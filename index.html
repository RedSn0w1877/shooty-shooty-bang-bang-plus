<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShootyShooty BangBang Plus - v6.5</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1.5rem 1rem 3rem;
            background: #05080f;
            color: #e2e8f0;
        }
        body.hell-mode { background: #12070f; }
        body.endless-mode { background: #071320; }
        #versionDisplay {
            position: fixed;
            top: 1rem;
            right: 1rem;
            font-size: 0.75rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            background: rgba(15, 23, 42, 0.85);
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            border: 1px solid #1f2937;
            color: #94a3b8;
            z-index: 10;
        }
        .game-container {
            width: min(960px, 100%);
            background: #101a24;
            border-radius: 12px;
            border: 1px solid #1c2635;
            padding: clamp(1rem, 2.5vw, 1.6rem);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        .game-title {
            font-size: clamp(2rem, 4vw, 2.75rem);
            font-weight: 700;
            margin: 0;
            color: #f8fafc;
        }
        .game-tagline {
            margin: -0.25rem 0 0.75rem;
            color: #94a3b8;
            font-size: clamp(0.95rem, 2vw, 1.1rem);
        }
        .ui-top-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem;
        }
        .ui-chip {
            background: #0c1522;
            border: 1px solid #1b2838;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }
        .ui-chip--score {
            justify-content: center;
            font-weight: 600;
            color: #38bdf8;
        }
        .ui-chip--shots {
            justify-content: center;
            font-weight: 600;
            color: #facc15;
        }
        .chip-title {
            font-weight: 600;
            font-size: 1rem;
        }
        .chip-label {
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #64748b;
        }
        .health-bar-container, .charge-container {
            width: 100%;
            height: 10px;
            background: #132032;
            border-radius: 8px;
            overflow: hidden;
        }
        .health-bar-inner, .charge-bar {
            height: 100%;
            border-radius: inherit;
            transition: width 0.2s ease;
        }
        .health-bar-inner { background: #34d399; }
        .beam-charge-bar { background: #f59e0b; }
        .smash-charge-bar { background: #f472b6; }
        .beam-charge-bar.ready, .smash-charge-bar.ready {
            filter: saturate(1.2);
        }
        #stageRow {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        .stage-info {
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: #e2e8f0;
        }
        .pause-indicator {
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            background: #162235;
            border: 1px solid #253246;
            color: #e2e8f0;
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            max-width: 100%;
            background: #050b15;
            border: 1px solid #1c2838;
            border-radius: 10px;
            cursor: crosshair;
        }
        .select-none { user-select: none; }
        .controls-hint {
            margin: -0.25rem 0 0;
            font-size: 0.85rem;
            color: #64748b;
        }
        .extra-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .button {
            background: #1e293b;
            color: #e2e8f0;
            border: 1px solid #334155;
            border-radius: 10px;
            padding: 0.5rem 0.9rem;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
        }
        .button:hover { background: #273548; }
        .button:active { transform: scale(0.98); }
        .button-primary { background: #2563eb; border-color: #1d4ed8; }
        .button-primary:hover { background: #1d4ed8; }
        .button-secondary { background: #0f172a; }
        .button-danger { background: #dc2626; border-color: #b91c1c; }
        .button-special { background: #f97316; border-color: #ea580c; }
        .button-godmode { background: #eab308; border-color: #ca8a04; color: #111827; }
        .button-healthboost { background: #22c55e; border-color: #16a34a; }
        .button-finish { background: #38bdf8; border-color: #0ea5e9; color: #0f172a; }
        .button-close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 50%;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            border: 1px solid #1e293b;
            cursor: pointer;
        }
        .controls-info {
            background: #0c1522;
            border-radius: 10px;
            border: 1px solid #1b2838;
            padding: 0.75rem 1rem;
            color: #94a3b8;
            font-size: 0.9rem;
        }
        .controls-accent { color: #f8fafc; font-weight: 600; }
        .controls-heading {
            margin: 0 0 0.35rem;
            font-weight: 600;
            color: #e2e8f0;
        }
        .controls-detail { font-size: 0.8rem; color: #64748b; margin: 0.35rem 0 0; }
        .hidden { display: none !important; }
        #tempPopup,
        #messageBox,
        #changelogPopup,
        #licensePopup,
        #namePopup,
        #loadingScreen,
        #adminPasswordPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background: rgba(10, 18, 30, 0.95);
            border: 1px solid rgba(30, 41, 59, 0.8);
            border-radius: 14px;
            padding: 1.5rem 1.75rem;
            color: #e2e8f0;
            box-shadow: 0 24px 48px rgba(5, 8, 15, 0.6);
            width: min(92vw, 520px);
            max-width: 520px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease, transform 0.25s ease;
            z-index: 200;
        }
        #tempPopup {
            top: auto;
            bottom: 2.5rem;
            width: auto;
            min-width: 220px;
            padding: 0.75rem 1.25rem;
            text-align: center;
            font-size: 0.95rem;
            letter-spacing: 0.04em;
            transform: translate(-50%, 10px) scale(0.95);
            z-index: 150;
        }
        #tempPopup.visible { transform: translate(-50%, 0) scale(1); }
        #messageBox,
        #changelogPopup,
        #loadingScreen {
            max-width: 640px;
        }
        #licensePopup { transform: translate(-50%, -60%) scale(0.92); }
        #namePopup { transform: translate(-50%, -40%) scale(0.92); }
        #loadingScreen { transform: translate(-50%, -50%) scale(0.92); }
        #adminPasswordPopup { border-color: rgba(234, 179, 8, 0.8); }
        .visible {
            opacity: 1;
            pointer-events: auto;
        }
        #tempPopup.visible,
        #messageBox.visible,
        #changelogPopup.visible,
        #licensePopup.visible,
        #namePopup.visible,
        #loadingScreen.visible,
        #adminPasswordPopup.visible {
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
        .popup-title {
            margin: 0 0 0.75rem;
            font-size: 1.35rem;
            font-weight: 600;
            color: #f8fafc;
        }
        .mb-4 { margin-bottom: 1.25rem; }
        .input-group {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .input-group input {
            flex: 1 1 180px;
            background: #0b1624;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 0.55rem 0.75rem;
            font-size: 1rem;
            color: #e2e8f0;
        }
        .input-group input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.25);
        }
        .error-text {
            color: #f87171;
            font-size: 0.85rem;
            margin-top: 0.5rem;
        }
        .input-error {
            animation: inputShake 0.3s ease;
            border-color: #f87171 !important;
        }
        @keyframes inputShake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px); }
            40%, 80% { transform: translateX(6px); }
        }
        #messageBox,
        #changelogPopup,
        #licensePopup,
        #namePopup,
        #loadingScreen,
        #adminPasswordPopup {
            text-align: center;
        }
        #messageBox .button,
        #changelogPopup .button,
        #licensePopup .button,
        #namePopup .button,
        #loadingScreen .button,
        #adminPasswordPopup .button {
            min-width: 140px;
        }
        .message-box-text {
            margin: 0;
            font-size: 1.05rem;
            color: #f8fafc;
        }
        #codeInputSection {
            margin-top: 1.25rem;
        }
        .button-row,
        .mode-selection-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }
        #changelogContent {
            max-height: min(50vh, 420px);
            overflow-y: auto;
            text-align: left;
            padding-right: 0.5rem;
            font-size: 0.95rem;
            line-height: 1.6;
            color: #cbd5f5;
        }
        #loadingProgressBarContainer {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: #132032;
            overflow: hidden;
        }
        #loadingProgressBar {
            width: 0;
            height: 100%;
            background: linear-gradient(90deg, #38bdf8, #2563eb);
            transition: width 0.2s ease;
        }
        #leaderboardContainer {
            background: #0c1522;
            border: 1px solid #1b2838;
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1.25rem;
        }
        .leaderboard-title {
            margin: 0 0 0.75rem;
            font-size: 1.2rem;
            color: #f8fafc;
        }
        #leaderboardList {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 0.35rem;
        }
        .leaderboard-hint {
            margin: 0.75rem 0 0;
            font-size: 0.8rem;
            color: #64748b;
            text-align: center;
        }
        @media (max-width: 720px) {
            body { padding: 1.25rem 0.5rem 2.25rem; }
            .game-container { border-radius: 14px; }
            #messageBox,
            #changelogPopup,
            #licensePopup,
            #namePopup,
            #loadingScreen,
            #adminPasswordPopup {
                width: min(94vw, 480px);
                padding: 1.25rem 1.5rem;
            }
            .input-group { flex-direction: column; align-items: stretch; }
            .input-group input { width: 100%; }
        }
    </style>
</head>
<body class="select-none">
    <div id="versionDisplay" class="version-box">V6.5</div>
    <div id="tempPopup" class="hidden"></div>
 
    <div id="licensePopup" class="hidden">
        <h2 class="popup-title">Game Integrity Protection GIP</h2>
        <p class="mb-4">Please enter your license key to play this game.</p>
        <div class="input-group">
            <input type="text" id="licenseKeyInput" placeholder="Enter License Key">
            <button id="submitLicenseKeyButton" class="button button-primary" type="button">Verify Key</button>
        </div>
        <p id="licenseErrorText" class="error-text hidden">Invalid License Key!</p>
    </div>

    <div id="namePopup" class="hidden">
        <h2 class="popup-title">Integrity Verified.</h2>
        <p class="mb-4">Please enter your name.</p>
        <div class="input-group">
            <input type="text" id="playerNameInput" placeholder="Enter Your Name">
            <button id="submitPlayerNameButton" class="button button-primary" type="button">Start Game</button>
        </div>
    </div>

    <div id="loadingScreen" class="hidden">
        <h2 id="loadingWelcomeText" class="popup-title">Welcome!</h2>
        <p class="mb-4">We're loading your game environment, please wait.</p>
        <div id="loadingProgressBarContainer">
            <div id="loadingProgressBar"></div>
        </div>
    </div>

    <!-- NEW ADMIN PASSWORD POPUP -->
    <div id="adminPasswordPopup" class="hidden">
        <h2 class="popup-title">Admin Access</h2>
        <p class="mb-4">Enter the password to access admin features.</p>
        <div class="input-group">
            <input type="password" id="adminPasswordInput" placeholder="Enter Password">
            <button id="submitAdminPasswordButton" class="button button-godmode" type="button">Submit</button>
        </div>
        <p id="adminPasswordError" class="error-text hidden">Invalid Password!</p>
        <button id="closeAdminPasswordPopup" class="button-close" type="button">&times;</button>
    </div>
    <!-- END NEW POPUP -->


    <div id="mainGameContent" class="hidden">
        <div class="game-container">
            <h1 class="game-title">ShootyShooty BangBang Plus</h1>
            <p class="game-tagline">Stay sharp, keep moving, and survive as long as you can.</p>
            <div class="ui-top-bar">
                <div id="healthDisplayContainer" class="ui-chip ui-chip--health">
                    <span id="healthText" class="chip-title">Health: 100</span>
                    <div class="health-bar-container">
                        <div id="healthBarInner" class="health-bar-inner"></div>
                    </div>
                </div>
                <div id="scoreDisplay" class="ui-chip ui-chip--score">Score: 0</div>
                <div class="ui-chip">
                    <span class="chip-label">Beam</span>
                    <div class="charge-container">
                        <div id="beamChargeBar" class="charge-bar beam-charge-bar"></div>
                    </div>
                </div>
                <div class="ui-chip">
                    <span class="chip-label">Smash</span>
                    <div class="charge-container">
                        <div id="smashChargeBar" class="charge-bar smash-charge-bar"></div>
                    </div>
                </div>
                <div id="bulletCountDisplay" class="ui-chip ui-chip--shots">Shots: 1</div>
            </div>

            <div id="stageRow">
                <div id="stageDisplay" class="stage-info">Stage 1: Wave 1</div>
                <div id="pauseIndicator" class="pause-indicator hidden">Paused</div>
            </div>
            <canvas id="gameCanvas"></canvas>
            <p class="controls-hint">Press P to pause, Q to dash, and hold the mouse button to keep firing.</p>

            <div class="extra-buttons-container">
                <button id="aimbotButton" class="button button-secondary" type="button">Aimbot</button>
                <button id="changelogButton" class="button button-secondary" type="button">Changelog</button>
                <button id="invincibilityButton" class="button button-godmode" type="button">Invincibility</button>
                <button id="plusHealthButton" class="button button-healthboost" type="button">+100 Health</button>
                <button id="finishGameButton" class="button button-finish" type="button">Finish Game</button>
            </div>

            <div id="messageBox" class="hidden">
                <p id="messageText" class="message-box-text"></p>
                <div id="codeInputSection" class="hidden input-group">
                    <input type="text" id="codeInput" placeholder="Enter Code">
                    <button id="submitCodeButton" class="button button-primary" type="button">Submit</button>
                    <button id="cancelCodeButton" class="button button-secondary" type="button">Cancel</button>
                </div>
                <div id="deathOptions" class="hidden button-row">
                    <button id="actionButton1" class="button button-primary" type="button">Play Again</button>
                    <button id="actionButton2" class="button button-secondary" type="button">Revive</button>
                </div>
                <div id="completionOptions" class="hidden mode-selection-buttons">
                    <button id="hellModeButton" class="button button-danger" type="button">Hell Mode</button>
                    <button id="endlessModeButton" class="button button-special" type="button">Endless Mode</button>
                </div>
                <div id="hellConfirmOptions" class="hidden mode-selection-buttons">
                    <button id="confirmHellButton" class="button button-danger" type="button">Yes, Unleash Hell!</button>
                    <button id="cancelHellButton" class="button button-secondary" type="button">Maybe Later</button>
                </div>
                <button id="closeMessageBoxButton" class="button-close" type="button">&times;</button>
            </div>

            <div id="changelogPopup" class="hidden">
                <h2 class="popup-title changelog-title">Changelog</h2>
                <div id="changelogContent">
                    <p>6.5: Revive password changed to 'ultrasecretpasscode'.</p>
                    <p>6.4: Added password protection to admin controls ('Invincibility', '+100 Health', 'Finish Game'). Admin access is now granted for the entire session after one successful login. Game version updated and title renamed to 'ShootyShooty BangBang Plus'.</p>
                    <p>6.2: fixed enemy health bar display. Added Green (+50HP) and Golden (+150HP) health power-ups cause duh. Enhanced particle effects for explosions and power-up collection. Screen shake on Smash & enemy death >:) </p>
                    <p>6.1: fixed GIP input issue with game control keys. beam attack now correctly uses sigma aimbot at the nearest enemy. refined bullet homing to prevent circling at close distance or whatever</p>
                    <p>6.0: fixed beam auto-aim. improved bullet homing to prevent circling at close range. enemy bullets no longer wrap.</p>
                    <p>5.9: fixed page scrolling. beam attack now auto-aims at nearest enemy. Added more background stars. Buttons now have an outline style. Fixed bullet homing issue circle. bullets now rebound instead of despawn for amore CHAOOSOSOSOSOSOSOSO</p>
                    <p>5.8: game title updated to "Shooty Shooty Bang Bang PLUS".resizing logic adjusted to make the game area larger because it kept.</p>
                    <p>5.7: changed 8-bit fonts to a smoother sans-serif font for a calmer feel and not like arcade pew pew pew pew</p>
                    <p>5.6: aimbot password changed.</p>
                    <p>5.5: player icon changed to a fox emoji cause old one looked like a fuckin box. particle logic adjusted for new shape.</p>
                    <p>5.4: added new power-ups: Rapid Fire, Shield, Speed Boost. power-up spawn timer no longer resets on wave/stage change. power-ups spawn every 10-20s.</p>
                    <p>5.3: ssssslightly increased bullet homing strength. Added more stars to the background for a cooler background hehe</p>
                    <p>5.2: added health bar. Added 'Finish Game' button. Adjusted Hell mode (slightly easier) & Normal mode (easier) difficulty. Changed main font to serif.</p>
                    <p>5.1: nerfed bullet homing strength. made Normal mode easier (enemy health/speed, wave length???)</p>
                    <p>5.0: created shooty shooty bang bang plus. more features, so beautiful and supports creator :D<p>
                    <p>4.9: moved Aimbot & Changelog buttons for better visibility below playing area field thingy Buttons are now larger.</p>
                    <p>4.8: fixed revive because it would freeze the game.</p>
                    <p>4.7: major major major major visual overhaul! dded animated backgrounds, particle effects, smoother animations, improved UI styling, and enhanced entity designs. player has a directional pointer. projectiles have cool trails</p>
                    <p>4.6: revamped enemy tracking and speed, upgraded AI and smarter enemies.</p>
                    <p>4.5: added endless and hell mode. polished everything and added to github</p>
                    <p>4.4: added changelog</p>
                    <p>4.3: fixed aimbot because it kept crashing the testing environment</p>
                    <p>4.2: added aimbot with secret code</p>
                    <p>4.1: rewrote the entire code cause it literally just wouldn't run</p>
                    <p>4.0: added revive feature with secret code</p>
                    <p>3.4: changed overall look to entities with more shapes and colors</p>
                    <p>3.3: bugfixes</p>
                    <p>3.2: added more friendly arrow movement</p>
                    <p>3.1: fixed mouse control mode</p>
                    <p>3.0: added mouse control mode</p>
                    <p>2.2: attempted background music, failed miserably</p>
                    <p>2.0: brand new UI with new colors and faces to enemies (AHH ITS SO GOOD)</p>
                    <p>1.4: bugfixing cause it broken</p>
                    <p>1.3: updated beam attack UI cause it looks like Microsoft paint</p>
                    <p>1.2: new attack mode: beam</p>
                    <p>1.1: new UI cause old one was hella ugly</p>
                    <p>1.0: initial release, what did you expect</p>
                </div>
                <button id="closeChangelogButton" class="button-close" type="button">&times;</button>
            </div>

            <div class="controls-info">
                <p class="controls-heading">Controls</p>
                <p><span class="controls-accent">Player:</span> WASD to Move, Space/Click to Shoot, hold Click in Mouse Aim, B for Beam, X for Smash, Q to Dash, P to Pause, M for Mouse Aim</p>
                <p class="controls-detail">Beam: 21s, Smash: 37.5s. Targets hurt on touch! Enemy shots curve slightly.</p>
            </div>

            <div id="leaderboardContainer" class="hidden">
                <h2 class="leaderboard-title">Local Leaderboard</h2>
                <ul id="leaderboardList"></ul>
                <p class="leaderboard-hint">(Scores are saved in this browser only)</p>
            </div>
        </div>
    </div>


    <script>
    function normalizeAngle(angle) {
        while (angle > Math.PI) { angle -= 2 * Math.PI; }
        while (angle < -Math.PI) { angle += 2 * Math.PI; }
        return angle;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stageDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthText = document.getElementById('healthText');
        const healthBarInner = document.getElementById('healthBarInner');
        const tempPopup = document.getElementById('tempPopup');
        const aimbotButton = document.getElementById('aimbotButton');
        const changelogButton = document.getElementById('changelogButton');
        const invincibilityButton = document.getElementById('invincibilityButton');
        const plusHealthButton = document.getElementById('plusHealthButton');
        const finishGameButton = document.getElementById('finishGameButton');
        const changelogPopup = document.getElementById('changelogPopup');
        const closeChangelogButton = document.getElementById('closeChangelogButton');
        const closeMessageBoxButton = document.getElementById('closeMessageBoxButton');
        const bulletCountDisplay = document.getElementById('bulletCountDisplay');
        const versionDisplay = document.getElementById('versionDisplay');

        const licensePopup = document.getElementById('licensePopup');
        const licenseKeyInput = document.getElementById('licenseKeyInput');
        const submitLicenseKeyButton = document.getElementById('submitLicenseKeyButton');
        const licenseErrorText = document.getElementById('licenseErrorText');
        const namePopup = document.getElementById('namePopup');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitPlayerNameButton = document.getElementById('submitPlayerNameButton');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingWelcomeText = document.getElementById('loadingWelcomeText');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const mainGameContent = document.getElementById('mainGameContent');

        // NEW: Admin Popup Elements
        const adminPasswordPopup = document.getElementById('adminPasswordPopup');
        const adminPasswordInput = document.getElementById('adminPasswordInput');
        const submitAdminPasswordButton = document.getElementById('submitAdminPasswordButton');
        const closeAdminPasswordPopup = document.getElementById('closeAdminPasswordPopup');
        const adminPasswordError = document.getElementById('adminPasswordError');

        const GAME_VERSION = "v6.5";
        let CANVAS_WIDTH = 800;
        let CANVAS_HEIGHT = 600;
        const PLAYER_WIDTH = 30;
        const PLAYER_HEIGHT = 30;
        const PROJECTILE_WIDTH = 10;
        const PROJECTILE_HEIGHT = 5;
        const ENEMY_PROJECTILE_WIDTH = 8;
        const ENEMY_PROJECTILE_HEIGHT = 8;
        const POWERUP_SIZE = 25;
        const BEAM_THICKNESS = 25;
        const TARGET_SIZE_MIN = 20;
        const TARGET_SIZE_MAX = 35;
        const TARGET_BASE_SPEED = 0.25;
        const TARGET_SPEED_INCREMENT = 0.03;
        const TARGET_CONTACT_DAMAGE = 8;
        const SCORE_PER_HIT = 55;
        const SCORE_PER_BEAM_FRAME = 4;
        const SCORE_PER_SMASH_HIT = 30;
        const MAX_WAVES_PER_LEVEL = 3;
        const COMPLETION_STAGE = 10;
        const BEAM_CHARGE_MAX = 21000;
        const SMASH_CHARGE_MAX = 37500;
        const BEAM_ACTIVE_DURATION = 1800;
        const POWERUP_SPAWN_INTERVAL_MIN = 10000;
        const POWERUP_SPAWN_INTERVAL_MAX = 20000;
        const HEALTH_PACK_GREEN_SPAWN_MIN = 10000;
        const HEALTH_PACK_GREEN_SPAWN_MAX = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MIN = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MAX = 20000;
        const POWERUP_LIFETIME = 8000;
        const POWERUP_DURATION = 7000;
        const MAX_BULLET_COUNT = 5;
        const MAX_PARTICLES = 220;
        const HELL_MODE_SPAWN_INTERVAL = 1200;
        const HELL_MODE_EXTRA_SPAWN_COUNT = 2;
        const REVIVE_INVULNERABILITY_DURATION = 3000;
        const STARFIELD_MIN_COUNT = 80;
        const STARFIELD_MAX_COUNT = 220;

        let gameRunning = false;
        let currentStage = 1;
        let currentWave = 1;
        let targetsPerWaveBase = 2;
        let gameTargets = [];
        let enemyProjectiles = [];
        let powerUps = [];
        let terrainObstacles = [];
        let playerScore = 0;
        let mouseAimActive = true;
        let mouseX = 0;
        let mouseY = 0;
        let aimbotActive = false;
        const AIMBOT_SHOOT_DELAY = 35;
        let currentPopupAction = null;
        let gameMode = 'normal';
        let nextPowerUpSpawnTime = 0;
        let nextGreenHealthPackSpawnTime = 0;
        let nextGoldenHealthPackSpawnTime = 0;
        let nextHellSpawnTime = 0;
        let globalPlayerName = "Player";
        let starfieldDots = [];

        function regenerateStarfield() {
            const area = Math.max(1, CANVAS_WIDTH * CANVAS_HEIGHT);
            const targetCount = Math.max(
                STARFIELD_MIN_COUNT,
                Math.min(STARFIELD_MAX_COUNT, Math.floor(area / 2400))
            );
            starfieldDots = new Array(targetCount).fill(null).map(() => {
                const pulses = Math.random() < 0.3;
                const size = 0.7 + Math.random() * 1.1;
                return {
                    x: Math.random() * (CANVAS_WIDTH - size) + size / 2,
                    y: Math.random() * (CANVAS_HEIGHT - size) + size / 2,
                    size,
                    baseAlpha: 0.35 + Math.random() * 0.45,
                    pulseSpeed: pulses ? (0.45 + Math.random() * 0.4) : 0,
                    pulseAmplitude: pulses ? (0.12 + Math.random() * 0.18) : 0,
                    phase: Math.random() * Math.PI * 2
                };
            });
        }

        function drawStarfield(deltaTime) {
            ctx.fillStyle = '#05080f';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            if (!starfieldDots.length) { return; }
            const seconds = deltaTime / 1000;
            for (let i = 0; i < starfieldDots.length; i++) {
                const star = starfieldDots[i];
                if (star.pulseSpeed > 0) {
                    star.phase += seconds * star.pulseSpeed;
                }
                const intensity = star.baseAlpha + (star.pulseAmplitude * Math.sin(star.phase));
                const alpha = Math.min(1, Math.max(0.2, intensity));
                const size = star.size;
                ctx.fillStyle = `rgba(248, 250, 252, ${alpha})`;
                ctx.fillRect(star.x - size / 2, star.y - size / 2, size, size);
            }
            ctx.globalAlpha = 1;
        }

        // NEW: Admin Password State
        let pendingAdminAction = null;
        const ADMIN_PASSWORD = "admin123"; // <-- YOU CAN CHANGE THE PASSWORD HERE
        let isAdminAccessGranted = false; // <-- NEW: Tracks if admin is unlocked

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const codeInputSection = document.getElementById('codeInputSection');
        const codeInput = document.getElementById('codeInput');
        const submitCodeButton = document.getElementById('submitCodeButton');
        const cancelCodeButton = document.getElementById('cancelCodeButton');
        const deathOptions = document.getElementById('deathOptions');
        const completionOptions = document.getElementById('completionOptions');
        const hellModeButton = document.getElementById('hellModeButton');
        const endlessModeButton = document.getElementById('endlessModeButton');
        const hellConfirmOptions = document.getElementById('hellConfirmOptions');
        const confirmHellButton = document.getElementById('confirmHellButton');
        const cancelHellButton = document.getElementById('cancelHellButton');
        const actionButton1 = document.getElementById('actionButton1');
        const actionButton2 = document.getElementById('actionButton2');
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const leaderboardList = document.getElementById('leaderboardList');
        const pauseIndicator = document.getElementById('pauseIndicator');

        const FOX_TYPES = {
            "Ranger": {
                color: "hsl(25, 85%, 55%)",
                accentColor: "hsl(0, 0%, 95%)",
                eyeColor: "hsl(190, 100%, 30%)",
                shieldColor: "hsla(200, 100%, 80%, 0.3)",
                invulnerableShieldColor: "hsla(50, 100%, 70%, 0.7)",
                engineColor: "hsl(30, 100%, 50%)",
                baseSpeed: 3.8,
                health: 100,
                baseShootDelay: 220,
                projectileSpeed: 6.0,
                projectileColor: "hsl(50, 100%, 60%)"
            }
        };

        const keysPressed = {};
        let manualPause = false;
        let mouseFireHeld = false;
        versionDisplay.textContent = GAME_VERSION;

        function isGameEffectivelyPaused() {
            if (manualPause) {
                return true;
            }
            if (!mainGameContent.classList.contains('hidden')) {
                 // UPDATED: Added adminPasswordPopup
                 return messageBox.classList.contains('visible') ||
                        changelogPopup.classList.contains('visible') ||
                        adminPasswordPopup.classList.contains('visible');
            }
            return true;
        }

        function updatePauseIndicator() {
            if (!pauseIndicator) return;
            if (manualPause) {
                pauseIndicator.classList.remove('hidden');
            } else {
                pauseIndicator.classList.add('hidden');
            }
        }

        function setManualPause(state) {
            manualPause = state;
            if (manualPause) {
                mouseFireHeld = false;
            }
            updatePauseIndicator();
            if (!manualPause && gameRunning) {
                lastFrameTime = performance.now();
            }
        }

        function toggleManualPause() {
            setManualPause(!manualPause);
        }


        function rectanglesOverlap(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function isRectOverlappingObstacles(x, y, width, height, padding = 0) {
            const rect = {
                x: x - padding,
                y: y - padding,
                width: width + padding * 2,
                height: height + padding * 2
            };
            return terrainObstacles.some(obstacle => rectanglesOverlap(rect, obstacle));
        }

        function generateTerrainObstacles(stage) {
            terrainObstacles = [];
            if (CANVAS_WIDTH <= 0 || CANVAS_HEIGHT <= 0) { return; }

            const maxTotalArea = CANVAS_WIDTH * CANVAS_HEIGHT * 0.18;
            const scaledStage = Math.max(1, Math.floor((stage + 1) / 2));
            const obstacleCount = Math.min(5, scaledStage);
            const leftSafeWidth = Math.min(220, CANVAS_WIDTH * 0.28);
            const leftSafeHeight = Math.min(260, CANVAS_HEIGHT * 0.55);
            const centerSafeWidth = Math.min(300, CANVAS_WIDTH * 0.4);
            const centerSafeHeight = Math.min(360, CANVAS_HEIGHT * 0.6);
            const safeZones = [
                { x: 0, y: (CANVAS_HEIGHT - leftSafeHeight) / 2, width: leftSafeWidth, height: leftSafeHeight },
                { x: CANVAS_WIDTH / 2 - centerSafeWidth / 2, y: CANVAS_HEIGHT / 2 - centerSafeHeight / 2, width: centerSafeWidth, height: centerSafeHeight }
            ];

            let usedArea = 0;
            let attempts = 0;
            const maxAttempts = obstacleCount * 24;

            while (terrainObstacles.length < obstacleCount && attempts < maxAttempts) {
                attempts++;
                const minWidth = Math.max(48, CANVAS_WIDTH * 0.08);
                const maxWidth = Math.max(minWidth + 12, CANVAS_WIDTH * 0.18);
                const minHeight = Math.max(44, CANVAS_HEIGHT * 0.08);
                const maxHeight = Math.max(minHeight + 12, CANVAS_HEIGHT * 0.16);
                const width = Math.random() * (maxWidth - minWidth) + minWidth;
                const height = Math.random() * (maxHeight - minHeight) + minHeight;
                if (usedArea + width * height > maxTotalArea) { continue; }

                const margin = 40;
                const maxX = CANVAS_WIDTH - width - margin;
                const maxY = CANVAS_HEIGHT - height - margin;
                if (maxX <= margin || maxY <= margin) { break; }

                const x = Math.random() * (maxX - margin) + margin;
                const y = Math.random() * (maxY - margin) + margin;
                const candidate = { x, y, width, height };

                if (terrainObstacles.some(ob => rectanglesOverlap(ob, candidate))) { continue; }

                const paddedCandidate = {
                    x: candidate.x - 32,
                    y: candidate.y - 32,
                    width: candidate.width + 64,
                    height: candidate.height + 64
                };
                if (safeZones.some(zone => rectanglesOverlap(paddedCandidate, zone))) { continue; }

                terrainObstacles.push(candidate);
                usedArea += width * height;
            }
        }

        function drawTerrainObstacles() {
            if (!terrainObstacles.length) { return; }
            ctx.save();
            ctx.fillStyle = '#172135';
            ctx.strokeStyle = '#0f172a';
            ctx.lineWidth = 2;
            for (let i = 0; i < terrainObstacles.length; i++) {
                const obstacle = terrainObstacles[i];
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
            ctx.restore();
        }

        function resolveEntityObstacleCollision(entity, prevX, prevY) {
            if (!terrainObstacles.length) { return; }
            for (let i = 0; i < terrainObstacles.length; i++) {
                const obstacle = terrainObstacles[i];
                if (!rectanglesOverlap(entity, obstacle)) { continue; }
                if (prevX + entity.width <= obstacle.x) {
                    entity.x = obstacle.x - entity.width;
                } else if (prevX >= obstacle.x + obstacle.width) {
                    entity.x = obstacle.x + obstacle.width;
                } else if (prevY + entity.height <= obstacle.y) {
                    entity.y = obstacle.y - entity.height;
                } else if (prevY >= obstacle.y + obstacle.height) {
                    entity.y = obstacle.y + obstacle.height;
                } else {
                    const overlapLeft = entity.x + entity.width - obstacle.x;
                    const overlapRight = obstacle.x + obstacle.width - entity.x;
                    const overlapTop = entity.y + entity.height - obstacle.y;
                    const overlapBottom = obstacle.y + obstacle.height - entity.y;
                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                    if (minOverlap === overlapLeft) { entity.x = obstacle.x - entity.width; }
                    else if (minOverlap === overlapRight) { entity.x = obstacle.x + obstacle.width; }
                    else if (minOverlap === overlapTop) { entity.y = obstacle.y - entity.height; }
                    else { entity.y = obstacle.y + obstacle.height; }
                }
            }
        }

        function resolveProjectileObstacleCollision(projectile, prevX, prevY) {
            if (!terrainObstacles.length) { return; }
            for (let i = 0; i < terrainObstacles.length; i++) {
                const obstacle = terrainObstacles[i];
                if (!rectanglesOverlap(projectile, obstacle)) { continue; }
                const overlapLeft = projectile.x + projectile.width - obstacle.x;
                const overlapRight = obstacle.x + obstacle.width - projectile.x;
                const overlapTop = projectile.y + projectile.height - obstacle.y;
                const overlapBottom = obstacle.y + obstacle.height - projectile.y;
                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                if (minOverlap === overlapLeft) {
                    projectile.x = obstacle.x - projectile.width;
                    projectile.speedX = Math.abs(projectile.speedX);
                } else if (minOverlap === overlapRight) {
                    projectile.x = obstacle.x + obstacle.width;
                    projectile.speedX = -Math.abs(projectile.speedX);
                } else if (minOverlap === overlapTop) {
                    projectile.y = obstacle.y - projectile.height;
                    projectile.speedY = Math.abs(projectile.speedY);
                } else {
                    projectile.y = obstacle.y + projectile.height;
                    projectile.speedY = -Math.abs(projectile.speedY);
                }
                break;
            }
        }
        let particles = [];
        function createParticle(x, y, count, color, sizeRange, speedRange, lifeRange, angleSpread = Math.PI * 2) {
            if (!count || MAX_PARTICLES <= 0) { return; }
            const spawnCount = Math.min(count, Math.max(0, MAX_PARTICLES));
            for (let i = 0; i < spawnCount; i++) {
                const targetY = typeof mouseY === 'number' ? mouseY : y;
                const targetX = typeof mouseX === 'number' ? mouseX : x + 1;
                const angle = (Math.random() - 0.5) * angleSpread + Math.atan2(targetY - y, targetX - x);
                const speed = Math.random() * (speedRange[1] - speedRange[0]) + speedRange[0];
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    size: Math.random() * (sizeRange[1] - sizeRange[0]) + sizeRange[0],
                    life: Math.random() * (lifeRange[1] - lifeRange[0]) + lifeRange[0], maxLife: lifeRange[1],
                    color: color, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
            if (particles.length > MAX_PARTICLES) {
                particles.splice(0, particles.length - MAX_PARTICLES);
            }
        }

        function updateAndDrawParticles(deltaTime) {
            if (!particles.length) { return; }
            const dtFactor = deltaTime / 16.67;
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dtFactor; p.y += p.vy * dtFactor;
                p.vx *= 0.98; p.vy *= 0.98; p.life -= deltaTime; p.rotation += p.rotationSpeed * dtFactor;
                if (p.life <= 0) { particles.splice(i, 1); } else {
                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color; const opacity = Math.max(0, p.life / p.maxLife);
                    ctx.globalAlpha = opacity * 0.8; ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();
                }
            }
            ctx.globalAlpha = 1;
        }

        window.addEventListener('keydown', (e) => {
            // UPDATED: Added adminPasswordInput
            const activePopupInput = document.activeElement === licenseKeyInput ||
                                     document.activeElement === playerNameInput ||
                                     (document.activeElement === codeInput && !codeInputSection.classList.contains('hidden')) ||
                                     document.activeElement === adminPasswordInput;

            if (activePopupInput) {
                if (e.code === 'Enter') {
                    e.preventDefault();
                    if (document.activeElement === licenseKeyInput) submitLicenseKeyButton.click();
                    else if (document.activeElement === playerNameInput) submitPlayerNameButton.click();
                    else if (document.activeElement === codeInput) submitCodeButton.click();
                    else if (document.activeElement === adminPasswordInput) submitAdminPasswordButton.click(); // NEW
                }
                return;
            }

            if (e.code === 'KeyP' && !mainGameContent.classList.contains('hidden')) {
                if (!messageBox.classList.contains('visible') && !changelogPopup.classList.contains('visible') && !adminPasswordPopup.classList.contains('visible')) {
                    toggleManualPause();
                }
                e.preventDefault();
                return;
            }

            if (e.code === 'Escape') {
                if (changelogPopup.classList.contains('visible')) {
                    hidePopup(changelogPopup); currentPopupAction = null; return;
                }
                // NEW: Handle admin popup escape
                if (adminPasswordPopup.classList.contains('visible')) {
                    hidePopup(adminPasswordPopup);
                    currentPopupAction = null;
                    pendingAdminAction = null;
                    return;
                }
                if (messageBox.classList.contains('visible')) {
                    if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                        messageText.textContent = "Game Over!";
                        codeInputSection.classList.add('hidden');
                        deathOptions.classList.remove('hidden');
                        currentPopupAction = 'game_over_options';
                        return;
                    } else if (['aimbot', 'hell_confirm', 'game_complete'].includes(currentPopupAction)) {
                         hidePopup(messageBox); currentPopupAction = null; return;
                    }
                }
            }

            if (isGameEffectivelyPaused() && !mainGameContent.classList.contains('hidden')) {
                 if (e.code === 'Space' || e.code.startsWith('Arrow') || ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyB', 'KeyX', 'KeyM', 'KeyQ'].includes(e.code)) {
                     e.preventDefault();
                 }
                 return;
            } else if (licensePopup.classList.contains('visible') || namePopup.classList.contains('visible') || loadingScreen.classList.contains('visible')) {
                if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyX', 'KeyM', 'KeyQ'].includes(e.code)) {
                    e.preventDefault();
                }
                return;
            }

            keysPressed[e.code] = true;
            if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) { e.preventDefault(); }
            if (e.code === 'KeyM') { toggleMouseAim(); }
            if (e.code === 'KeyX' && player1 && player1.smashReady && !player1.isSmashing) { player1.fireSmash(); }
            if (e.code === 'KeyQ' && player1) {
                if (player1.tryDash()) { e.preventDefault(); }
            }
        });
        window.addEventListener('keyup', (e) => { keysPressed[e.code] = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (isGameEffectivelyPaused()) return;
            const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('mousedown', () => {
            if (isGameEffectivelyPaused()) return;
            mouseFireHeld = true;
            if (mouseAimActive && !aimbotActive && player1 && player1.health > 0) { player1.shoot(true); }
        });
        canvas.addEventListener('touchstart', (e) => {
            if (isGameEffectivelyPaused()) return;
            const touch = e.changedTouches[0];
            if (!touch) { return; }
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            mouseFireHeld = true;
            if (mouseAimActive && !aimbotActive && player1 && player1.health > 0) { player1.shoot(true); }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            if (isGameEffectivelyPaused()) return;
            const touch = e.changedTouches[0];
            if (!touch) { return; }
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
        }, { passive: false });
        window.addEventListener('mouseup', () => { mouseFireHeld = false; });
        canvas.addEventListener('mouseleave', () => { mouseFireHeld = false; });
        canvas.addEventListener('touchend', () => { mouseFireHeld = false; });
        canvas.addEventListener('touchcancel', () => { mouseFireHeld = false; });
        window.addEventListener('blur', () => { mouseFireHeld = false; });

        function showPopup(element) {
            element.classList.remove('hidden');
            setTimeout(() => element.classList.add('visible'), 10);
        }
        function hidePopup(element) {
            element.classList.remove('visible');
            setTimeout(() => element.classList.add('hidden'), 600);
        }

        submitLicenseKeyButton.addEventListener('click', () => {
            if (licenseKeyInput.value.trim() === "64446644") {
                licenseErrorText.classList.add('hidden');
                licenseKeyInput.classList.remove('input-error');
                hidePopup(licensePopup);
                setTimeout(() => {
                    showPopup(namePopup);
                    playerNameInput.focus();
                }, 300);
            } else {
                licenseErrorText.classList.remove('hidden');
                licenseKeyInput.classList.add('input-error');
                setTimeout(() => licenseKeyInput.classList.remove('input-error'), 300);
                licenseKeyInput.value = "";
                licenseKeyInput.focus();
            }
        });

        submitPlayerNameButton.addEventListener('click', () => {
            globalPlayerName = playerNameInput.value.trim() || "Player";
            hidePopup(namePopup);
            setTimeout(() => {
                loadingWelcomeText.textContent = `Welcome to ShootyShooty BangBang Plus, ${globalPlayerName}! We're loading your game environment, please wait.`;
                showPopup(loadingScreen);
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 1;
                    loadingProgressBar.style.width = `${progress}%`;
                    if (progress >= 100) {
                        clearInterval(interval);
                        hidePopup(loadingScreen);
                        setTimeout(startGame, 300);
                    }
                }, 100); // Increased loading time slightly
            }, 300);
        });


        aimbotButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && currentPopupAction !== 'aimbot') return;
            if (aimbotActive) { aimbotActive = false; showTemporaryPopup("Aimbot Deactivated!"); return; }
            messageText.textContent = "Enter Admin Code:";
            codeInputSection.classList.remove('hidden'); deathOptions.classList.add('hidden');
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden');
            showPopup(messageBox); codeInput.value = ""; codeInput.focus(); currentPopupAction = 'aimbot';
        });

        actionButton2.addEventListener('click', () => {
            if (currentPopupAction === 'game_over_options') {
                messageText.textContent = "Enter Revive Code:";
                codeInputSection.classList.remove('hidden');
                deathOptions.classList.add('hidden');
                codeInput.value = "";
                codeInput.focus();
                currentPopupAction = 'revive_code_input';
            }
        });

        changelogButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && !changelogPopup.classList.contains('visible')) return;
            showPopup(changelogPopup); currentPopupAction = 'changelog';
        });

        // --- NEW ADMIN ACCESS LOGIC ---

        function requestAdminAccess(action) {
            // Don't show if another popup is already active
            if (isGameEffectivelyPaused() && !adminPasswordPopup.classList.contains('visible')) return;

            pendingAdminAction = action;
            adminPasswordInput.value = "";
            adminPasswordError.classList.add('hidden');
            adminPasswordInput.classList.remove('input-error');
            showPopup(adminPasswordPopup);
            adminPasswordInput.focus();
            currentPopupAction = 'admin_password'; // To help with pause logic
        }

        function executeAdminAction(action) {
            if (!player1 && (action === 'invincibility' || action === 'health')) return;

            switch (action) {
                case 'invincibility':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.isDivineProtectionActive = !player1.isDivineProtectionActive;
                        if (player1.isDivineProtectionActive) {
                            player1.health = 1000;
                            player1.initialHealth = 1000;
                            showTemporaryPopup("Divine Protection Activated!");
                        } else {
                            player1.health = Math.min(player1.health, player1.type.health);
                            player1.initialHealth = player1.type.health;
                            showTemporaryPopup("Divine Protection Deactivated!");
                        }
                        updateUI();
                    }
                    break;
                case 'health':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.health += 100;
                        if (player1.isDivineProtectionActive) {
                            player1.health = Math.min(player1.health, 1000);
                        } else {
                            player1.initialHealth = Math.max(player1.initialHealth, player1.health, player1.type.health);
                        }
                        updateUI();
                        showTemporaryPopup("+100 Health!");
                    }
                    break;
                case 'finish':
                     if (!isGameEffectivelyPaused()) {
                        showGameCompletionPopup();
                     }
                    break;
            }
        }

        // UPDATED: Re-wired admin buttons to new password prompt
        invincibilityButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('invincibility');
            } else {
                requestAdminAccess('invincibility');
            }
        });

        plusHealthButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('health');
            } else {
                requestAdminAccess('health');
            }
        });

        finishGameButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('finish');
            } else {
                requestAdminAccess('finish');
            }
        });

        // NEW: Event listeners for admin password popup
        closeAdminPasswordPopup.addEventListener('click', () => {
            hidePopup(adminPasswordPopup);
            pendingAdminAction = null;
            currentPopupAction = null;
        });

        submitAdminPasswordButton.addEventListener('click', () => {
            if (adminPasswordInput.value === ADMIN_PASSWORD) {
                isAdminAccessGranted = true; // <-- Grant access
                hidePopup(adminPasswordPopup);
                executeAdminAction(pendingAdminAction);
                pendingAdminAction = null;
                currentPopupAction = null;
                adminPasswordInput.value = "";
                adminPasswordError.classList.add('hidden');
                adminPasswordInput.classList.remove('input-error');
                showTemporaryPopup("Admin Access Granted!"); // Notify user
            } else {
                adminPasswordError.classList.remove('hidden');
                adminPasswordInput.classList.add('input-error');
                setTimeout(() => adminPasswordInput.classList.remove('input-error'), 300);
                adminPasswordInput.value = "";
                adminPasswordInput.focus();
            }
        });

        // --- END NEW ADMIN LOGIC ---


        hellModeButton.addEventListener('click', () => {
            messageText.textContent = "Warning: Hell Mode is for HIGHLY ADVANCED PLAYERS ONLY. Proceed?";
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.remove('hidden');
            showPopup(messageBox); currentPopupAction = 'hell_confirm';
        });

        endlessModeButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'endless';
            document.body.classList.remove('hell-mode'); document.body.classList.add('endless-mode');
            setManualPause(false);
            showTemporaryPopup("Thanks for playing! Enjoy Endless Mode!");
            player1.reset(true); initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        confirmHellButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'hell';
            document.body.classList.remove('endless-mode'); document.body.classList.add('hell-mode');
            setManualPause(false);
            stageDisplay.textContent = "HELL MODE ENABLED";
            player1.reset(true); player1.health = 200; player1.initialHealth = 200;
            targetsPerWaveBase = 3;
            initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        cancelHellButton.addEventListener('click', () => {
            messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            currentPopupAction = 'game_complete';
        });

        closeChangelogButton.addEventListener('click', () => { hidePopup(changelogPopup); currentPopupAction = null; });
        closeMessageBoxButton.addEventListener('click', () => {
            hidePopup(messageBox);
            if (currentPopupAction === 'game_over_options' || currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                 leaderboardContainer.classList.add('hidden');
            }
            currentPopupAction = null;
        });

        submitCodeButton.addEventListener('click', () => {
            const code = codeInput.value.trim().toLowerCase();
            if (currentPopupAction === 'aimbot') {
                if (code === "ultrasecretpassword") {
                    aimbotActive = true;
                    showTemporaryPopup("Aimbot Enabled!");
                } else {
                    showTemporaryPopup("Incorrect Code.");
                }
                hidePopup(messageBox); currentPopupAction = null;
            } else if (currentPopupAction === 'revive_code_input') {
                if (code === "ultrasecretpasscode") {
                    player1.reset(false);
                    player1.health = player1.isDivineProtectionActive ? 1000 : player1.initialHealth;
                    player1.isInvulnerable = true; player1.invulnerableUntil = Date.now() + REVIVE_INVULNERABILITY_DURATION;
                    gameRunning = true; lastFrameTime = performance.now();
                    hidePopup(messageBox); leaderboardContainer.classList.add('hidden');
                    requestAnimationFrame(gameLoop); currentPopupAction = null;
                } else {
                    messageText.textContent = "Incorrect Code. Try Respawn?";
                    codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                    currentPopupAction = 'revive_failed';
                }
            }
            codeInput.value = "";
        });

        cancelCodeButton.addEventListener('click', () => {
            if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                messageText.textContent = "Game Over!";
                codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                currentPopupAction = 'game_over_options';
            } else {
                hidePopup(messageBox); currentPopupAction = null;
            }
        });

        function showTemporaryPopup(message) {
            tempPopup.textContent = message;
            showPopup(tempPopup);
            setTimeout(() => {
                hidePopup(tempPopup);
            }, 2500);
        };
        function toggleMouseAim() {
            if (isGameEffectivelyPaused()) return;
            mouseAimActive = !mouseAimActive; showTemporaryPopup(mouseAimActive ? "Mouse Aim Activated!" : "Mouse Aim Deactivated!");
            canvas.style.cursor = mouseAimActive ? 'crosshair' : 'default';
            if (mouseAimActive && aimbotActive) { showTemporaryPopup("Aimbot is active, mouse aim will be overridden by Aimbot targeting."); }
        };

        const POWERUP_TYPES = {
            MULTI_SHOT: 'multiShot',
            RAPID_FIRE: 'rapidFire',
            SHIELD: 'shield',
            SPEED_BOOST: 'speedBoost',
            HEALTH_PACK_GREEN: 'healthPackGreen',
            HEALTH_PACK_GOLDEN: 'healthPackGolden'
        };

        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.size = POWERUP_SIZE;
                this.createdAt = Date.now(); this.lifetime = POWERUP_LIFETIME;
                this.pulseSpeed = 0.05; this.currentPulse = 0;

                switch (this.type) {
                    case POWERUP_TYPES.MULTI_SHOT: this.baseColor = 'rgb(34, 197, 94)'; this.pulseColor = 'rgb(134, 239, 172)'; this.symbol = ''; break;
                    case POWERUP_TYPES.RAPID_FIRE: this.baseColor = 'rgb(251, 146, 60)'; this.pulseColor = 'rgb(253, 186, 116)'; this.symbol = ''; break;
                    case POWERUP_TYPES.SHIELD: this.baseColor = 'rgb(59, 130, 246)'; this.pulseColor = 'rgb(147, 197, 253)'; this.symbol = ''; break;
                    case POWERUP_TYPES.SPEED_BOOST: this.baseColor = 'rgb(168, 85, 247)'; this.pulseColor = 'rgb(216, 180, 254)'; this.symbol = ''; break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN: this.baseColor = 'hsl(120, 60%, 50%)'; this.pulseColor = 'hsl(120, 60%, 70%)'; this.symbol = ''; break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN: this.baseColor = 'hsl(50, 100%, 50%)'; this.pulseColor = 'hsl(50, 100%, 70%)'; this.symbol = ''; break;
                    default: this.baseColor = 'grey'; this.pulseColor = 'lightgrey'; this.symbol = '?';
                }
            }
            draw() {
                this.currentPulse = (this.currentPulse + this.pulseSpeed) % (Math.PI * 2);
                const scaleFactor = 1 + Math.sin(this.currentPulse) * 0.1;
                const currentSize = this.size * scaleFactor;
                ctx.fillStyle = this.pulseColor;
                ctx.globalAlpha = 0.5 * (1 + Math.sin(this.currentPulse) * 0.5);
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 1.8, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = this.baseColor;
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 2.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${currentSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x + this.size / 2, this.y + this.size / 2);
            }
            update(deltaTime) { return Date.now() - this.createdAt > this.lifetime; }
        }

        class Target {
            constructor(x, y, type) {
                this.type = type; this.size = Math.random() * (TARGET_SIZE_MAX - TARGET_SIZE_MIN) + TARGET_SIZE_MIN;
                this.x = x; this.y = y; this.width = this.size; this.height = this.size;
                let speedMultiplier = 1.0 + (Math.random() - 0.5) * 0.3;
                let healthMultiplier = 1.0;
                let projectileSpeedMultiplier = 1.0;
                let shootCooldownFactor = 1.0;

                if (gameMode === 'hell') {
                    speedMultiplier *= 3.4; healthMultiplier = 2.2; projectileSpeedMultiplier = 1.15; shootCooldownFactor = 0.65;
                } else if (gameMode === 'endless') {
                    speedMultiplier *= 1.25; healthMultiplier = 1.2;
                } else {
                    speedMultiplier *= 0.8; healthMultiplier = 0.7;
                }

                this.speed = (TARGET_BASE_SPEED + (currentWave-1) * TARGET_SPEED_INCREMENT + (currentStage-1) * TARGET_SPEED_INCREMENT * 2) * speedMultiplier;
                this.projectileColor = "rgb(220, 100, 100)";
                this.projectileDamage = (gameMode === 'hell') ? 15 : 10;
                this.repulsionForce = 0.65; this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;

                switch(type) {
                    case 'purple':
                        this.color = "hsl(280, 70%, 60%)"; this.faceColor = "hsl(280, 70%, 40%)";
                        this.health = (40 + currentWave * 5 + currentStage * 10) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 450 : (gameMode === 'endless' ? 1500 : 1800)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 2.8 * projectileSpeedMultiplier;
                        break;
                    case 'orange':
                        this.color = "hsl(30, 80%, 60%)"; this.faceColor = "hsl(30, 80%, 40%)";
                        this.health = (30 + currentWave * 4 + currentStage * 8) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 300 : (gameMode === 'endless' ? 750 : 900)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 3.2 * projectileSpeedMultiplier;
                        break;
                    case 'green':
                        this.color = "hsl(140, 70%, 50%)"; this.faceColor = "hsl(140, 70%, 30%)";
                        this.health = (50 + currentWave * 7 + currentStage * 12) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 1.7 : 1.5);
                        this.canShoot = false;
                        break;
                    case 'blue':
                        this.color = "hsl(210, 70%, 60%)"; this.faceColor = "hsl(210, 70%, 40%)";
                        this.health = (20 + currentWave * 3 + currentStage * 5) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 0.6 : 0.55);
                        this.canShoot = false;
                        break;
                    default:
                        this.color = "hsl(0, 0%, 50%)"; this.faceColor = "hsl(0, 0%, 30%)";
                        this.health = (25 + currentWave * 4 + currentStage * 4) * healthMultiplier;
                        this.canShoot = false;
                }
                this.initialHealth = this.health; this.lastShotTime = 0;
                this.hitFlashDuration = 100; this.lastHitTime = 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                let drawColor = this.color; if (Date.now() - this.lastHitTime < this.hitFlashDuration) { drawColor = "white"; }
                ctx.fillStyle = drawColor; ctx.beginPath();
                if (this.type === 'purple') { const s = this.width / 2; ctx.moveTo(-s, -s); ctx.lineTo(s, -s); ctx.lineTo(s*0.8, -s*0.2); ctx.lineTo(s, s); ctx.lineTo(-s, s); ctx.lineTo(-s*0.8, s*0.2); ctx.closePath();
                } else if (this.type === 'orange') { for (let i = 0; i < 5; i++) { ctx.lineTo( (this.width / 2) * Math.cos( (Math.PI*2/5) * i - Math.PI/2 ), (this.height / 2) * Math.sin( (Math.PI*2/5) * i - Math.PI/2 )); } ctx.closePath();
                } else if (this.type === 'green') { ctx.moveTo(0, -this.height / 2); ctx.lineTo(this.width / 2, this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.closePath();
                } else { const r = this.width / 5; ctx.moveTo(-this.width/2 + r, -this.height/2); ctx.arcTo(this.width/2, -this.height/2, this.width/2, this.height/2, r); ctx.arcTo(this.width/2, this.height/2, -this.width/2, this.height/2, r); ctx.arcTo(-this.width/2, this.height/2, -this.width/2, -this.height/2, r); ctx.arcTo(-this.width/2, -this.height/2, this.width/2, -this.height/2, r); ctx.closePath(); }
                ctx.fill();
                ctx.fillStyle = this.faceColor; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)"; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 12, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                if (this.health > 0) {
                    const hBW = this.width * 0.8;
                    const hBH = 4;
                    const healthPercentage = (this.health / this.initialHealth) * 100;
                    const hP = Math.max(0, Math.min(1, this.health / this.initialHealth));

                    const barX = this.x + this.width * 0.1;
                    const barY = this.y - hBH - 3;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, hBW, hBH);

                    let healthBarColor = 'hsl(0, 70%, 50%)';
                    if (healthPercentage > 60) {
                        healthBarColor = 'hsl(120, 70%, 50%)';
                    } else if (healthPercentage > 25) {
                        healthBarColor = 'hsl(60, 70%, 50%)';
                    }
                    ctx.fillStyle = healthBarColor;
                    ctx.fillRect(barX, barY, hBW * hP, hBH);

                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(barX, barY, hBW, hBH);
                }
            }
            update(playerX, playerY, deltaTime, otherTargets) {
                const dtFactor = deltaTime / (1000/60); this.rotation += this.rotationSpeed * dtFactor;
                const dxToPlayer = playerX + PLAYER_WIDTH/2-(this.x+this.width/2); const dyToPlayer = playerY + PLAYER_HEIGHT/2-(this.y+this.height/2);
                const distToPlayer = Math.sqrt(dxToPlayer*dxToPlayer + dyToPlayer*dyToPlayer);
                let moveX = 0; let moveY = 0; if (distToPlayer > 0) { moveX += (dxToPlayer/distToPlayer)*this.speed; moveY += (dyToPlayer/distToPlayer)*this.speed; }
                let repelX = 0; let repelY = 0;
                otherTargets.forEach(other => {
                    if (other === this) return; const dx = this.x - other.x; const dy = this.y - other.y;
                    const distSq = dx*dx + dy*dy; const minDist = (this.size + other.size) * 0.6;
                    if (distSq < minDist*minDist && distSq > 0) { const dist = Math.sqrt(distSq); const force = this.repulsionForce * (1 - dist/minDist); repelX += (dx/dist)*force; repelY += (dy/dist)*force; }
                });
                this.x += (moveX + repelX) * dtFactor; this.y += (moveY + repelY) * dtFactor;
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width)); this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                if (this.canShoot && Date.now() - this.lastShotTime > this.shootCooldown) {
                    this.lastShotTime = Date.now(); const aimDx = playerX+PLAYER_WIDTH/2-(this.x+this.width/2); const aimDy = playerY+PLAYER_HEIGHT/2-(this.y+this.height/2);
                    const aimDist = Math.sqrt(aimDx*aimDx + aimDy*aimDy); let sX=0,sY=0;
                    if(aimDist>0){sX=(aimDx/aimDist)*this.enemyProjectileSpeed;sY=(aimDy/aimDist)*this.enemyProjectileSpeed;}
                    enemyProjectiles.push(new EnemyProjectile(this.x+this.width/2, this.y+this.height/2, sX, sY, this.projectileColor, this.projectileDamage));
                }
            }
            takeDamage(amount) { this.health -= amount; this.lastHitTime = Date.now(); createParticle(this.x+this.width/2, this.y+this.height/2, 3, 'rgba(255,255,255,0.8)', [2,5], [1,3], [100,300]); if (this.health < 0) {this.health = 0;} }
        }

        class EnemyProjectile {
            constructor(x,y,sX,sY,c, damage = 10){
                this.x=x-ENEMY_PROJECTILE_WIDTH/2;this.y=y-ENEMY_PROJECTILE_HEIGHT/2; this.width=ENEMY_PROJECTILE_WIDTH;this.height=ENEMY_PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c; this.damage = damage;
                this.trail = []; this.maxTrailLength = (gameMode === 'hell') ? 8 : 5; this.rotation = Math.random() * Math.PI * 2;
                this.baseSpeed = Math.sqrt(sX*sX + sY*sY) || 0;
                this.curveStrength = 0.035;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.3 * (i / this.trail.length); ctx.fillStyle = `hsla(0, 100%, 70%, ${alpha})`; ctx.beginPath(); ctx.arc(point.x + this.width / 2, point.y + this.height / 2, this.width / 2.5 * (i / this.trail.length), 0, Math.PI * 2); ctx.fill(); }
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                ctx.fillStyle = "rgba(255, 50, 50, 0.5)"; ctx.beginPath(); ctx.arc(0, 0, this.width / 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,this.width/2.2,0,Math.PI*2); ctx.fill();
                ctx.restore();
            }
            update(deltaTime){
                const dtFactor=deltaTime/(1000/60);
                if (player1 && player1.health > 0 && this.baseSpeed > 0) {
                    const projectileCenterX = this.x + this.width / 2;
                    const projectileCenterY = this.y + this.height / 2;
                    const playerCenterX = player1.x + player1.width / 2;
                    const playerCenterY = player1.y + player1.height / 2;
                    const dx = playerCenterX - projectileCenterX;
                    const dy = playerCenterY - projectileCenterY;
                    const distance = Math.sqrt(dx*dx + dy*dy) || 1;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(this.speedY, this.speedX);
                    let angleDiff = normalizeAngle(targetAngle - currentAngle);
                    const maxTurn = (this.curveStrength / (1 + distance / 400)) * dtFactor;
                    angleDiff = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                    const newAngle = currentAngle + angleDiff;
                    this.speedX = Math.cos(newAngle) * this.baseSpeed;
                    this.speedY = Math.sin(newAngle) * this.baseSpeed;
                }
                const prevX = this.x;
                const prevY = this.y;
                this.x+=this.speedX*dtFactor; this.y+=this.speedY*dtFactor;
                this.rotation += 0.1 * dtFactor;

                resolveProjectileObstacleCollision(this, prevX, prevY);

                if (this.x > CANVAS_WIDTH + this.width * 2 || this.x < -this.width * 2 || this.y > CANVAS_HEIGHT + this.height * 2 || this.y < -this.height * 2) {
                    const index = enemyProjectiles.indexOf(this);
                    if (index > -1) {
                        enemyProjectiles.splice(index, 1);
                    }
                }

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }
            }
        }

        class FoxPlayer {
            constructor(x, y, foxTypeName, controls) {
                this.type = FOX_TYPES[foxTypeName]; this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT;
                this.color = this.type.color;
                this.speed = this.type.baseSpeed;
                this.shootDelayBase = this.type.baseShootDelay;
                this.health = (gameMode === 'hell') ? 200 : this.type.health; this.initialHealth = this.health;
                this.controls = controls; this.projectiles = []; this.lastShotTime = 0;
                this.beamCharge = 0; this.beamChargeMax = BEAM_CHARGE_MAX; this.beamReady = false;
                this.isFiringBeam = false; this.beamActiveDuration = BEAM_ACTIVE_DURATION; this.beamActiveStartTime = 0;
                this.beamDamagePerFrame = 2.5; this.smashCharge = 0; this.smashChargeMax = SMASH_CHARGE_MAX; this.smashReady = false;
                this.isSmashing = false; this.smashRadius = 0; this.smashMaxRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
                this.smashExpansionSpeed = this.smashMaxRadius / 50; this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0;
                this.beamTargetAngle = 0;
                this.aimbotTarget = null; this.bulletCount = 1; this.engineParticles = [];
                this.engineParticleTimer = 0; this.engineParticleInterval = 50; this.currentSpeed = 0;
                this.shieldOpacity = 0; this.lastDamageTime = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.isDivineProtectionActive = false;
                this.rapidFireActiveUntil = 0;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0;
                this.dashCooldown = 1200;
                this.dashDuration = 160;
                this.dashSpeedMultiplier = 5;
                this.dashActive = false;
                this.dashEndTime = 0;
                this.nextDashTime = 0;
                this.dashVelocityX = 0;
                this.dashVelocityY = 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.aimAngle);

                this.engineParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.beginPath();
                    const localX = p.x - (this.x + this.width / 2);
                    const localY = p.y - (this.y + this.height / 2);
                    ctx.arc(localX, localY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                ctx.font = `${this.height * 0.95}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('', 0, 0);


                const shieldPath = () => {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.7, 0, Math.PI * 2);
                    ctx.closePath();
                };

                let currentShieldColor = this.type.shieldColor;
                let shieldActive = false;

                if (this.isInvulnerable) {
                    currentShieldColor = this.type.invulnerableShieldColor;
                    shieldActive = true;
                } else if (Date.now() < this.shieldActiveUntil) {
                    currentShieldColor = "hsla(180, 100%, 70%, 0.7)";
                    shieldActive = true;
                } else if (this.isDivineProtectionActive) {
                     currentShieldColor = "hsla(270, 100%, 70%, 0.7)";
                     shieldActive = true;
                } else if (this.shieldOpacity > 0) {
                    shieldActive = true;
                }

                if (shieldActive) {
                    ctx.strokeStyle = currentShieldColor;
                    ctx.lineWidth = (this.isInvulnerable || Date.now() < this.shieldActiveUntil || this.isDivineProtectionActive) ? 4 : 3;
                    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 80) * 0.4;
                    shieldPath();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();

                if (aimbotActive && this.aimbotTarget) { ctx.strokeStyle = "rgba(255,0,0,0.6)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x+this.width/2,this.y+this.height/2); ctx.lineTo(this.aimbotTarget.x+this.aimbotTarget.width/2,this.aimbotTarget.y+this.aimbotTarget.height/2); ctx.stroke(); }
                if (this.isFiringBeam) {
                    ctx.save(); ctx.translate(this.x+this.width/2,this.y+this.height/2);
                    ctx.rotate(this.beamTargetAngle);
                    const beamLength = CANVAS_WIDTH*1.5;
                    let gradBeam = ctx.createLinearGradient(0,0,beamLength,0); gradBeam.addColorStop(0,"rgba(255,255,220,1)"); gradBeam.addColorStop(0.1,"rgba(255,255,180,0.9)"); gradBeam.addColorStop(1,"rgba(255,200,100,0)");
                    ctx.fillStyle = gradBeam; ctx.fillRect(this.width/2, -BEAM_THICKNESS/4, beamLength, BEAM_THICKNESS/2);
                    let gradGlow = ctx.createLinearGradient(0,0,beamLength,0); gradGlow.addColorStop(0,"rgba(255,220,150,0.6)"); gradGlow.addColorStop(0.2,"rgba(255,200,100,0.4)"); gradGlow.addColorStop(1,"rgba(255,180,50,0)");
                    ctx.fillStyle = gradGlow; ctx.fillRect(this.width/2, -BEAM_THICKNESS/2, beamLength, BEAM_THICKNESS);
                    ctx.restore();
                }
                if (this.isSmashing) {
                    ctx.beginPath(); const smashProgress = this.smashRadius/this.smashMaxRadius;
                    ctx.strokeStyle = `rgba(255,100,50,${0.8-smashProgress*0.7})`; ctx.lineWidth = 10+15*(1-smashProgress); ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius,0,Math.PI*2); ctx.stroke();
                    ctx.fillStyle = `rgba(255,150,80,${0.5-smashProgress*0.4})`; ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius*0.8,0,Math.PI*2); ctx.fill();
                }
            }

            updateChargeIndicators() {
                const beamBar = document.getElementById('beamChargeBar'); if (beamBar) { const bCP = this.beamCharge/this.beamChargeMax; beamBar.style.width = `${Math.min(100,bCP*100)}%`; beamBar.classList.toggle('ready',this.beamReady); }
                const smashBar = document.getElementById('smashChargeBar'); if (smashBar) { const sCP = this.smashCharge/this.smashChargeMax; smashBar.style.width = `${Math.min(100,sCP*100)}%`; smashBar.classList.toggle('ready',this.smashReady); }
            }

            updateAimDirection() {
                this.aimbotTarget = null;
                if (aimbotActive) {
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => { const dx = target.x+target.width/2-(this.x+this.width/2); const dy = target.y+target.height/2-(this.y+this.height/2); const distSq = dx*dx+dy*dy; if (distSq < minDistanceSq) { minDistanceSq = distSq; closestTarget = target; }});
                    if (closestTarget) { const dx = closestTarget.x+closestTarget.width/2-(this.x+this.width/2); const dy = closestTarget.y+closestTarget.height/2-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx); this.aimbotTarget = closestTarget; }
                } else if (mouseAimActive) {
                    const dx = mouseX-(this.x+this.width/2); const dy = mouseY-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx);
                } else {
                    let keyAimDx = 0; let keyAimDy = 0;
                    if (keysPressed['ArrowLeft']) { keyAimDx = -1; } else if (keysPressed['ArrowRight']) { keyAimDx = 1;}
                    if (keysPressed['ArrowUp']) { keyAimDy = -1; } else if (keysPressed['ArrowDown']) { keyAimDy = 1;}
                    if (keyAimDx !== 0 || keyAimDy !== 0) { this.aimAngle = Math.atan2(keyAimDy, keyAimDx); }
                    else { if (this.lastMoveDx !== 0 || this.lastMoveDy !== 0) { this.aimAngle = Math.atan2(this.lastMoveDy, this.lastMoveDx); } }
                }
            }

            move(deltaTime) {
                let moveDx = 0; let moveDy = 0;
                if (keysPressed[this.controls.left]) { moveDx -= 1; }
                if (keysPressed[this.controls.right]) { moveDx += 1; }
                if (keysPressed[this.controls.up]) { moveDy -= 1; }
                if (keysPressed[this.controls.down]) { moveDy += 1; }

                const targetSpeed = (moveDx !== 0 || moveDy !== 0) ? this.speed : 0;
                const acceleration = 0.15;
                this.currentSpeed += (targetSpeed - this.currentSpeed) * acceleration;

                const dtFactor = deltaTime / (1000/60);
                const prevX = this.x;
                const prevY = this.y;

                if (moveDx !== 0 || moveDy !== 0) {
                    const dist = Math.hypot(moveDx, moveDy) || 1;
                    const nDx = moveDx / dist;
                    const nDy = moveDy / dist;
                    this.x += nDx * this.currentSpeed * dtFactor;
                    this.y += nDy * this.currentSpeed * dtFactor;
                    this.lastMoveDx = nDx;
                    this.lastMoveDy = nDy;
                }

                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                resolveEntityObstacleCollision(this, prevX, prevY);
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));

                if (this.dashActive) {
                    const dashPrevX = this.x;
                    const dashPrevY = this.y;
                    this.x += this.dashVelocityX * dtFactor;
                    this.y += this.dashVelocityY * dtFactor;
                    this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                    this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                    resolveEntityObstacleCollision(this, dashPrevX, dashPrevY);
                    this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                    this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                    if (Date.now() >= this.dashEndTime) {
                        this.dashActive = false;
                        this.dashVelocityX = 0;
                        this.dashVelocityY = 0;
                    }
                }

                this.engineParticleTimer += deltaTime;
                if (this.engineParticleTimer > this.engineParticleInterval && this.currentSpeed > this.speed * 0.25) {
                    this.engineParticleTimer = 0;
                    const particleCount = Math.max(1, Math.floor(this.currentSpeed / this.speed));
                    for (let i = 0; i < particleCount; i++) {
                        const angleOffset = (Math.random() - 0.5) * 0.4;
                        const particleStartX = (this.x + this.width/2) - Math.cos(this.aimAngle) * (this.width * 0.4);
                        const particleStartY = (this.y + this.height/2) - Math.sin(this.aimAngle) * (this.height * 0.4);
                        const particleAngle = this.aimAngle + Math.PI + angleOffset;
                        const speed = (Math.random() * 0.8 + 0.6) * (this.currentSpeed / Math.max(this.speed, 0.01));
                        this.engineParticles.push({
                            x: particleStartX,
                            y: particleStartY,
                            vx: Math.cos(particleAngle) * speed,
                            vy: Math.sin(particleAngle) * speed,
                            size: Math.random() * 2 + 1,
                            life: Math.random() * 180 + 120,
                            maxLife: 220,
                            color: `hsla(${20 + Math.random()*30},100%,${60 + Math.random()*20}%,${0.4 + Math.random()*0.4})`,
                            opacity: 1
                        });
                    }
                }
                for (let i = this.engineParticles.length - 1; i >= 0; i--) {
                    const p = this.engineParticles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= deltaTime;
                    p.opacity = p.life / p.maxLife;
                    if (p.life <= 0) { this.engineParticles.splice(i, 1); }
                }
            }

            tryDash() {
                const now = Date.now();
                if (this.health <= 0 || this.dashActive || now < this.nextDashTime) { return false; }
                let dirX = this.lastMoveDx;
                let dirY = this.lastMoveDy;
                if (dirX === 0 && dirY === 0) {
                    dirX = Math.cos(this.aimAngle);
                    dirY = Math.sin(this.aimAngle);
                }
                const length = Math.hypot(dirX, dirY);
                if (!length) { return false; }
                dirX /= length;
                dirY /= length;
                const dashSpeed = this.speed * this.dashSpeedMultiplier;
                this.dashVelocityX = dirX * dashSpeed;
                this.dashVelocityY = dirY * dashSpeed;
                this.dashActive = true;
                this.dashEndTime = now + this.dashDuration;
                this.nextDashTime = now + this.dashCooldown;
                createParticle(this.x + this.width/2, this.y + this.height/2, 12, 'rgba(148, 163, 255, 0.45)', [4,8], [2,5], [180,360]);
                return true;
            }

            shoot(triggeredByClick = false) {
                const currentTime = Date.now();
                const currentShootDelay = (Date.now() < this.rapidFireActiveUntil) ? this.shootDelayBase / 2 : this.shootDelayBase;
                const actualShootDelay = aimbotActive ? AIMBOT_SHOOT_DELAY : currentShootDelay;

                let attemptShot = false;
                if (mouseFireHeld) {
                    attemptShot = true;
                } else if (aimbotActive) {
                    attemptShot = true;
                } else if (mouseAimActive && triggeredByClick) {
                    attemptShot = true;
                } else if (keysPressed[this.controls.shoot]) {
                    attemptShot = true;
                }

                if (attemptShot && (currentTime - this.lastShotTime > actualShootDelay)) {
                    this.lastShotTime = currentTime;
                    const numBullets = this.bulletCount;
                    const spreadAngle = numBullets > 1 ? Math.PI / 24 : 0;

                    const muzzleOffsetX = Math.cos(this.aimAngle) * (this.width * 0.5);
                    const muzzleOffsetY = Math.sin(this.aimAngle) * (this.height * 0.5);
                    createParticle( this.x+this.width/2 + muzzleOffsetX, this.y+this.height/2 + muzzleOffsetY, 5, `rgba(255,223,186,${0.5+Math.random()*0.5})`,[3,7],[2,4],[50,150],Math.PI/4 );
                    createParticle( this.x+this.width/2 + muzzleOffsetX, this.y+this.height/2 + muzzleOffsetY, 3, 'rgba(255,255,255,0.7)',[2,4],[1,2],[40,90],Math.PI/6 );

                    for (let i = 0; i < numBullets; i++) {
                        const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle;
                        const currentAngle = this.aimAngle + angleOffset;
                        const cosA = Math.cos(currentAngle); const sinA = Math.sin(currentAngle);
                        const startX = this.x + this.width/2 + cosA * (this.width * 0.5);
                        const startY = this.y + this.height/2 + sinA * (this.height * 0.5);
                        this.projectiles.push(new Projectile( startX, startY, cosA*this.type.projectileSpeed, sinA*this.type.projectileSpeed, this.type.projectileColor ));
                    }
                }
            }
            fireBeam() {
                if (this.beamReady && !this.isFiringBeam) {
                    this.isFiringBeam = true; this.beamActiveStartTime = Date.now(); this.beamReady = false; this.beamCharge = 0;
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => {
                        const dx = target.x + target.width/2 - (this.x + this.width/2);
                        const dy = target.y + target.height/2 - (this.y + this.height/2);
                        const distSq = dx*dx + dy*dy;
                        if (distSq < minDistanceSq) {
                            minDistanceSq = distSq;
                            closestTarget = target;
                        }
                    });
                    if (closestTarget) {
                        const dx = closestTarget.x + closestTarget.width/2 - (this.x + this.width/2);
                        const dy = closestTarget.y + closestTarget.height/2 - (this.y + this.height/2);
                        this.beamTargetAngle = Math.atan2(dy, dx);
                    } else {
                        this.beamTargetAngle = this.aimAngle;
                    }
                    createParticle(this.x+this.width/2,this.y+this.height/2,20,'rgba(255,255,100,0.7)',[4,10],[3,6],[300,600],Math.PI*2);
                }
            }
            fireSmash() {
                if (this.smashReady && !this.isSmashing) {
                    this.smashReady = false; this.smashCharge = 0; this.isSmashing = true; this.smashRadius = 0;
                    createParticle(this.x+this.width/2,this.y+this.height/2,30,'rgba(255,100,50,0.7)',[5,15],[4,8],[400,800],Math.PI*2);
                }
            }

            update(deltaTime) {
                if (this.health <= 0) { return; }

                if (this.isInvulnerable && Date.now() >= this.invulnerableUntil) { this.isInvulnerable = false; }
                if (Date.now() >= this.rapidFireActiveUntil && this.shootDelayBase !== this.type.baseShootDelay) {
                    this.shootDelayBase = this.type.baseShootDelay;
                    showTemporaryPopup("Rapid Fire Worn Off!");
                }
                if (Date.now() >= this.shieldActiveUntil && this.shieldOpacity > 0 && !this.isInvulnerable) {
                }
                if (Date.now() >= this.speedBoostActiveUntil && this.speed !== this.type.baseSpeed) {
                    this.speed = this.type.baseSpeed;
                    showTemporaryPopup("Speed Boost Worn Off!");
                }


                if (this.isDivineProtectionActive && this.health < 20 && this.health > 0) {
                    this.health = 1000;
                    updateUI();
                }

                this.updateAimDirection(); this.move(deltaTime); this.shoot();
                if (!this.beamReady && !this.isFiringBeam) { this.beamCharge += deltaTime; if (this.beamCharge >= this.beamChargeMax) { this.beamCharge = this.beamChargeMax; this.beamReady = true;} }
                if (!this.smashReady && !this.isSmashing) { this.smashCharge += deltaTime; if (this.smashCharge >= this.smashChargeMax) { this.smashCharge = this.smashChargeMax; this.smashReady = true;}}
                if (keysPressed[this.controls.beam]) { this.fireBeam(); }
                if (this.isFiringBeam && (Date.now() - this.beamActiveStartTime >= this.beamActiveDuration)) { this.isFiringBeam = false; }
                if (this.isSmashing) {
                    this.smashRadius += this.smashExpansionSpeed * (deltaTime/(1000/60));
                    for (let i = gameTargets.length-1; i >= 0; i--) { const target = gameTargets[i]; const distSq = Math.pow(target.x+target.width/2-(this.x+this.width/2),2)+Math.pow(target.y+target.height/2-(this.y+this.height/2),2); if (distSq <= Math.pow(this.smashRadius,2)) { target.takeDamage(1000); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(i,1); playerScore += SCORE_PER_SMASH_HIT; }}}
                    if (this.smashRadius >= this.smashMaxRadius) { this.isSmashing = false; this.smashRadius = 0; showTemporaryPopup("SMASHED!"); }
                }
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    projectile.update(deltaTime);
                    if (projectile.shouldRemove) {
                        this.projectiles.splice(i, 1);
                    }
                }

                if (!this.isInvulnerable && !(Date.now() < this.shieldActiveUntil) && !this.isDivineProtectionActive && this.shieldOpacity > 0) {
                    this.shieldOpacity -= 0.02 * (deltaTime / 16.67); if (this.shieldOpacity < 0) this.shieldOpacity = 0;
                }
            }
            reset(fullReset = true) {
                this.health = (this.isDivineProtectionActive && !fullReset) ? 1000 : (gameMode === 'hell' ? 200 : FOX_TYPES["Ranger"].health);
                this.initialHealth = this.health;
                this.projectiles = []; this.x = 50; this.y = CANVAS_HEIGHT/2 - this.height/2;
                resolveEntityObstacleCollision(this, this.x, this.y);
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                this.beamCharge = 0; this.beamReady = false; this.isFiringBeam = false; this.smashCharge = 0; this.smashReady = false; this.isSmashing = false; this.smashRadius = 0;
                this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0; this.beamTargetAngle = 0; this.aimbotTarget = null;
                this.bulletCount = 1; this.engineParticles = []; this.currentSpeed = 0; this.shieldOpacity = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.rapidFireActiveUntil = 0; this.shootDelayBase = this.type.baseShootDelay;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0; this.speed = this.type.baseSpeed;
                this.dashActive = false;
                this.dashVelocityX = 0; this.dashVelocityY = 0;
                this.nextDashTime = 0; this.dashEndTime = 0;
                if (fullReset) {
                    this.isDivineProtectionActive = false;
                    playerScore = 0;
                }
            }
            takeDamage(amount) {
                if (this.isInvulnerable || Date.now() < this.shieldActiveUntil) return;

                if (this.isDivineProtectionActive) {
                    if (this.health > 20) {
                        this.health -= amount;
                        if (this.health < 20) this.health = 20;
                    }
                    this.lastDamageTime = Date.now();
                    this.shieldOpacity = 1;
                    createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                    if (this.health < 0) this.health = 0;
                    return;
                }

                if (Date.now() - this.lastDamageTime < 200) return;
                this.health -= amount; this.lastDamageTime = Date.now(); this.shieldOpacity = 1;
                createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                if (this.health < 0) {this.health = 0;}
            }
            collectPowerUp(powerUpType) {
                createParticle(this.x + this.width/2, this.y + this.height/2, 15, 'rgba(200,200,255,0.7)', [4,9], [2,5], [200,500]);
                switch (powerUpType) {
                    case POWERUP_TYPES.MULTI_SHOT:
                        if (this.bulletCount < MAX_BULLET_COUNT) {
                            this.bulletCount++;
                            showTemporaryPopup(`Multi-Shot Level ${this.bulletCount}!`);
                        } else {
                            showTemporaryPopup(`Multi-Shot Maxed!`);
                        }
                        break;
                    case POWERUP_TYPES.RAPID_FIRE:
                        this.shootDelayBase = this.type.baseShootDelay / 2;
                        this.rapidFireActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Laser Fingers Activated!");
                        break;
                    case POWERUP_TYPES.SHIELD:
                        this.shieldActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Force Field Activated!");
                        break;
                    case POWERUP_TYPES.SPEED_BOOST:
                        this.speed = this.type.baseSpeed * 1.5;
                        this.speedBoostActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Zoomies Activated!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN:
                        this.health += 50;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("+50 Health!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN:
                        this.health += 150;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("Golden Health +150!");
                        break;
                }
                updateUI();
            }
        }

        class Projectile{
            constructor(x,y,sX,sY,c){
                this.x=x-PROJECTILE_WIDTH/2;this.y=y-PROJECTILE_HEIGHT/2; this.width=PROJECTILE_WIDTH;this.height=PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c;
                this.trail = []; this.maxTrailLength = 5;
                this.createdAt = Date.now();
                this.maxLifetime = 5000;
                this.shouldRemove = false;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.5 * (i / this.trail.length); ctx.fillStyle = `hsla(50, 100%, 70%, ${alpha})`; ctx.beginPath(); const trailWidth = this.width*0.6*((this.trail.length-i)/this.trail.length); const trailHeight = this.height*0.6*((this.trail.length-i)/this.trail.length); ctx.ellipse(point.x+this.width/2,point.y+this.height/2,trailWidth/2,trailHeight/2,0,0,Math.PI*2); ctx.fill(); }
                ctx.fillStyle=this.color; ctx.beginPath(); const r = Math.min(this.width,this.height)/3; ctx.moveTo(this.x+r,this.y); ctx.arcTo(this.x+this.width,this.y,this.x+this.width,this.y+this.height,r); ctx.arcTo(this.x+this.width,this.y+this.height,this.x,this.y+this.height,r); ctx.arcTo(this.x,this.y+this.height,this.x,this.y,r); ctx.arcTo(this.x,this.y,this.x+this.width,this.y,r); ctx.closePath(); ctx.fill();
                ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.ellipse(this.x+this.width/2,this.y+this.height/2,this.width/3,this.height/3,0,0,Math.PI*2); ctx.fill();
            }
            update(dT){
                const dF=dT/(1000/60);
                const prevX = this.x;
                const prevY = this.y;
                this.x+=this.speedX*dF; this.y+=this.speedY*dF;

                if (this.x <= 0) { this.x = 0; this.speedX = Math.abs(this.speedX); }
                else if (this.x + this.width >= CANVAS_WIDTH) { this.x = CANVAS_WIDTH - this.width; this.speedX = -Math.abs(this.speedX); }
                if (this.y <= 0) { this.y = 0; this.speedY = Math.abs(this.speedY); }
                else if (this.y + this.height >= CANVAS_HEIGHT) { this.y = CANVAS_HEIGHT - this.height; this.speedY = -Math.abs(this.speedY); }

                resolveProjectileObstacleCollision(this, prevX, prevY);

                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }

                if (Date.now() - this.createdAt > this.maxLifetime) { this.shouldRemove = true; }
            }
        }

        let player1;
        let lastFrameTime = 0;

        function spawnTargets(count, isInitialSpawn = true) {
            const enemyTypes = ['purple','orange','green','blue']; let availableTypes = [...enemyTypes];
            if (gameMode === 'normal') {
                if(currentStage===1&&currentWave===1){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['blue','green'];}
                else if(currentStage===2&&currentWave===1){availableTypes=['green'];}
                else if(currentStage===2&&currentWave===2){availableTypes=['green','purple'];}
                else if(currentStage >= 3) {availableTypes = ['green','purple','orange'];}
            } else {
                if(currentStage===1&&currentWave===1){availableTypes=['blue','green'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue','green','purple'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['green','purple','orange'];}
                else {availableTypes = ['purple','orange','green'];}
            }

            let spawnMultiplier=1.0;
            if(gameMode==='hell')spawnMultiplier=isInitialSpawn? (targetsPerWaveBase * 1.1) :HELL_MODE_EXTRA_SPAWN_COUNT;
            else if(gameMode==='endless')spawnMultiplier=1.3;

            let numToSpawn=isInitialSpawn?count:spawnMultiplier;
            for(let i=0;i<numToSpawn;i++){ const side=Math.floor(Math.random()*4); let x,y; const margin=50; if(side===0){x=Math.random()*CANVAS_WIDTH;y=-margin-Math.random()*50;}else if(side===1){x=CANVAS_WIDTH+margin+Math.random()*50;y=Math.random()*CANVAS_HEIGHT;}else if(side===2){x=Math.random()*CANVAS_WIDTH;y=CANVAS_HEIGHT+margin+Math.random()*50;}else{x=-margin-Math.random()*50;y=Math.random()*CANVAS_HEIGHT;} const type=availableTypes[Math.floor(Math.random()*availableTypes.length)]; gameTargets.push(new Target(x,y,type)); }
        };
        function initializeStage(stage, wave) {
            currentStage = stage; currentWave = wave; gameTargets = []; enemyProjectiles = []; powerUps = [];
            if (gameMode === 'endless' || gameMode === 'hell') { stageDisplay.textContent = `${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)} Mode: Wave ${wave}`; }
            else { stageDisplay.textContent = `Stage ${stage}: Wave ${wave}`; }

            if (wave === 1) {
                generateTerrainObstacles(stage);
                if (player1) {
                    resolveEntityObstacleCollision(player1, player1.x, player1.y);
                    player1.x = Math.max(0, Math.min(player1.x, CANVAS_WIDTH - player1.width));
                    player1.y = Math.max(0, Math.min(player1.y, CANVAS_HEIGHT - player1.height));
                }
            }

            let baseTargetsForMode = (gameMode === 'hell') ? 3 : (gameMode === 'normal' ? 2 : 3);
            let stageIncrementFactor = (gameMode === 'hell') ? 2.2 : (gameMode === 'normal' ? 1.2 : 2);
            let waveIncrementFactor = (gameMode === 'hell') ? 1.2 : (gameMode === 'normal' ? 0.7 : 1);

            targetsPerWaveBase = baseTargetsForMode;

            let numToSpawn = targetsPerWaveBase + (wave - 1) * waveIncrementFactor + (stage - 1) * stageIncrementFactor;
            spawnTargets(Math.max(1, Math.floor(numToSpawn)), true);
            if (gameMode === 'hell') { setNextHellSpawnTime(); } updateUI();
        };

        function setNextPowerupSpawnTime() {
            nextPowerUpSpawnTime = Date.now() + Math.random() * (POWERUP_SPAWN_INTERVAL_MAX - POWERUP_SPAWN_INTERVAL_MIN) + POWERUP_SPAWN_INTERVAL_MIN;
        }
        function setNextGreenHealthPackSpawnTime() {
            nextGreenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GREEN_SPAWN_MAX - HEALTH_PACK_GREEN_SPAWN_MIN) + HEALTH_PACK_GREEN_SPAWN_MIN;
        }
        function setNextGoldenHealthPackSpawnTime() {
            nextGoldenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GOLDEN_SPAWN_MAX - HEALTH_PACK_GOLDEN_SPAWN_MIN) + HEALTH_PACK_GOLDEN_SPAWN_MIN;
        }

        function trySpawnPowerUp() {
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextPowerUpSpawnTime && powerUps.filter(p => p.type != POWERUP_TYPES.HEALTH_PACK_GREEN && p.type !== POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                let attempts = 0; let x = 0; let y = 0;
                do {
                    x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                    y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                } while (attempts++ < 12 && isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12));
                if (!isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12)) {
                    const availablePowerUps = [POWERUP_TYPES.MULTI_SHOT, POWERUP_TYPES.RAPID_FIRE, POWERUP_TYPES.SHIELD, POWERUP_TYPES.SPEED_BOOST];
                    const randomType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                    powerUps.push(new PowerUp(x,y,randomType));
                }
                setNextPowerupSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGreenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GREEN).length < 1) {
                let attempts = 0; let x = 0; let y = 0;
                do {
                    x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                    y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                } while (attempts++ < 12 && isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12));
                if (!isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12)) {
                    powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GREEN));
                }
                setNextGreenHealthPackSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGoldenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                let attempts = 0; let x = 0; let y = 0;
                do {
                    x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                    y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                } while (attempts++ < 12 && isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12));
                if (!isRectOverlappingObstacles(x, y, POWERUP_SIZE, POWERUP_SIZE, 12)) {
                    powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GOLDEN));
                }
                setNextGoldenHealthPackSpawnTime();
            }
        }
        function setNextHellSpawnTime() { nextHellSpawnTime = Date.now() + HELL_MODE_SPAWN_INTERVAL * (0.7 + Math.random() * 0.2); }
        function trySpawnHellEnemies() {
            if (gameMode === 'hell' && gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextHellSpawnTime) {
                spawnTargets(0, false); setNextHellSpawnTime();
            }
        }

        function checkCollisions() {
            if (!player1 || player1.isSmashing) { return; }
            if (player1) {
                for (let pIndex = player1.projectiles.length - 1; pIndex >= 0; pIndex--) {
                    const projectile = player1.projectiles[pIndex];
                    for (let tIndex = gameTargets.length - 1; tIndex >= 0; tIndex--) {
                        const target = gameTargets[tIndex];
                        if (projectile.x < target.x + target.width &&
                            projectile.x + projectile.width > target.x &&
                            projectile.y < target.y + target.height &&
                            projectile.y + projectile.height > target.y) {
                            target.takeDamage(10);
                            player1.projectiles.splice(pIndex, 1);
                            playerScore += SCORE_PER_HIT;
                            if (target.health <= 0) {
                                createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]);
                                gameTargets.splice(tIndex,1);
                                if(!player1.isSmashing) { screenShake(5, 150); }
                            }
                            break;
                        }
                    }
                }
            }
            if (player1.isFiringBeam) { const beamAngle = player1.beamTargetAngle; const beamLength = CANVAS_WIDTH*1.5; for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; const tCX = target.x+target.width/2; const tCY = target.y+target.height/2; const pCX = player1.x+player1.width/2; const pCY = player1.y+player1.height/2; const dx = tCX-pCX; const dy = tCY-pCY; const distToP = Math.sqrt(dx*dx+dy*dy); if (distToP < beamLength) { const angleToT = Math.atan2(dy,dx); const angleDiff = Math.abs(normalizeAngle(beamAngle-angleToT)); if (angleDiff < Math.atan2(BEAM_THICKNESS/2,distToP) || distToP < target.size*0.8 ) { target.takeDamage(player1.beamDamagePerFrame*(lastFrameTime-(player1.beamFrameTime||lastFrameTime))/(1000/60)); playerScore+=SCORE_PER_BEAM_FRAME; if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]); gameTargets.splice(tIndex,1); screenShake(3,100); }}}} player1.beamFrameTime = lastFrameTime; } else { player1.beamFrameTime = null; }
            for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; if (player1.x < target.x+target.width && player1.x+player1.width > target.x && player1.y < target.y+target.height && player1.y+player1.height > target.y) { player1.takeDamage(TARGET_CONTACT_DAMAGE); target.takeDamage(50); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(tIndex,1); screenShake(5,150); } else { const dx = target.x-player1.x; const dy = target.y-player1.y; const dist = Math.sqrt(dx*dx+dy*dy)||1; target.x+=(dx/dist)*10; target.y+=(dy/dist)*10; }}}
            for (let epIndex = enemyProjectiles.length-1; epIndex >= 0; epIndex--) { const ep = enemyProjectiles[epIndex]; if (player1.health > 0 && ep.x < player1.x+player1.width && ep.x+ep.width > player1.x && ep.y < player1.y+player1.height && ep.y+ep.height > player1.y) { player1.takeDamage(ep.damage); enemyProjectiles.splice(epIndex,1); }}
            for (let puIndex = powerUps.length-1; puIndex >= 0; puIndex--) { const powerUp = powerUps[puIndex]; if (player1.x < powerUp.x+powerUp.size && player1.x+player1.width > powerUp.x && player1.y < powerUp.y+powerUp.size && player1.y+player1.height > powerUp.y) { player1.collectPowerUp(powerUp.type); powerUps.splice(puIndex,1); createParticle(powerUp.x + powerUp.size/2, powerUp.y + powerUp.size/2, 20, powerUp.pulseColor, [3,8], [2,5], [200,500]);}}
            if (!player1.isSmashing && gameTargets.length === 0 && gameRunning && player1.health > 0) { if (gameMode==='normal' && currentStage===COMPLETION_STAGE && currentWave===MAX_WAVES_PER_LEVEL) { showGameCompletionPopup(); } else { currentWave++; if (gameMode==='normal' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(10,targetsPerWaveBase+ (gameMode === 'hell' ? 2.2 : 1.2)); showTemporaryPopup(`Stage ${currentStage-1} Cleared! Onto Stage ${currentStage}!`); } else if (gameMode==='hell' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(20,targetsPerWaveBase+2.5); showTemporaryPopup(`Hell Stage ${currentStage-1} Cleared! Prepare for more!`); } else { showTemporaryPopup(`Wave ${currentWave-1} Cleared!`); } initializeStage(currentStage,currentWave); }}
            if (player1.health <= 0 && gameRunning) { announceOutcome("Game Over!", false); } updateUI();
        };

        function screenShake(intensity, duration) {
            document.body.style.transition = 'transform 0.05s';
            let startTime = Date.now();
            function shake() {
                let elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const x = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    const y = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    canvas.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(shake);
                } else {
                    canvas.style.transform = 'translate(0,0)';
                    document.body.style.transition = '';
                }
            }
            shake();
        }


        function showGameCompletionPopup() {
            gameRunning = false; messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            setManualPause(false);
            codeInputSection.classList.add('hidden'); deathOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            showPopup(messageBox); currentPopupAction = 'game_complete';
        }

        function updateUI() {
            if (!player1) return;
            healthText.textContent = `Health: ${player1.health}`;
            const healthPercentage = (player1.health / player1.initialHealth) * 100;
            healthBarInner.style.width = `${Math.max(0, Math.min(100, healthPercentage))}%`;
            if (healthPercentage <= 25) {
                healthBarInner.style.backgroundColor = '#f56565';
            } else if (healthPercentage <= 60) {
                healthBarInner.style.backgroundColor = '#ecc94b';
            } else {
                healthBarInner.style.backgroundColor = '#48bb78';
            }

            scoreDisplay.textContent = `Score: ${playerScore}`;
            bulletCountDisplay.textContent = `Shots: ${player1.bulletCount}`;
            player1.updateChargeIndicators();
        };
        function announceOutcome(message, isVictory) {
            gameRunning = false; messageText.textContent = message;
            setManualPause(false);
            codeInputSection.classList.add('hidden'); completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); deathOptions.classList.remove('hidden');
            actionButton1.textContent = "Respawn"; actionButton2.classList.remove('hidden'); actionButton2.textContent = "Revive";
            showPopup(messageBox); currentPopupAction = 'game_over_options';

            // MODIFIED: Changed prompt to use the globalPlayerName
            const playerNameForLeaderboard = globalPlayerName || `Fox${Math.floor(Math.random()*1000)}`;

            if (!isVictory) {
                // We'll just auto-save with the name they entered at the start.
                // const playerName = prompt("Game Over! Enter name for leaderboard:", `Fox${Math.floor(Math.random()*1000)}`);
                saveScoreToLeaderboard(playerNameForLeaderboard, playerScore);
                displayLeaderboard();
                leaderboardContainer.classList.remove('hidden');
            } else {
                leaderboardContainer.classList.add('hidden');
            }
        };
        actionButton1.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; leaderboardContainer.classList.add('hidden'); gameMode = 'normal'; document.body.className = 'select-none';
            setManualPause(false);
            player1.reset(true); currentStage = 1; currentWave = 1; targetsPerWaveBase = 2;
            initializeStage(1,1);
            gameRunning = true; lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        function saveScoreToLeaderboard(name, score) {
            let l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5')) || [];
            l.push({ name, score, date: new Date().toLocaleDateString(), stage: `${gameMode.substring(0,1).toUpperCase()}-S${currentStage}W${currentWave}` });
            l.sort((a,b) => b.score - a.score); l = l.slice(0,10); localStorage.setItem('ssbbLeaderboard_v6.5', JSON.stringify(l));
        };
        function displayLeaderboard() {
            leaderboardList.innerHTML = ""; const l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5')) || [];
            if (l.length === 0) { leaderboardList.innerHTML = "<li>No scores yet! Be the first!</li>"; return; }
            l.forEach(e => { const li = document.createElement('li'); li.textContent = `${e.name}: ${e.score} (${e.stage} - ${e.date})`; leaderboardList.appendChild(li); });
        };

        function gameLoop(currentTime) {
            if (!gameRunning && !isGameEffectivelyPaused()) {
            } else if (!gameRunning && isGameEffectivelyPaused()) {
                return;
            }

            const dT = Math.min(50, (currentTime - lastFrameTime) || (1000/60)); lastFrameTime = currentTime;

            if (!isGameEffectivelyPaused()) {
                trySpawnPowerUp();
                trySpawnHellEnemies();
                if (player1) {
                    player1.update(dT);
                    const playerX = player1.x;
                    const playerY = player1.y;
                    for (let i = gameTargets.length - 1; i >= 0; i--) {
                        gameTargets[i].update(playerX, playerY, dT, gameTargets);
                    }
                } else {
                    for (let i = gameTargets.length - 1; i >= 0; i--) {
                        gameTargets[i].update(0, 0, dT, gameTargets);
                    }
                }
                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    enemyProjectiles[i].update(dT);
                }
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    if (powerUps[i].update(dT)) {
                        powerUps.splice(i, 1);
                    }
                }
                checkCollisions();
            }

            drawStarfield(dT);
            drawTerrainObstacles();
            if (player1) { player1.draw(); }
            for (let i = 0; i < gameTargets.length; i++) {
                gameTargets[i].draw();
            }
            for (let i = 0; i < enemyProjectiles.length; i++) {
                enemyProjectiles[i].draw();
            }
            for (let i = 0; i < powerUps.length; i++) {
                powerUps[i].draw();
            }
            if (player1) {
                for (let i = 0; i < player1.projectiles.length; i++) {
                    player1.projectiles[i].draw();
                }
            }
            updateAndDrawParticles(dT);

            requestAnimationFrame(gameLoop);
        };

        function resizeCanvas() {
            const gameArea = document.querySelector('.game-container');
            const headerEl = document.querySelector('h1');
            const taglineEl = document.querySelector('.game-tagline');
            const uiTopBar = document.querySelector('.ui-top-bar');
            const stageRow = document.querySelector('#stageRow');
            const controlsInfoEl = document.querySelector('.controls-info');
            const buttonsEl = document.querySelector('.extra-buttons-container');

            const topUIHeight = (headerEl ? headerEl.offsetHeight : 0)
                + (taglineEl ? taglineEl.offsetHeight : 0)
                + (uiTopBar ? uiTopBar.offsetHeight : 0)
                + (stageRow ? stageRow.offsetHeight : 0)
                + 32;

            const leaderboardHeight = leaderboardContainer.classList.contains('hidden') ? 0 : leaderboardContainer.offsetHeight;
            const bottomUIHeight = (controlsInfoEl ? controlsInfoEl.offsetHeight : 0)
                + (buttonsEl ? buttonsEl.offsetHeight : 0)
                + leaderboardHeight
                + 24;

            const maxWidth = gameArea ? gameArea.clientWidth - 24 : window.innerWidth - 24;
            const availableWidth = Math.max(320, Math.min(window.innerWidth - 24, maxWidth));
            const availableHeight = window.innerHeight - topUIHeight - bottomUIHeight;

            const aspectRatio = 16 / 9;
            let newWidth = availableWidth;
            let newHeight = newWidth / aspectRatio;

            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * aspectRatio;
            }

            newWidth = Math.max(320, Math.min(newWidth, 1920));
            newHeight = Math.max(180, Math.min(newHeight, 1080));

            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            canvas.width = Math.round(newWidth * dpr);
            canvas.height = Math.round(newHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = false;

            CANVAS_WIDTH = newWidth;
            CANVAS_HEIGHT = newHeight;
            regenerateStarfield();

            if (player1) {
                player1.x = Math.max(0, Math.min(player1.x, CANVAS_WIDTH - player1.width));
                player1.y = Math.max(0, Math.min(player1.y, CANVAS_HEIGHT - player1.height));
                player1.smashMaxRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
                player1.smashExpansionSpeed = player1.smashMaxRadius / 50;
            }
            updateUI();
        };

        function startGame() {
            document.body.classList.add('select-none');
            setManualPause(false);
            document.body.classList.remove('hell-mode', 'endless-mode');
            mainGameContent.classList.remove('hidden');
            player1 = new FoxPlayer(50, CANVAS_HEIGHT/2 - PLAYER_HEIGHT/2, "Ranger", { up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',shoot:'Space',beam:'KeyB',smash:'KeyX' });
            setNextPowerupSpawnTime();
            setNextGreenHealthPackSpawnTime();
            setNextGoldenHealthPackSpawnTime();
            resizeCanvas(); window.addEventListener('resize', resizeCanvas);
            initializeStage(1,1);
            displayLeaderboard();
            if (JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5'))?.length > 0) {
                leaderboardContainer.classList.remove('hidden');
                resizeCanvas();
            }
            gameRunning = true;
            lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        showPopup(licensePopup);
        licenseKeyInput.focus();

    });
    </script>
</body>
</html>


