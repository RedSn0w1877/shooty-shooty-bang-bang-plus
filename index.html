<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShootyShooty BangBang Plus - v6.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --body-bg: radial-gradient(circle at 20% 20%, #1a1440 0%, #040414 55%, #02020f 100%);
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --panel-bg: rgba(12, 16, 40, 0.82);
            --panel-strong-bg: rgba(24, 32, 72, 0.78);
            --panel-border: rgba(124, 58, 237, 0.65);
            --panel-border-strong: rgba(138, 43, 226, 0.85);
            --accent: #8a2be2;
            --accent-strong: #4a00e0;
            --accent-warm: #f97316;
            --accent-cool: #06b6d4;
            --accent-gold: #fde047;
            --highlight: #7df9ff;
            --canvas-bg: rgba(10, 10, 30, 0.85);
            --canvas-border: #6900cc;
            --glow-strong: rgba(105, 0, 204, 0.7);
            --glow-soft: rgba(255, 255, 255, 0.18);
            --button-radius: 2rem;
            --panel-blur: 18px;
            --star-color-1: rgba(255, 255, 255, 0.65);
            --star-color-2: rgba(148, 163, 255, 0.55);
            --star-color-3: rgba(199, 146, 234, 0.55);
            --star-color-4: rgba(125, 249, 255, 0.45);
            --aurora-color-1: rgba(125, 249, 255, 0.22);
            --aurora-color-2: rgba(255, 94, 247, 0.18);
            --aurora-color-3: rgba(120, 114, 255, 0.2);
            --aurora-speed: 26s;
            --aurora-opacity: 0.65;
            --star-speed: 40s;
            --title-glow: #ffae42;
            --title-shadow: rgba(250, 204, 21, 0.35);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background: var(--body-bg);
            color: var(--text-main);
            margin: 0;
            padding-top: 0.5rem;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            transition: background 0.8s ease, color 0.4s ease;
            text-shadow: 0 0 10px rgba(125, 249, 255, 0.3);
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-image:
                radial-gradient(var(--star-color-1), rgba(255,255,255,0) 0.5px, transparent 15px),
                radial-gradient(var(--star-color-2), rgba(255,255,255,0) 1px, transparent 20px),
                radial-gradient(var(--star-color-3), rgba(255,255,255,0) 2px, transparent 40px),
                radial-gradient(var(--star-color-4), rgba(255,255,255,0) 1px, transparent 30px),
                radial-gradient(var(--aurora-color-1), rgba(255,255,255,0) 2px, transparent 30px),
                radial-gradient(var(--aurora-color-2), rgba(255,255,255,0) 2px, transparent 35px);
            background-repeat: repeat;
            background-size: 150px 150px, 200px 200px, 500px 500px, 300px 300px, 220px 220px, 130px 130px;
            background-position: 0 0, 10px 10px, 30px 50px, 110px 250px, 60px 90px, 20px 180px;
            animation: starsAnim var(--star-speed) linear infinite, aurora-2 6s linear infinite;
        }

        body::after {
            content: "";
            position: fixed;
            inset: -20%;
            z-index: -2;
            background: radial-gradient(circle at 20% 20%, var(--aurora-color-1), transparent 55%),
                        radial-gradient(circle at 80% 10%, var(--aurora-color-2), transparent 60%),
                        radial-gradient(circle at 50% 80%, var(--aurora-color-3), transparent 65%);
            opacity: var(--aurora-opacity);
            filter: blur(80px) saturate(120%);
            transform: translateZ(0);
            animation: auroraDance var(--aurora-speed) ease-in-out infinite alternate;
        }

        @keyframes starsAnim {
            from { background-position: 0 0, 10px 10px, 30px 50px, 110px 250px, 60px 90px, 20px 180px; }
            to { background-position: -150px -150px, -190px -190px, -470px -450px, -190px 0px, -160px -130px, -110px 0px; }
        }

        @keyframes auroraDance {
            0% { transform: translate(-10%, -8%) scale(1.05) rotate(0deg); opacity: 0.55; }
            50% { transform: translate(6%, 4%) scale(1.1) rotate(2deg); opacity: 0.75; }
            100% { transform: translate(-4%, 6%) scale(1.04) rotate(-2deg); opacity: 0.6; }
        }

        @keyframes aurora-2 {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        body.hell-mode {
            background: radial-gradient(circle at 20% 20%, #3c0505 0%, #1a0000 70%, #0a0000 100%);
        }
        body.hell-mode::before {
            background-image:
                radial-gradient(red, rgba(255,0,0,0) 0.5px, transparent 20px),
                radial-gradient(yellow, rgba(255,255,0,0) 1px, transparent 25px),
                radial-gradient(orangered, rgba(255,69,0,0) 2px, transparent 40px),
                radial-gradient(red, rgba(255,0,0,0) 1px, transparent 30px),
                radial-gradient(darkred, rgba(139,0,0,0) 2px, transparent 40px);
            background-size: 120px 120px, 180px 180px, 450px 450px, 280px 280px, 200px 200px;
            animation: starsAnimHell 30s linear infinite;
        }
        body.hell-mode::after {
            background: radial-gradient(circle at 30% 20%, rgba(255, 86, 34, 0.28), transparent 60%),
                        radial-gradient(circle at 80% 70%, rgba(255, 0, 0, 0.25), transparent 65%),
                        radial-gradient(circle at 50% 40%, rgba(255, 196, 34, 0.18), transparent 70%);
            filter: blur(90px) saturate(140%);
            opacity: 0.55;
            animation-duration: calc(var(--aurora-speed) * 0.6);
        }

        @keyframes starsAnimHell {
            from { background-position: 0 0, 20px 30px, 40px 60px, 130px 270px, 0 100px; }
            to { background-position: -120px 120px, -160px 150px, 410px -390px, -150px 0px, 200px -100px; }
        }

        body.endless-mode {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            animation: endlessGradientShift 20s ease infinite alternate;
        }
         body.endless-mode::before { opacity: 0.6; }
        body.endless-mode::after {
            background: radial-gradient(circle at 20% 30%, rgba(26, 42, 108, 0.28), transparent 65%),
                        radial-gradient(circle at 75% 30%, rgba(248, 187, 61, 0.22), transparent 70%),
                        radial-gradient(circle at 40% 80%, rgba(209, 35, 35, 0.2), transparent 75%);
            opacity: 0.55;
            animation-duration: calc(var(--aurora-speed) * 0.8);
        }

        @keyframes stagePulse {
            0% { letter-spacing: 0.05em; text-shadow: 0 0 10px rgba(125, 249, 255, 0.3); }
            50% { letter-spacing: 0.12em; text-shadow: 0 0 18px rgba(125, 249, 255, 0.6); }
            100% { letter-spacing: 0.05em; text-shadow: 0 0 10px rgba(125, 249, 255, 0.3); }
        }

        @keyframes panelShimmer {
            0% { transform: translateX(-10%) skewX(-5deg); opacity: 0.65; }
            50% { transform: translateX(10%) skewX(5deg); opacity: 0.85; }
            100% { transform: translateX(-15%) skewX(-4deg); opacity: 0.65; }
        }

        @keyframes leaderboardGlow {
            0% { opacity: 0.35; transform: rotate(0deg) scale(1); }
            50% { opacity: 0.6; transform: rotate(8deg) scale(1.1); }
            100% { opacity: 0.35; transform: rotate(-6deg) scale(0.98); }
        }

        @keyframes buttonSweep {
            from { transform: translateX(-50%) rotate(25deg); }
            to { transform: translateX(120%) rotate(25deg); }
        }

        @keyframes barShimmer {
            0% { transform: translateX(-60%); }
            100% { transform: translateX(60%); }
        }

        @keyframes endlessGradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body.theme-nebula:not(.hell-mode):not(.endless-mode) {
            --body-bg: radial-gradient(circle at 15% 15%, #3422a8 0%, #130636 48%, #05051a 100%);
            --panel-bg: rgba(14, 18, 48, 0.82);
            --panel-strong-bg: rgba(26, 32, 72, 0.78);
            --panel-border: rgba(99, 102, 241, 0.65);
            --panel-border-strong: rgba(168, 85, 247, 0.85);
            --accent: #8b5cf6;
            --accent-strong: #4f46e5;
            --accent-warm: #f97316;
            --accent-cool: #22d3ee;
            --highlight: #a5b4fc;
            --canvas-border: #7c3aed;
            --glow-strong: rgba(124, 58, 237, 0.65);
            --star-color-1: rgba(208, 213, 255, 0.85);
            --star-color-2: rgba(165, 180, 252, 0.65);
            --star-color-3: rgba(129, 140, 248, 0.6);
            --star-color-4: rgba(96, 165, 250, 0.5);
            --aurora-color-1: rgba(79, 70, 229, 0.25);
            --aurora-color-2: rgba(59, 130, 246, 0.22);
            --aurora-color-3: rgba(236, 72, 153, 0.18);
        }

        body.theme-aurora:not(.hell-mode):not(.endless-mode) {
            --body-bg: linear-gradient(140deg, #041b2d 0%, #042f3d 35%, #052418 70%, #03090f 100%);
            --panel-bg: rgba(8, 36, 50, 0.82);
            --panel-strong-bg: rgba(12, 55, 68, 0.76);
            --panel-border: rgba(45, 212, 191, 0.55);
            --panel-border-strong: rgba(20, 184, 166, 0.85);
            --accent: #14b8a6;
            --accent-strong: #0f766e;
            --accent-warm: #f97316;
            --accent-cool: #06b6d4;
            --highlight: #5eead4;
            --canvas-border: #0ea5e9;
            --glow-strong: rgba(45, 212, 191, 0.55);
            --star-color-1: rgba(190, 242, 255, 0.85);
            --star-color-2: rgba(56, 189, 248, 0.6);
            --star-color-3: rgba(45, 212, 191, 0.55);
            --star-color-4: rgba(34, 211, 238, 0.45);
            --aurora-color-1: rgba(34, 197, 94, 0.2);
            --aurora-color-2: rgba(6, 182, 212, 0.24);
            --aurora-color-3: rgba(14, 165, 233, 0.2);
        }

        body.theme-sunset:not(.hell-mode):not(.endless-mode) {
            --body-bg: linear-gradient(160deg, #2d0f3a 0%, #432371 45%, #fb6f92 100%);
            --panel-bg: rgba(48, 19, 68, 0.78);
            --panel-strong-bg: rgba(63, 27, 84, 0.76);
            --panel-border: rgba(236, 72, 153, 0.55);
            --panel-border-strong: rgba(244, 114, 182, 0.85);
            --accent: #f472b6;
            --accent-strong: #db2777;
            --accent-warm: #fb7185;
            --accent-cool: #38bdf8;
            --highlight: #f9a8d4;
            --canvas-border: #ec4899;
            --glow-strong: rgba(236, 72, 153, 0.55);
            --star-color-1: rgba(255, 228, 230, 0.8);
            --star-color-2: rgba(251, 191, 219, 0.65);
            --star-color-3: rgba(248, 113, 113, 0.55);
            --star-color-4: rgba(251, 191, 36, 0.5);
            --aurora-color-1: rgba(236, 72, 153, 0.25);
            --aurora-color-2: rgba(249, 115, 22, 0.2);
            --aurora-color-3: rgba(14, 165, 233, 0.18);
        }

        body.theme-cyber:not(.hell-mode):not(.endless-mode) {
            --body-bg: linear-gradient(140deg, #06041f 0%, #1a0738 50%, #021019 100%);
            --panel-bg: rgba(10, 10, 30, 0.84);
            --panel-strong-bg: rgba(20, 18, 50, 0.78);
            --panel-border: rgba(6, 182, 212, 0.55);
            --panel-border-strong: rgba(20, 184, 166, 0.8);
            --accent: #22d3ee;
            --accent-strong: #0891b2;
            --accent-warm: #f97316;
            --accent-cool: #38bdf8;
            --highlight: #67e8f9;
            --canvas-border: #22d3ee;
            --glow-strong: rgba(56, 189, 248, 0.55);
            --star-color-1: rgba(244, 244, 255, 0.85);
            --star-color-2: rgba(125, 211, 252, 0.6);
            --star-color-3: rgba(6, 182, 212, 0.5);
            --star-color-4: rgba(16, 185, 129, 0.45);
            --aurora-color-1: rgba(14, 165, 233, 0.3);
            --aurora-color-2: rgba(56, 189, 248, 0.25);
            --aurora-color-3: rgba(16, 185, 129, 0.2);
        }

        #gameCanvas {
            border: 3px solid var(--canvas-border);
            border-radius: 1rem;
            background-color: var(--canvas-bg);
            box-shadow: 0 0 35px var(--glow-strong), 0 0 12px var(--glow-soft) inset;
            cursor: crosshair;
            transition: border-color 0.3s ease, transform 0.05s, box-shadow 0.3s ease, background-color 0.3s ease;
        }
        body.hell-mode #gameCanvas {
            border-color: #ff3300;
            box-shadow: 0 0 25px rgba(255, 51, 0, 0.7), 0 0 10px rgba(255,100,100,0.2) inset;
        }
         body.endless-mode #gameCanvas {
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7), 0 0 10px rgba(255,255,200,0.2) inset;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
            max-width: 100%;
            padding: 0.25rem;
            background: var(--panel-bg);
            border-radius: 2rem;
            box-shadow: 0 20px 45px rgba(2, 6, 23, 0.45), inset 0 0 0 1px rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(var(--panel-blur));
            border: 1px solid var(--panel-border);
            transition: background 0.6s ease, border-color 0.6s ease, box-shadow 0.6s ease, transform 0.3s ease;
            animation: float 6s ease-in-out infinite;
        }
        .modal-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background: rgba(6, 11, 30, 0.92);
            color: var(--text-main); padding: 2rem 2.5rem; border-radius: 2rem;
            text-align: center; font-size: 1.25rem; z-index: 100;
            box-shadow: 0 35px 65px rgba(2, 6, 23, 0.6), 0 0 45px rgba(124, 58, 237, 0.45);
            width: 90%; max-width: 600px;
            border: 1px solid var(--panel-border-strong);
            opacity: 0;
            pointer-events: none;
            backdrop-filter: blur(calc(var(--panel-blur) - 4px));
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s ease-out, box-shadow 0.3s ease;
        }

        #licensePopup, #namePopup, #loadingScreen {
            position: fixed; top: 50%; left: 50%;
            background: rgba(8, 16, 44, 0.94);
            color: var(--text-main); padding: 2.5rem 3rem; border-radius: 1rem;
            text-align: center; font-size: 1.25rem; z-index: 1000;
            box-shadow: 0 40px 75px rgba(2, 6, 23, 0.65), 0 0 55px rgba(125, 249, 255, 0.5);
            width: 90%; max-width: 550px;
            border: 1px solid rgba(125, 249, 255, 0.6);
            opacity: 0;
            pointer-events: none;
            backdrop-filter: blur(calc(var(--panel-blur) - 6px));
            transition: transform 0.25s cubic-bezier(0.24, 0.82, 0.25, 1.2), opacity 0.2s ease-out, box-shadow 0.25s ease;
        }
        .hud-flyout.visible {
            transform: translate3d(0, 0, 0) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        #licensePopup, #namePopup, #loadingScreen {
            background: rgba(8, 16, 44, 0.94);
            padding: 2.5rem 3rem;
            font-size: 1.2rem;
            z-index: 1000;
            box-shadow: 0 40px 75px rgba(2, 6, 23, 0.65), 0 0 55px rgba(125, 249, 255, 0.5);
            width: min(90%, 550px);
            border: 1px solid rgba(125, 249, 255, 0.6);
        }

        /* NEW POPUP STYLE */
        #adminPasswordPopup {
            box-shadow: 0 0 30px rgba(234, 179, 8, 0.5), 0 5px 20px rgba(0,0,0,0.5); /* Yellow glow for admin */
            width: min(90%, 500px);
            border: 2px solid #eab308; /* Yellow border */
            z-index: 101; /* Above messageBox */
        }
        #adminPasswordPopup input {
            background-color: #1e1e3f; color: #e0e0ff; border: 1px solid #eab308;
            padding: 0.6rem; border-radius: 0.375rem; margin-right: 0.3rem; font-size: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); transition: border-color 0.2s, box-shadow 0.2s;
        }
        #adminPasswordPopup input:focus {
            border-color: #fde047; box-shadow: 0 0 8px rgba(253, 224, 71, 0.5), inset 0 1px 3px rgba(0,0,0,0.4); outline: none;
        }
        /* END NEW POPUP STYLE */


        #licensePopup { 
            transform: translate(-50%, -150vh) scale(0.8);
            transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease-out;
        }
        #namePopup {
            transform: translate(-50%, 150vh) scale(0.8);
            transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease-out;
        }
        #loadingScreen { 
            transform: translate(-50%, -50%) scale(0.9);
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
        }

        #licensePopup.visible,
        #namePopup.visible,
        #loadingScreen.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }


        .modal-popup.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }
        #tempPopup.visible {
             pointer-events: none;
             z-index: 101;
        }
        #loadingScreen.visible {
            z-index: 1001;
        }


        #changelogPopup {
            text-align: left;
            font-size: 0.9rem;
            max-height: 80vh;
            overflow-y: auto;
            background-color: rgba(15, 15, 40, 0.98);
        }
        #changelogContent p {
            margin-bottom: 0.4rem;
            line-height: 1.5;
            color: #c0c0ff;
        }
        #changelogContent p:first-child {
            color: #ffae42;
            font-weight: bold;
        }

        .hidden { display: none !important; }

        .ui-top-bar {
            display: flex;
            flex-wrap: wrap;
            align-items: stretch;
            justify-content: center;
            width: 100%;
            padding: 1rem 1.1rem;
            box-sizing: border-box;
            font-size: 0.9rem;
            background: var(--panel-strong-bg);
            border-radius: 0.75rem;
            margin-bottom: 0.3rem;
            border: 1px solid var(--panel-border-strong);
            box-shadow: 0 15px 30px rgba(2, 6, 23, 0.35), inset 0 0 0 1px rgba(255,255,255,0.04);
            backdrop-filter: blur(calc(var(--panel-blur) - 6px));
            position: relative;
            overflow: hidden;
        }
        .ui-top-bar::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255,255,255,0.08), transparent 40%, rgba(255,255,255,0.06));
            opacity: 0.8;
            mix-blend-mode: screen;
            pointer-events: none;
            animation: panelShimmer 12s ease-in-out infinite;
        }
        .score-display {
            color: rgba(253, 224, 71, 0.9);
            letter-spacing: 0.05em;
            text-shadow: 0 0 12px rgba(253, 224, 71, 0.35);
        }
        .version-box {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 0.8rem;
            color: var(--text-muted);
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.7));
            padding: 0.35rem 0.6rem;
            border-radius: 0.5rem;
            z-index: 1000;
            border: 1px solid rgba(148, 163, 184, 0.25);
            backdrop-filter: blur(12px);
            box-shadow: 0 10px 20px rgba(2, 6, 23, 0.35);
        }
        .charge-container { background: rgba(15, 23, 42, 0.75); width: 80px; height: 12px; border-radius: 999px; overflow: hidden; border: 1px solid rgba(148, 163, 255, 0.35); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), inset 0 0 12px rgba(15, 118, 110, 0.35); }
        .charge-bar { height: 100%; width: 0%; transition: width 0.15s ease-out, background 0.3s ease, box-shadow 0.3s ease; border-radius: 999px; position: relative; overflow: hidden; }
        .charge-bar::after { content: ""; position: absolute; inset: 0; background: linear-gradient(120deg, rgba(255,255,255,0.3), transparent 45%, rgba(255,255,255,0.25)); mix-blend-mode: screen; opacity: 0.7; animation: barShimmer 2.4s linear infinite; }
        .beam-charge-bar { background: linear-gradient(to right, rgba(249, 115, 22, 0.65), rgba(251, 191, 36, 0.85)); }
        .beam-charge-bar.ready { background: linear-gradient(to right, rgba(52, 211, 153, 0.75), rgba(110, 231, 183, 0.95)); box-shadow: 0 0 12px rgba(52, 211, 153, 0.85); }
        .smash-charge-bar { background: linear-gradient(to right, rgba(239, 68, 68, 0.7), rgba(248, 113, 113, 0.9)); }
        .smash-charge-bar.ready { background: linear-gradient(to right, rgba(168, 85, 247, 0.75), rgba(192, 132, 252, 0.95)); box-shadow: 0 0 12px rgba(168, 85, 247, 0.85); }

        #healthDisplayContainer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            margin-bottom: 0.6rem;
        }
        .hud-flyout__badge {
            font-size: 0.65rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: rgba(148, 163, 255, 0.78);
            background: rgba(24, 36, 72, 0.9);
            padding: 0.35rem 0.85rem;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 255, 0.3);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
        }
        .hud-flyout__message {
            margin: 0 0 0.9rem;
            font-size: 1.05rem;
            line-height: 1.45;
            color: rgba(226, 232, 240, 0.95);
        }
        .hud-flyout__actions,
        .hud-flyout .mode-selection-buttons,
        .hud-flyout #deathOptions,
        .hud-flyout #hellConfirmOptions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.6rem;
        }
        .hud-flyout .mode-selection-buttons,
        .hud-flyout #hellConfirmOptions {
            flex-direction: column;
        }
        @media (min-width: 540px) {
            .hud-flyout .mode-selection-buttons,
            .hud-flyout #hellConfirmOptions {
                flex-direction: row;
            }
        }
        .hud-flyout .input-group {
            flex-direction: column;
            align-items: stretch;
            gap: 0.5rem;
        }
        #healthText {
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.03em;
            color: rgba(226, 232, 240, 0.9);
        }
        .health-bar-container {
            width: 80px;
            height: 12px;
            background: rgba(15, 23, 42, 0.78);
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 255, 0.35);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
        }
        .health-bar-inner {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, rgba(74, 222, 128, 0.9), rgba(56, 189, 248, 0.85));
            border-radius: 999px;
            transition: width 0.2s ease-out;
        }

        .stage-info, .game-title, .game-title-like, .popup-title {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .game-title-like {
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.85), rgba(125, 249, 255, 0.85));
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 16px rgba(125, 249, 255, 0.35);
            letter-spacing: 0.05em;
        }
        .popup-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--highlight);
            text-shadow: 0 0 18px rgba(125, 249, 255, 0.55);
            letter-spacing: 0.06em;
        }
        /* NEW: Admin popup title */
        #adminPasswordPopup .popup-title {
            color: #fde047;
            text-shadow: 0 0 8px rgba(253, 224, 71, 0.7);
        }
        .stage-info {
            font-size: 1.15rem; font-weight: 600; color: var(--highlight);
            text-shadow: 0 0 12px rgba(125, 249, 255, 0.4);
            margin-bottom: 0.3rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            animation: stagePulse 10s ease-in-out infinite;
        }
        .game-title {
            background: linear-gradient(90deg, rgba(255, 196, 125, 0.95), rgba(255, 255, 255, 0.9), rgba(252, 165, 165, 0.9));
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px var(--title-shadow), 0 0 40px rgba(249, 115, 22, 0.35);
            animation: titleGlow 6s ease-in-out infinite alternate;
            letter-spacing: 0.08em;
        }
        @keyframes titleGlow {
            0% { text-shadow: 0 0 18px var(--title-shadow), 0 0 32px rgba(249, 115, 22, 0.25); }
            50% { text-shadow: 0 0 24px rgba(253, 224, 71, 0.55), 0 0 45px rgba(249, 115, 22, 0.45); }
            100% { text-shadow: 0 0 18px var(--title-shadow), 0 0 30px rgba(249, 115, 22, 0.3); }
        }
        .controls-info .font-semibold {
             font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
             font-size: 1.05rem;
             color: var(--highlight);
             letter-spacing: 0.04em;
             text-transform: uppercase;
         }


        .controls-info { background: var(--panel-strong-bg); padding: 0.75rem; border-radius: 0.75rem; margin-top: 0.6rem; font-size: 0.8rem; text-align: center; width: 100%; border: 1px solid var(--panel-border-strong); box-shadow: 0 10px 25px rgba(2, 6, 23, 0.28); backdrop-filter: blur(calc(var(--panel-blur) - 4px)); }
        .controls-info p { margin: 0.2rem 0; }

        #leaderboardContainer { margin-top: 0.75rem; padding: 1.1rem; background: var(--panel-strong-bg); border-radius: 0.85rem; width: 90%; max-width: 500px; text-align: center; border: 1px solid var(--panel-border-strong); box-shadow: 0 18px 35px rgba(2, 6, 23, 0.4), inset 0 0 0 1px rgba(255,255,255,0.04); backdrop-filter: blur(calc(var(--panel-blur) - 4px)); position: relative; overflow: hidden; }
        #leaderboardContainer::before { content: ""; position: absolute; inset: -40%; background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.08), transparent 65%); opacity: 0.7; animation: leaderboardGlow 18s ease-in-out infinite; pointer-events: none; }
        #leaderboardContainer h2 {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.2rem;
            background: linear-gradient(90deg, rgba(255, 174, 66, 0.95), rgba(255, 255, 255, 0.9));
            -webkit-background-clip: text;
            color: transparent;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        #leaderboardList { list-style: none; padding: 0; max-height: 150px; overflow-y: auto; }
        #leaderboardList li { padding: 0.4rem 0.35rem; border-bottom: 1px solid rgba(148, 163, 255, 0.25); font-size: 0.85rem; color: rgba(226, 232, 240, 0.9); letter-spacing: 0.03em; transition: background 0.3s ease, transform 0.2s ease; }
        #leaderboardList li:last-child { border-bottom: none; }
        #leaderboardList li:nth-child(odd) { background-color: rgba(148,163,255,0.08); }
        #leaderboardList li:hover { background-color: rgba(125, 249, 255, 0.15); transform: translateX(4px); }

        .input-group { margin-top: 0.75rem; }
        .input-group input {
            background-color: rgba(15, 23, 42, 0.85); color: var(--text-main); border: 1px solid var(--panel-border-strong);
            padding: 0.6rem; border-radius: 0.6rem; margin-right: 0.3rem; font-size: 1rem;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.05), 0 0 0 1px rgba(255,255,255,0.05);
            transition: border-color 0.2s, box-shadow 0.3s ease, transform 0.2s ease;
        }
        .input-group input:focus { border-color: rgba(199, 146, 234, 0.9); box-shadow: 0 0 12px rgba(199, 146, 234, 0.45), inset 0 1px 2px rgba(255,255,255,0.08); outline: none; transform: translateY(-1px); }

        .button {
            position: relative;
            padding: 0.65rem 1.25rem; font-weight: 600; border-radius: var(--button-radius);
            transition: background 0.3s ease-out, color 0.2s ease-out, transform 0.18s ease-out, box-shadow 0.3s ease-out, border-color 0.3s ease-out;
            cursor: pointer; border-width: 2px; border-style: solid;
            font-size: 0.95rem; text-transform: uppercase;
            letter-spacing: 0.6px; box-shadow: 0 8px 18px rgba(2, 6, 23, 0.35);
            background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.08), transparent 55%);
            overflow: hidden;
            isolation: isolate;
        }
        .button::before {
            content: "";
            position: absolute;
            inset: -120% -40%;
            background: linear-gradient(120deg, rgba(255,255,255,0.25), rgba(255,255,255,0.05), rgba(255,255,255,0.25));
            opacity: 0;
            transform: translateX(-120%) rotate(25deg);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .button:hover {
            transform: translateY(-3px) scale(1.01);
            box-shadow: 0 14px 24px rgba(2, 6, 23, 0.45);
            animation: glowing-border 2s infinite, jello 1s;
        }
        .button:hover::before { opacity: 0.9; animation: buttonSweep 0.85s ease forwards; }
        .button:active {
            transform: translateY(0px) scale(0.99);
            box-shadow: 0 8px 16px rgba(2, 6, 23, 0.35);
        }

        @keyframes glowing-border {
            0% {
                border-color: #ffeb3b;
                box-shadow: 0 0 10px #ffeb3b;
            }
            50% {
                border-color: #ff5722;
                box-shadow: 0 0 20px #ff5722;
            }
            100% {
                border-color: #ffeb3b;
                box-shadow: 0 0 10px #ffeb3b;
            }
        }

        @keyframes jello {
            0% {
                transform: scale(1);
            }
            30% {
                transform: scale(1.25);
            }
            40% {
                transform: scale(0.9);
            }
            50% {
                transform: scale(1.15);
            }
            65% {
                transform: scale(0.95);
            }
            75% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
            100% {
                transform: translateY(0px);
            }
        }

        .button-primary { border-color: var(--accent-warm); color: var(--accent-warm); background: linear-gradient(135deg, rgba(249, 115, 22, 0.15), rgba(255, 255, 255, 0)); }
        .button-primary:hover { background: linear-gradient(135deg, rgba(249, 115, 22, 0.3), rgba(255,255,255,0.05)); color: #fdba74; border-color: rgba(249, 115, 22, 0.85);}

        .button-secondary { border-color: var(--accent); color: var(--accent); background: linear-gradient(135deg, rgba(124, 58, 237, 0.18), transparent 60%); }
        .button-secondary:hover { background: linear-gradient(135deg, rgba(124, 58, 237, 0.35), transparent 55%); color: #c4b5fd; border-color: rgba(124, 58, 237, 0.85);}

        .button-danger { border-color: #ef4444; color: #ef4444; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), transparent 60%); }
        .button-danger:hover { background: linear-gradient(135deg, rgba(239, 68, 68, 0.35), transparent 55%); color: #fca5a5; border-color: rgba(239, 68, 68, 0.85);}

        .button-special { border-color: var(--accent-cool); color: var(--accent-cool); background: linear-gradient(135deg, rgba(6, 182, 212, 0.18), transparent 60%); }
        .button-special:hover { background: linear-gradient(135deg, rgba(6, 182, 212, 0.35), transparent 55%); color: #67e8f9; border-color: rgba(6, 182, 212, 0.85);}

        .button-godmode { border-color: var(--accent-gold); color: var(--accent-gold); background: linear-gradient(135deg, rgba(234, 179, 8, 0.18), transparent 60%); }
        .button-godmode:hover { background: linear-gradient(135deg, rgba(234, 179, 8, 0.3), transparent 55%); color: #fde047; border-color: rgba(234, 179, 8, 0.85);}

        .button-healthboost { border-color: #22c55e; color: #22c55e; background: linear-gradient(135deg, rgba(34, 197, 94, 0.18), transparent 60%); }
        .button-healthboost:hover { background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), transparent 55%); color: #4ade80; border-color: rgba(34, 197, 94, 0.85);}

        .button-finish { border-color: #3b82f6; color: #3b82f6; background: linear-gradient(135deg, rgba(59, 130, 246, 0.18), transparent 60%); }
        .button-finish:hover { background: linear-gradient(135deg, rgba(59, 130, 246, 0.35), transparent 55%); color: #60a5fa; border-color: rgba(59, 130, 246, 0.85);}

        .button-close {
            position: absolute; top: 0.75rem; right: 1rem;
            background: none; border: none; color: rgba(226, 232, 240, 0.45);
            font-size: 2rem; line-height: 1; cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            text-shadow: 0 0 12px rgba(148, 163, 255, 0.35);
        }
        .button-close:hover { color: var(--highlight); transform: rotate(90deg) scale(1.1); }

        .command-dock {
            width: 100%;
            padding: 0.85rem 1.1rem 1rem;
            border-radius: 1.05rem;
            background: linear-gradient(150deg, rgba(12, 20, 44, 0.85), rgba(29, 37, 78, 0.6));
            border: 1px solid rgba(148, 163, 255, 0.25);
            box-shadow: 0 18px 36px rgba(2, 6, 23, 0.4), inset 0 0 0 1px rgba(255,255,255,0.03);
            backdrop-filter: blur(calc(var(--panel-blur) - 6px));
            display: flex;
            flex-direction: column;
            gap: 0.7rem;
            margin-top: 0.8rem;
        }
        .command-dock__header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            flex-wrap: wrap;
            gap: 0.35rem;
        }
        .command-dock__title {
            font-size: 0.75rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: var(--highlight);
        }
        .command-dock__subtitle {
            font-size: 0.65rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.75);
        }
        .extra-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.7rem;
            justify-content: center;
        }
        .mode-selection-buttons { display: flex; justify-content: center; gap: 1.2rem; margin-top: 1.2rem; }

        #loadingProgressBarContainer {
            width: 80%;
            height: 25px;
            background: rgba(15, 23, 42, 0.85);
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 255, 0.35);
            margin-top: 1.5rem;
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 15px 25px rgba(2, 6, 23, 0.35);
        }
        #loadingProgressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.75), rgba(192, 132, 252, 0.9), rgba(236, 72, 153, 0.85));
            border-radius: 999px;
            transition: width 0.25s ease-out;
            box-shadow: 0 0 15px rgba(192, 132, 252, 0.65);
            position: relative;
            overflow: hidden;
        }
        #loadingProgressBar::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255,255,255,0.35), rgba(255,255,255,0));
            mix-blend-mode: screen;
            animation: barShimmer 1.8s linear infinite;
        }
        .input-error {
            border-color: red !important;
            animation: shake 0.3s;
        }
        @keyframes shake {
            0%, 100% {transform: translateX(0);}
            25% {transform: translateX(-5px);}
            75% {transform: translateX(5px);}
        }

        .theme-panel {
            position: fixed;
            top: 1.25rem;
            left: 1.25rem;
            z-index: 1100;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            color: var(--text-main);
        }
        .theme-panel__toggle {
            border: 1px solid rgba(148, 163, 255, 0.35);
            background: rgba(15, 23, 42, 0.7);
            color: rgba(226, 232, 240, 0.9);
            padding: 0.45rem 1rem;
            border-radius: 999px;
            font-size: 0.85rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            box-shadow: 0 12px 24px rgba(2, 6, 23, 0.35);
            backdrop-filter: blur(12px);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.3s ease, background 0.3s ease;
        }
        .theme-panel__toggle:hover {
            transform: translateY(-2px);
            background: rgba(30, 41, 59, 0.8);
            box-shadow: 0 16px 28px rgba(2, 6, 23, 0.45);
        }
        .theme-panel__content {
            background: rgba(8, 16, 44, 0.82);
            border-radius: 1rem;
            padding: 1rem 1.15rem;
            width: min(280px, 90vw);
            border: 1px solid rgba(148, 163, 255, 0.25);
            box-shadow: 0 20px 35px rgba(2, 6, 23, 0.45);
            backdrop-filter: blur(16px);
            transform-origin: top left;
            transition: transform 0.35s ease, opacity 0.35s ease;
            opacity: 0;
            transform: scale(0.9) translateY(-10px);
            pointer-events: none;
        }
        .theme-panel__content.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }
        .theme-panel__title {
            margin: 0 0 0.5rem 0;
            font-size: 0.95rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.9);
        }
        .theme-swatches {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.5rem;
        }
        .theme-swatch {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.65rem 0.5rem;
            border-radius: 0.75rem;
            border: 1px solid transparent;
            color: rgba(226, 232, 240, 0.88);
            font-size: 0.85rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .theme-swatch::before {
            content: "";
            position: absolute;
            inset: 0;
            opacity: 0.9;
            z-index: -1;
        }
        .theme-swatch[data-theme="nebula"]::before {
            background: linear-gradient(135deg, #312e81, #5b21b6);
        }
        .theme-swatch[data-theme="aurora"]::before {
            background: linear-gradient(135deg, #0f766e, #0ea5e9);
        }
        .theme-swatch[data-theme="sunset"]::before {
            background: linear-gradient(135deg, #be123c, #f97316);
        }
        .theme-swatch[data-theme="cyber"]::before {
            background: linear-gradient(135deg, #1d4ed8, #0f172a);
        }
        .theme-swatch:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 20px rgba(2, 6, 23, 0.35);
            border-color: rgba(255,255,255,0.35);
        }
        .theme-swatch.theme-active {
            border-color: rgba(255,255,255,0.55);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.2), 0 12px 25px rgba(2, 6, 23, 0.45);
        }
        .theme-slider {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            margin-top: 0.75rem;
        }
        .theme-slider span {
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.8);
        }
        .theme-slider input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 999px;
            background: rgba(148, 163, 255, 0.3);
            outline: none;
            cursor: pointer;
        }
        .theme-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 2px solid rgba(148, 163, 255, 0.9);
            box-shadow: 0 4px 10px rgba(2, 6, 23, 0.35);
            transition: transform 0.2s ease;
        }
        .theme-slider input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 2px solid rgba(148, 163, 255, 0.9);
            box-shadow: 0 4px 10px rgba(2, 6, 23, 0.35);
            transition: transform 0.2s ease;
        }
        .theme-slider input[type="range"]::-webkit-slider-thumb:hover,
        .theme-slider input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.15);
        }
        @media (max-width: 640px) {
            .theme-panel {
                top: auto;
                bottom: 1rem;
                left: 50%;
                transform: translateX(-50%);
                align-items: center;
            }
            .theme-panel__content {
                transform-origin: bottom center;
            }
        }

    </style>
</head>
<body class="select-none theme-nebula">
    <div id="versionDisplay" class="version-box">V6.4</div>
    <div class="theme-panel">
        <button id="themePanelToggle" type="button" class="theme-panel__toggle">✨ Themes</button>
        <div id="themePanelContent" class="theme-panel__content">
            <p class="theme-panel__title">Choose your vibe</p>
            <div class="theme-swatches">
                <button type="button" class="theme-swatch" data-theme="nebula">Nebula</button>
                <button type="button" class="theme-swatch" data-theme="aurora">Aurora</button>
                <button type="button" class="theme-swatch" data-theme="sunset">Sunset</button>
                <button type="button" class="theme-swatch" data-theme="cyber">Cyber</button>
            </div>
            <label class="theme-slider" for="themeAnimationSpeed">
                <span>Starfield speed</span>
                <input type="range" id="themeAnimationSpeed" min="15" max="70" step="5" value="40">
            </label>
            <label class="theme-slider" for="themeGlowIntensity">
                <span>Glow intensity</span>
                <input type="range" id="themeGlowIntensity" min="40" max="90" step="5" value="65">
            </label>
        </div>
    </div>
    <div id="tempPopup" class="hidden"></div>

    <div id="licensePopup" class="modal-popup hidden">
        <h2 class="popup-title">Game Integrity Protection GIP</h2>
        <p class="mb-4">Please enter your license key to play this game.</p>
        <div class="input-group">
            <input type="text" id="licenseKeyInput" placeholder="Enter License Key" class="w-full sm:w-2/3">
            <button id="submitLicenseKeyButton" class="button button-primary mt-2 sm:mt-0 sm:ml-2">Verify Key</button>
        </div>
        <p id="licenseErrorText" class="text-red-400 text-sm mt-2 hidden">Invalid License Key!</p>
    </div>

    <div id="namePopup" class="modal-popup hidden">
        <h2 class="popup-title">Integrity Verified.</h2>
        <p class="mb-4">Please enter your name.</p>
        <div class="input-group">
            <input type="text" id="playerNameInput" placeholder="Enter Your Name" class="w-full sm:w-2/3">
            <button id="submitPlayerNameButton" class="button button-primary mt-2 sm:mt-0 sm:ml-2">Start Game</button>
        </div>
    </div>

    <div id="loadingScreen" class="modal-popup hidden">
        <h2 id="loadingWelcomeText" class="popup-title">Welcome!</h2>
        <p class="mb-4">We're loading your game environment, please wait.</p>
        <div id="loadingProgressBarContainer">
            <div id="loadingProgressBar"></div>
        </div>
    </div>

    <!-- NEW ADMIN PASSWORD POPUP -->
    <div id="adminPasswordPopup" class="modal-popup hidden">
        <h2 class="popup-title">Admin Access</h2>
        <p class="mb-4">Enter the password to access admin features.</p>
        <div class="input-group">
            <input type="password" id="adminPasswordInput" placeholder="Enter Password" class="w-full sm:w-2/3">
            <button id="submitAdminPasswordButton" class="button button-godmode mt-2 sm:mt-0 sm:ml-2">Submit</button>
        </div>
        <p id="adminPasswordError" class="text-red-400 text-sm mt-2 hidden">Invalid Password!</p>
        <button id="closeAdminPasswordPopup" class="button-close">&times;</button>
    </div>
    <!-- END NEW POPUP -->


    <div id="mainGameContent" class="hidden"> <div class="game-container p-1 sm:p-2">
            <h1 class="text-2xl sm:text-3xl font-bold mb-1 text-orange-400 game-title">ShootyShooty BangBang Plus</h1>

            <div class="ui-top-bar">
                <div id="healthDisplayContainer" class="hud-chip hud-chip--health">
                    <div class="hud-chip__label"><span class="hud-chip__icon">❤</span> Vitality</div>
                    <div class="hud-chip__stat">
                        <span id="healthText" class="hud-chip__value">100</span>
                        <span class="hud-chip__suffix">HP</span>
                    </div>
                    <div class="hud-chip__meter">
                        <div class="health-bar-container">
                            <div id="healthBarInner" class="health-bar-inner"></div>
                        </div>
                    </div>
                </div>
                <div id="scoreDisplay" class="text-xs sm:text-sm font-semibold score-display">Score: 0</div>
                <div class="flex items-center gap-1 sm:gap-2">
                    <span class="text-2xs sm:text-xs">Beam:</span>
                    <div class="charge-container">
                        <div id="beamChargeBar" class="charge-bar beam-charge-bar"></div>
                    </div>
                    <div class="hud-chip__note">Full charge = auto-aim beam</div>
                </div>
                <div class="hud-chip hud-chip--smash">
                    <div class="hud-chip__label"><span class="hud-chip__icon">✦</span> Smash Charge</div>
                    <div class="hud-chip__meter charge-container">
                        <div id="smashChargeBar" class="charge-bar smash-charge-bar"></div>
                    </div>
                    <div class="hud-chip__note">Unleash the fox smash</div>
                </div>
                <div class="hud-chip hud-chip--ammo">
                    <div class="hud-chip__label"><span class="hud-chip__icon">➳</span> Arsenal</div>
                    <div class="hud-chip__stat">
                        <span id="bulletCountDisplay" class="hud-chip__value">1</span>
                        <span class="hud-chip__suffix">Shots</span>
                    </div>
                    <div class="hud-chip__note">Power-up for more fire</div>
                </div>
            </div>

            <div id="stageDisplay" class="stage-info">Stage 1: Wave 1</div>
            <canvas id="gameCanvas"></canvas>

            <div class="command-dock">
                <div class="command-dock__header">
                    <span class="command-dock__title">Command Deck</span>
                    <span class="command-dock__subtitle">Experimental Controls</span>
                </div>
                <div class="extra-buttons-container">
                    <button id="aimbotButton" class="button button-secondary">Aimbot</button>
                    <button id="changelogButton" class="button button-secondary">Changelog</button>
                    <button id="invincibilityButton" class="button button-godmode">Invincibility</button>
                    <button id="plusHealthButton" class="button button-healthboost">+100 Health</button>
                    <button id="finishGameButton" class="button button-finish">Finish Game</button>
                </div>
            </div>

            <div id="messageBox" class="hud-flyout hidden">
                <div class="hud-flyout__header">
                    <span id="messageBadge" class="hud-flyout__badge">Mission Update</span>
                    <button id="closeMessageBoxButton" class="button-close">&times;</button>
                </div>
                <p id="messageText" class="hud-flyout__message"></p>
                <div id="codeInputSection" class="hidden input-group">
                    <input type="text" id="codeInput" placeholder="Enter Code">
                    <button id="submitCodeButton" class="button button-primary text-sm">Submit</button>
                    <button id="cancelCodeButton" class="button button-secondary text-sm">Cancel</button>
                </div>
                <div id="deathOptions" class="hidden hud-flyout__actions">
                    <button id="actionButton1" class="button button-primary">Play Again</button>
                    <button id="actionButton2" class="button button-secondary">Revive</button>
                </div>
                <div id="completionOptions" class="hidden mode-selection-buttons">
                    <button id="hellModeButton" class="button button-danger">Hell Mode</button>
                    <button id="endlessModeButton" class="button button-special">Endless Mode</button>
                </div>
                <div id="hellConfirmOptions" class="hidden mode-selection-buttons">
                    <button id="confirmHellButton" class="button button-danger">Yes, Unleash Hell!</button>
                    <button id="cancelHellButton" class="button button-secondary">Maybe Later</button>
                </div>
            </div>

            <div id="changelogPopup" class="modal-popup hidden">
                <h2 class="text-xl font-semibold mb-4 text-center text-amber-300 game-title-like">Changelog</h2>
                <div id="changelogContent">
                    <p>6.4: Added password protection to admin controls ('Invincibility', '+100 Health', 'Finish Game'). Admin access is now granted for the entire session after one successful login. Game version updated and title renamed to 'ShootyShooty BangBang Plus'.</p>
                    <p>6.2: fixed enemy health bar display. Added Green (+50HP) and Golden (+150HP) health power-ups cause duh. Enhanced particle effects for explosions and power-up collection. Screen shake on Smash & enemy death >:) </p>
                    <p>6.1: fixed GIP input issue with game control keys. beam attack now correctly uses sigma aimbot at the nearest enemy. refined bullet homing to prevent circling at close distance or whatever</p>
                    <p>6.0: fixed beam auto-aim. improved bullet homing to prevent circling at close range. enemy bullets no longer wrap.</p>
                    <p>5.9: fixed page scrolling. beam attack now auto-aims at nearest enemy. Added more background stars. Buttons now have an outline style. Fixed bullet homing issue circle. bullets now rebound instead of despawn for amore CHAOOSOSOSOSOSOSOSO</p>
                    <p>5.8: game title updated to "Shooty Shooty Bang Bang PLUS".resizing logic adjusted to make the game area larger because it kept.</p>
                    <p>5.7: changed 8-bit fonts to a smoother sans-serif font for a calmer feel and not like arcade pew pew pew pew</p>
                    <p>5.6: aimbot password changed.</p>
                    <p>5.5: player icon changed to a fox emoji cause old one looked like a fuckin box. particle logic adjusted for new shape.</p>
                    <p>5.4: added new power-ups: Rapid Fire, Shield, Speed Boost. power-up spawn timer no longer resets on wave/stage change. power-ups spawn every 10-20s.</p>
                    <p>5.3: ssssslightly increased bullet homing strength. Added more stars to the background for a cooler background hehe</p>
                    <p>5.2: added health bar. Added 'Finish Game' button. Adjusted Hell mode (slightly easier) & Normal mode (easier) difficulty. Changed main font to serif.</p>
                    <p>5.1: nerfed bullet homing strength. made Normal mode easier (enemy health/speed, wave length???)</p>
                    <p>5.0: created shooty shooty bang bang plus. more features, so beautiful and supports creator :D<p>
                    <p>4.9: moved Aimbot & Changelog buttons for better visibility below playing area field thingy Buttons are now larger.</p>
                    <p>4.8: fixed revive because it would freeze the game.</p>
                    <p>4.7: major major major major visual overhaul! dded animated backgrounds, particle effects, smoother animations, improved UI styling, and enhanced entity designs. player has a directional pointer. projectiles have cool trails</p>
                    <p>4.6: revamped enemy tracking and speed, upgraded AI and smarter enemies.</p>
                    <p>4.5: added endless and hell mode. polished everything and added to github</p>
                    <p>4.4: added changelog</p>
                    <p>4.3: fixed aimbot because it kept crashing the testing environment</p>
                    <p>4.2: added aimbot with secret code</p>
                    <p>4.1: rewrote the entire code cause it literally just wouldn't run</p>
                    <p>4.0: added revive feature with secret code</p>
                    <p>3.4: changed overall look to entities with more shapes and colors</p>
                    <p>3.3: bugfixes</p>
                    <p>3.2: added more friendly arrow movement</p>
                    <p>3.1: fixed mouse control mode</p>
                    <p>3.0: added mouse control mode</p>
                    <p>2.2: attempted background music, failed miserably</p>
                    <p>2.0: brand new UI with new colors and faces to enemies (AHH ITS SO GOOD)</p>
                    <p>1.4: bugfixing cause it broken</p>
                    <p>1.3: updated beam attack UI cause it looks like Microsoft paint</p>
                    <p>1.2: new attack mode: beam</p>
                    <p>1.1: new UI cause old one was hella ugly</p>
                    <p>1.0: initial release, what did you expect</p>
                </div>
                <button id="closeChangelogButton" class="button-close">&times;</button>
            </div>

            <div class="controls-info">
                <p class="font-semibold mb-0.5 text-lg text-purple-300 game-title-like">Controls:</p>
                <p><span class="text-orange-300">Player:</span> WASD to Move, Space/Click to Shoot, B for Beam, X for Smash, M for Mouse Aim</p>
                <p class="mt-0.5 text-xs text-gray-400">Beam: 21s, Smash: 37.5s. Targets hurt on touch!</p>
            </div>

            <div id="leaderboardContainer" class="hidden">
                <h2 class="text-lg font-semibold mb-2 text-amber-300 game-title-like">Local Leaderboard</h2>
                <ul id="leaderboardList"></ul>
                <p class="text-xs text-gray-500 mt-1">(Scores are saved in this browser only)</p>
            </div>
        </div>
    </div>


    <script>
    function normalizeAngle(angle) {
        while (angle > Math.PI) { angle -= 2 * Math.PI; }
        while (angle < -Math.PI) { angle += 2 * Math.PI; }
        return angle;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stageDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthText = document.getElementById('healthText');
        const healthBarInner = document.getElementById('healthBarInner');
        const tempPopup = document.getElementById('tempPopup');
        const aimbotButton = document.getElementById('aimbotButton');
        const changelogButton = document.getElementById('changelogButton');
        const invincibilityButton = document.getElementById('invincibilityButton');
        const plusHealthButton = document.getElementById('plusHealthButton');
        const finishGameButton = document.getElementById('finishGameButton');
        const changelogPopup = document.getElementById('changelogPopup');
        const closeChangelogButton = document.getElementById('closeChangelogButton');
        const closeMessageBoxButton = document.getElementById('closeMessageBoxButton');
        const bulletCountDisplay = document.getElementById('bulletCountDisplay');
        const versionDisplay = document.getElementById('versionDisplay');
        const themePanelToggle = document.getElementById('themePanelToggle');
        const themePanelContent = document.getElementById('themePanelContent');
        const themeSwatches = Array.from(document.querySelectorAll('.theme-swatch'));
        const themeAnimationSpeed = document.getElementById('themeAnimationSpeed');
        const themeGlowIntensity = document.getElementById('themeGlowIntensity');

        const licensePopup = document.getElementById('licensePopup');
        const licenseKeyInput = document.getElementById('licenseKeyInput');
        const submitLicenseKeyButton = document.getElementById('submitLicenseKeyButton');
        const licenseErrorText = document.getElementById('licenseErrorText');
        const namePopup = document.getElementById('namePopup');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitPlayerNameButton = document.getElementById('submitPlayerNameButton');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingWelcomeText = document.getElementById('loadingWelcomeText');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const mainGameContent = document.getElementById('mainGameContent');

        // NEW: Admin Popup Elements
        const adminPasswordPopup = document.getElementById('adminPasswordPopup');
        const adminPasswordInput = document.getElementById('adminPasswordInput');
        const submitAdminPasswordButton = document.getElementById('submitAdminPasswordButton');
        const closeAdminPasswordPopup = document.getElementById('closeAdminPasswordPopup');
        const adminPasswordError = document.getElementById('adminPasswordError');


        const GAME_VERSION = "v6.4";
        const AVAILABLE_THEMES = ['nebula', 'aurora', 'sunset', 'cyber'];
        const THEME_STORAGE_KEY = 'ssbb_theme_choice';
        const SPEED_STORAGE_KEY = 'ssbb_star_speed';
        const GLOW_STORAGE_KEY = 'ssbb_glow_strength';
        const rootElement = document.documentElement;

        function applyThemeChoice(themeName) {
            const targetTheme = AVAILABLE_THEMES.includes(themeName) ? themeName : 'nebula';
            AVAILABLE_THEMES.forEach(name => document.body.classList.remove(`theme-${name}`));
            document.body.classList.add(`theme-${targetTheme}`);
            themeSwatches.forEach(btn => btn.classList.toggle('theme-active', btn.dataset.theme === targetTheme));
            localStorage.setItem(THEME_STORAGE_KEY, targetTheme);
        }

        function applyStarSpeed(value) {
            const speed = Math.min(70, Math.max(15, Number(value) || 40));
            rootElement.style.setProperty('--star-speed', `${speed}s`);
            const auroraSpeed = Math.max(12, Math.round(speed * 0.65));
            rootElement.style.setProperty('--aurora-speed', `${auroraSpeed}s`);
            if (themeAnimationSpeed) { themeAnimationSpeed.value = speed; }
            localStorage.setItem(SPEED_STORAGE_KEY, String(speed));
        }

        function applyGlowStrength(value) {
            const glow = Math.min(90, Math.max(40, Number(value) || 65));
            const opacity = (glow / 100).toFixed(2);
            rootElement.style.setProperty('--aurora-opacity', opacity);
            if (themeGlowIntensity) { themeGlowIntensity.value = glow; }
            localStorage.setItem(GLOW_STORAGE_KEY, String(glow));
        }

        if (themePanelToggle && themePanelContent) {
            themePanelToggle.setAttribute('aria-expanded', 'false');
            themePanelToggle.addEventListener('click', () => {
                const isActive = themePanelContent.classList.toggle('active');
                themePanelToggle.setAttribute('aria-expanded', isActive ? 'true' : 'false');
            });

            document.addEventListener('click', (event) => {
                if (!themePanelContent.contains(event.target) && event.target !== themePanelToggle) {
                    if (themePanelContent.classList.contains('active')) {
                        themePanelContent.classList.remove('active');
                        themePanelToggle.setAttribute('aria-expanded', 'false');
                    }
                }
            });
        }

        themeSwatches.forEach(btn => {
            btn.addEventListener('click', () => {
                applyThemeChoice(btn.dataset.theme);
                if (themePanelContent && themePanelToggle) {
                    themePanelContent.classList.remove('active');
                    themePanelToggle.setAttribute('aria-expanded', 'false');
                }
            });
        });

        if (themeAnimationSpeed) {
            themeAnimationSpeed.addEventListener('input', (event) => {
                applyStarSpeed(event.target.value);
            });
        }

        if (themeGlowIntensity) {
            themeGlowIntensity.addEventListener('input', (event) => {
                applyGlowStrength(event.target.value);
            });
        }

        applyThemeChoice(localStorage.getItem(THEME_STORAGE_KEY) || 'nebula');
        applyStarSpeed(localStorage.getItem(SPEED_STORAGE_KEY) || themeAnimationSpeed?.value || 40);
        applyGlowStrength(localStorage.getItem(GLOW_STORAGE_KEY) || themeGlowIntensity?.value || 65);

        let CANVAS_WIDTH = 800;
        let CANVAS_HEIGHT = 600;
        const PLAYER_WIDTH = 30;
        const PLAYER_HEIGHT = 30;
        const PROJECTILE_WIDTH = 10;
        const PROJECTILE_HEIGHT = 5;
        const ENEMY_PROJECTILE_WIDTH = 8;
        const ENEMY_PROJECTILE_HEIGHT = 8;
        const POWERUP_SIZE = 25;
        const BEAM_THICKNESS = 25;
        const TARGET_SIZE_MIN = 20;
        const TARGET_SIZE_MAX = 35;
        const TARGET_BASE_SPEED = 0.25;
        const TARGET_SPEED_INCREMENT = 0.03;
        const TARGET_CONTACT_DAMAGE = 8;
        const SCORE_PER_HIT = 55;
        const SCORE_PER_BEAM_FRAME = 4;
        const SCORE_PER_SMASH_HIT = 30;
        const MAX_WAVES_PER_LEVEL = 3;
        const COMPLETION_STAGE = 10;
        const BEAM_CHARGE_MAX = 21000;
        const SMASH_CHARGE_MAX = 37500;
        const BEAM_ACTIVE_DURATION = 1800;
        const POWERUP_SPAWN_INTERVAL_MIN = 10000;
        const POWERUP_SPAWN_INTERVAL_MAX = 20000;
        const HEALTH_PACK_GREEN_SPAWN_MIN = 10000;
        const HEALTH_PACK_GREEN_SPAWN_MAX = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MIN = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MAX = 20000;
        const POWERUP_LIFETIME = 8000;
        const POWERUP_DURATION = 7000;
        const MAX_BULLET_COUNT = 5;
        const HELL_MODE_SPAWN_INTERVAL = 1200;
        const HELL_MODE_EXTRA_SPAWN_COUNT = 2;
        const REVIVE_INVULNERABILITY_DURATION = 3000;

        let gameRunning = false;
        let currentStage = 1;
        let currentWave = 1;
        let targetsPerWaveBase = 2;
        let gameTargets = [];
        let enemyProjectiles = [];
        let powerUps = [];
        let playerScore = 0;
        let mouseAimActive = false;
        let mouseX = 0;
        let mouseY = 0;
        let aimbotActive = false;
        const AIMBOT_SHOOT_DELAY = 35;
        let currentPopupAction = null;
        let gameMode = 'normal';
        let nextPowerUpSpawnTime = 0;
        let nextGreenHealthPackSpawnTime = 0;
        let nextGoldenHealthPackSpawnTime = 0;
        let nextHellSpawnTime = 0;
        let globalPlayerName = "Player";

        // NEW: Admin Password State
        let pendingAdminAction = null;
        const ADMIN_PASSWORD = "admin123"; // <-- YOU CAN CHANGE THE PASSWORD HERE
        let isAdminAccessGranted = false; // <-- NEW: Tracks if admin is unlocked

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBadge = document.getElementById('messageBadge');
        const codeInputSection = document.getElementById('codeInputSection');
        const codeInput = document.getElementById('codeInput');
        const submitCodeButton = document.getElementById('submitCodeButton');
        const cancelCodeButton = document.getElementById('cancelCodeButton');
        const deathOptions = document.getElementById('deathOptions');
        const completionOptions = document.getElementById('completionOptions');
        const hellModeButton = document.getElementById('hellModeButton');
        const endlessModeButton = document.getElementById('endlessModeButton');
        const hellConfirmOptions = document.getElementById('hellConfirmOptions');
        const confirmHellButton = document.getElementById('confirmHellButton');
        const cancelHellButton = document.getElementById('cancelHellButton');
        const actionButton1 = document.getElementById('actionButton1');
        const actionButton2 = document.getElementById('actionButton2');
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const leaderboardList = document.getElementById('leaderboardList');

        const FOX_TYPES = {
            "Ranger": {
                color: "hsl(25, 85%, 55%)",
                accentColor: "hsl(0, 0%, 95%)",
                eyeColor: "hsl(190, 100%, 30%)",
                shieldColor: "hsla(200, 100%, 80%, 0.3)",
                invulnerableShieldColor: "hsla(50, 100%, 70%, 0.7)",
                engineColor: "hsl(30, 100%, 50%)",
                baseSpeed: 3.8,
                health: 100,
                baseShootDelay: 220,
                projectileSpeed: 6.0,
                projectileColor: "hsl(50, 100%, 60%)"
            }
        };

        const keysPressed = {};
        versionDisplay.textContent = GAME_VERSION;

        function isGameEffectivelyPaused() {
            if (!mainGameContent.classList.contains('hidden')) {
                 // UPDATED: Added adminPasswordPopup
                 return messageBox.classList.contains('visible') ||
                        changelogPopup.classList.contains('visible') ||
                        adminPasswordPopup.classList.contains('visible');
            }
            return true;
        }

        let particles = [];
        function createParticle(x, y, count, color, sizeRange, speedRange, lifeRange, angleSpread = Math.PI * 2) {
            for (let i = 0; i < count; i++) {
                const targetY = typeof mouseY === 'number' ? mouseY : y;
                const targetX = typeof mouseX === 'number' ? mouseX : x + 1;
                const angle = (Math.random() - 0.5) * angleSpread + Math.atan2(targetY - y, targetX - x);
                const speed = Math.random() * (speedRange[1] - speedRange[0]) + speedRange[0];
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    size: Math.random() * (sizeRange[1] - sizeRange[0]) + sizeRange[0],
                    life: Math.random() * (lifeRange[1] - lifeRange[0]) + lifeRange[0], maxLife: lifeRange[1],
                    color: color, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.2,
                    shape: 'triangle'
                });
            }
        }

        function updateAndDrawParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * (deltaTime / 16.67); p.y += p.vy * (deltaTime / 16.67);
                p.vx *= 0.98; p.vy *= 0.98; p.life -= deltaTime; p.rotation += p.rotationSpeed * (deltaTime / 16.67);
                if (p.life <= 0) { particles.splice(i, 1); } else {
                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color; const opacity = Math.max(0, p.life / p.maxLife);
                    ctx.globalAlpha = opacity * 0.8;
                    if (p.shape === 'triangle') {
                        ctx.beginPath();
                        ctx.moveTo(0, -p.size / 2);
                        ctx.lineTo(p.size / 2, p.size / 2);
                        ctx.lineTo(-p.size / 2, p.size / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    }
                    ctx.restore();
                }
            }
            ctx.globalAlpha = 1;
        }

        window.addEventListener('keydown', (e) => {
            // UPDATED: Added adminPasswordInput
            const activePopupInput = document.activeElement === licenseKeyInput ||
                                     document.activeElement === playerNameInput ||
                                     (document.activeElement === codeInput && !codeInputSection.classList.contains('hidden')) ||
                                     document.activeElement === adminPasswordInput;

            if (activePopupInput) {
                if (e.code === 'Enter') {
                    e.preventDefault();
                    if (document.activeElement === licenseKeyInput) submitLicenseKeyButton.click();
                    else if (document.activeElement === playerNameInput) submitPlayerNameButton.click();
                    else if (document.activeElement === codeInput) submitCodeButton.click();
                    else if (document.activeElement === adminPasswordInput) submitAdminPasswordButton.click(); // NEW
                }
                return;
            }


            if (e.code === 'Escape') {
                if (changelogPopup.classList.contains('visible')) {
                    hidePopup(changelogPopup); currentPopupAction = null; return;
                }
                // NEW: Handle admin popup escape
                if (adminPasswordPopup.classList.contains('visible')) {
                    hidePopup(adminPasswordPopup);
                    currentPopupAction = null;
                    pendingAdminAction = null;
                    return;
                }
                if (messageBox.classList.contains('visible')) {
                    if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                        messageText.textContent = "Game Over!";
                        codeInputSection.classList.add('hidden');
                        deathOptions.classList.remove('hidden');
                        setMessageBadge('Critical Status');
                        currentPopupAction = 'game_over_options';
                        return;
                    } else if (['aimbot', 'hell_confirm', 'game_complete'].includes(currentPopupAction)) {
                         hidePopup(messageBox); currentPopupAction = null; return;
                    }
                }
            }

            if (isGameEffectivelyPaused() && !mainGameContent.classList.contains('hidden')) {
                 if (e.code === 'Space' || e.code.startsWith('Arrow') || ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyB', 'KeyX', 'KeyM'].includes(e.code)) {
                     e.preventDefault();
                 }
                 return;
            } else if (licensePopup.classList.contains('visible') || namePopup.classList.contains('visible') || loadingScreen.classList.contains('visible')) {
                if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyX', 'KeyM'].includes(e.code)) {
                    e.preventDefault();
                }
                return;
            }


            keysPressed[e.code] = true;
            if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) { e.preventDefault(); }
            if (e.code === 'KeyM') { toggleMouseAim(); }
            if (e.code === 'KeyX' && player1 && player1.smashReady && !player1.isSmashing) { player1.fireSmash(); }
        });
        window.addEventListener('keyup', (e) => { keysPressed[e.code] = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (isGameEffectivelyPaused()) return;
            const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('click', () => {
            if (isGameEffectivelyPaused()) return;
            if (mouseAimActive && !aimbotActive && player1 && player1.health > 0) { player1.shoot(true); }
        });

        const DEFAULT_MESSAGE_BADGE = 'Mission Update';

        function setMessageBadge(label = DEFAULT_MESSAGE_BADGE) {
            if (messageBadge) {
                messageBadge.textContent = label;
            }
        }

        function resetMessageBadge() {
            setMessageBadge(DEFAULT_MESSAGE_BADGE);
        }

        function showPopup(element) {
            element.classList.remove('hidden');
            setTimeout(() => element.classList.add('visible'), 10);
        }
        function hidePopup(element) {
            element.classList.remove('visible');
            setTimeout(() => {
                element.classList.add('hidden');
                if (element === messageBox) {
                    resetMessageBadge();
                }
            }, 600);
        }

        submitLicenseKeyButton.addEventListener('click', () => {
            if (licenseKeyInput.value.trim() === "64446644") {
                licenseErrorText.classList.add('hidden');
                licenseKeyInput.classList.remove('input-error');
                hidePopup(licensePopup);
                setTimeout(() => {
                    showPopup(namePopup);
                    playerNameInput.focus();
                }, 300);
            } else {
                licenseErrorText.classList.remove('hidden');
                licenseKeyInput.classList.add('input-error');
                setTimeout(() => licenseKeyInput.classList.remove('input-error'), 300);
                licenseKeyInput.value = "";
                licenseKeyInput.focus();
            }
        });

        submitPlayerNameButton.addEventListener('click', () => {
            globalPlayerName = playerNameInput.value.trim() || "Player";
            hidePopup(namePopup);
            setTimeout(() => {
                loadingWelcomeText.textContent = `Welcome to ShootyShooty BangBang Plus, ${globalPlayerName}! We're loading your game environment, please wait.`;
                showPopup(loadingScreen);
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 1;
                    loadingProgressBar.style.width = `${progress}%`;
                    if (progress >= 100) {
                        clearInterval(interval);
                        hidePopup(loadingScreen);
                        setTimeout(startGame, 300);
                    }
                }, 100); // Increased loading time slightly
            }, 300);
        });


        aimbotButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && currentPopupAction !== 'aimbot') return;
            if (aimbotActive) { aimbotActive = false; showTemporaryPopup("Aimbot Deactivated!"); return; }
            messageText.textContent = "Enter Admin Code:";
            codeInputSection.classList.remove('hidden'); deathOptions.classList.add('hidden');
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden');
            setMessageBadge('Admin Override');
            showPopup(messageBox); codeInput.value = ""; codeInput.focus(); currentPopupAction = 'aimbot';
        });

        actionButton2.addEventListener('click', () => {
            if (currentPopupAction === 'game_over_options') {
                messageText.textContent = "Enter Revive Code:";
                codeInputSection.classList.remove('hidden');
                deathOptions.classList.add('hidden');
                codeInput.value = "";
                codeInput.focus();
                setMessageBadge('Revive Protocol');
                currentPopupAction = 'revive_code_input';
            }
        });

        changelogButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && !changelogPopup.classList.contains('visible')) return;
            showPopup(changelogPopup); currentPopupAction = 'changelog';
        });

        // --- NEW ADMIN ACCESS LOGIC ---

        function requestAdminAccess(action) {
            // Don't show if another popup is already active
            if (isGameEffectivelyPaused() && !adminPasswordPopup.classList.contains('visible')) return;

            pendingAdminAction = action;
            adminPasswordInput.value = "";
            adminPasswordError.classList.add('hidden');
            adminPasswordInput.classList.remove('input-error');
            showPopup(adminPasswordPopup);
            adminPasswordInput.focus();
            currentPopupAction = 'admin_password'; // To help with pause logic
        }

        function executeAdminAction(action) {
            if (!player1 && (action === 'invincibility' || action === 'health')) return;

            switch (action) {
                case 'invincibility':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.isDivineProtectionActive = !player1.isDivineProtectionActive;
                        if (player1.isDivineProtectionActive) {
                            player1.health = 1000;
                            player1.initialHealth = 1000;
                            showTemporaryPopup("Divine Protection Activated!");
                        } else {
                            player1.health = Math.min(player1.health, player1.type.health);
                            player1.initialHealth = player1.type.health;
                            showTemporaryPopup("Divine Protection Deactivated!");
                        }
                        updateUI();
                    }
                    break;
                case 'health':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.health += 100;
                        if (player1.isDivineProtectionActive) {
                            player1.health = Math.min(player1.health, 1000);
                        } else {
                            player1.initialHealth = Math.max(player1.initialHealth, player1.health, player1.type.health);
                        }
                        updateUI();
                        showTemporaryPopup("+100 Health!");
                    }
                    break;
                case 'finish':
                     if (!isGameEffectivelyPaused()) {
                        showGameCompletionPopup();
                     }
                    break;
            }
        }

        // UPDATED: Re-wired admin buttons to new password prompt
        invincibilityButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('invincibility');
            } else {
                requestAdminAccess('invincibility');
            }
        });

        plusHealthButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('health');
            } else {
                requestAdminAccess('health');
            }
        });

        finishGameButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('finish');
            } else {
                requestAdminAccess('finish');
            }
        });

        // NEW: Event listeners for admin password popup
        closeAdminPasswordPopup.addEventListener('click', () => {
            hidePopup(adminPasswordPopup);
            pendingAdminAction = null;
            currentPopupAction = null;
        });

        submitAdminPasswordButton.addEventListener('click', () => {
            if (adminPasswordInput.value === ADMIN_PASSWORD) {
                isAdminAccessGranted = true; // <-- Grant access
                hidePopup(adminPasswordPopup);
                executeAdminAction(pendingAdminAction);
                pendingAdminAction = null;
                currentPopupAction = null;
                adminPasswordInput.value = "";
                adminPasswordError.classList.add('hidden');
                adminPasswordInput.classList.remove('input-error');
                showTemporaryPopup("Admin Access Granted!"); // Notify user
            } else {
                adminPasswordError.classList.remove('hidden');
                adminPasswordInput.classList.add('input-error');
                setTimeout(() => adminPasswordInput.classList.remove('input-error'), 300);
                adminPasswordInput.value = "";
                adminPasswordInput.focus();
            }
        });

        // --- END NEW ADMIN LOGIC ---


        hellModeButton.addEventListener('click', () => {
            messageText.textContent = "Warning: Hell Mode is for HIGHLY ADVANCED PLAYERS ONLY. Proceed?";
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.remove('hidden');
            setMessageBadge('Mode Select');
            showPopup(messageBox); currentPopupAction = 'hell_confirm';
        });

        endlessModeButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'endless';
            document.body.classList.remove('hell-mode'); document.body.classList.add('endless-mode');
            showTemporaryPopup("Thanks for playing! Enjoy Endless Mode!");
            player1.reset(true); initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        confirmHellButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'hell';
            document.body.classList.remove('endless-mode'); document.body.classList.add('hell-mode');
            stageDisplay.textContent = "HELL MODE ENABLED";
            player1.reset(true); player1.health = 200; player1.initialHealth = 200;
            targetsPerWaveBase = 3;
            initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        cancelHellButton.addEventListener('click', () => {
            messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            setMessageBadge('Mission Complete');
            currentPopupAction = 'game_complete';
        });

        closeChangelogButton.addEventListener('click', () => { hidePopup(changelogPopup); currentPopupAction = null; });
        closeMessageBoxButton.addEventListener('click', () => {
            hidePopup(messageBox);
            if (currentPopupAction === 'game_over_options' || currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                 leaderboardContainer.classList.add('hidden');
            }
            currentPopupAction = null;
        });

        submitCodeButton.addEventListener('click', () => {
            const code = codeInput.value.trim().toLowerCase();
            if (currentPopupAction === 'aimbot') {
                if (code === "ultrasecretpassword") {
                    aimbotActive = true;
                    showTemporaryPopup("Aimbot Enabled!");
                } else {
                    showTemporaryPopup("Incorrect Code.");
                }
                hidePopup(messageBox); currentPopupAction = null;
            } else if (currentPopupAction === 'revive_code_input') {
                if (code === "nugget") {
                    player1.reset(false);
                    player1.health = player1.isDivineProtectionActive ? 1000 : player1.initialHealth;
                    player1.isInvulnerable = true; player1.invulnerableUntil = Date.now() + REVIVE_INVULNERABILITY_DURATION;
                    gameRunning = true; lastFrameTime = performance.now();
                    hidePopup(messageBox); leaderboardContainer.classList.add('hidden');
                    requestAnimationFrame(gameLoop); currentPopupAction = null;
                } else {
                    messageText.textContent = "Incorrect Code. Try Respawn?";
                    codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                    setMessageBadge('Access Denied');
                    currentPopupAction = 'revive_failed';
                }
            }
            codeInput.value = "";
        });

        cancelCodeButton.addEventListener('click', () => {
            if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                messageText.textContent = "Game Over!";
                codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                setMessageBadge('Critical Status');
                currentPopupAction = 'game_over_options';
            } else {
                hidePopup(messageBox); currentPopupAction = null;
            }
        });

        function showTemporaryPopup(message) {
            tempPopup.textContent = message;
            showPopup(tempPopup);
            setTimeout(() => {
                hidePopup(tempPopup);
            }, 2500);
        };
        function toggleMouseAim() {
            if (isGameEffectivelyPaused()) return;
            mouseAimActive = !mouseAimActive; showTemporaryPopup(mouseAimActive ? "Mouse Aim Activated!" : "Mouse Aim Deactivated!");
            canvas.style.cursor = mouseAimActive ? 'crosshair' : 'default';
            if (mouseAimActive && aimbotActive) { showTemporaryPopup("Aimbot is active, mouse aim will be overridden by Aimbot targeting."); }
        };

        const POWERUP_TYPES = {
            MULTI_SHOT: 'multiShot',
            RAPID_FIRE: 'rapidFire',
            SHIELD: 'shield',
            SPEED_BOOST: 'speedBoost',
            HEALTH_PACK_GREEN: 'healthPackGreen',
            HEALTH_PACK_GOLDEN: 'healthPackGolden'
        };

        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.size = POWERUP_SIZE;
                this.createdAt = Date.now(); this.lifetime = POWERUP_LIFETIME;
                this.pulseSpeed = 0.05; this.currentPulse = 0;

                switch (this.type) {
                    case POWERUP_TYPES.MULTI_SHOT: this.baseColor = 'rgb(34, 197, 94)'; this.pulseColor = 'rgb(134, 239, 172)'; this.symbol = '•••'; break;
                    case POWERUP_TYPES.RAPID_FIRE: this.baseColor = 'rgb(251, 146, 60)'; this.pulseColor = 'rgb(253, 186, 116)'; this.symbol = '►►►'; break;
                    case POWERUP_TYPES.SHIELD: this.baseColor = 'rgb(59, 130, 246)'; this.pulseColor = 'rgb(147, 197, 253)'; this.symbol = '🛡️'; break;
                    case POWERUP_TYPES.SPEED_BOOST: this.baseColor = 'rgb(168, 85, 247)'; this.pulseColor = 'rgb(216, 180, 254)'; this.symbol = '⚡'; break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN: this.baseColor = 'hsl(120, 60%, 50%)'; this.pulseColor = 'hsl(120, 60%, 70%)'; this.symbol = '➕'; break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN: this.baseColor = 'hsl(50, 100%, 50%)'; this.pulseColor = 'hsl(50, 100%, 70%)'; this.symbol = '💛'; break;
                    default: this.baseColor = 'grey'; this.pulseColor = 'lightgrey'; this.symbol = '?';
                }
            }
            draw() {
                this.currentPulse = (this.currentPulse + this.pulseSpeed) % (Math.PI * 2);
                const scaleFactor = 1 + Math.sin(this.currentPulse) * 0.1;
                const currentSize = this.size * scaleFactor;
                ctx.fillStyle = this.pulseColor;
                ctx.globalAlpha = 0.5 * (1 + Math.sin(this.currentPulse) * 0.5);
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 1.8, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = this.baseColor;
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 2.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${currentSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x + this.size / 2, this.y + this.size / 2);
            }
            update(deltaTime) { return Date.now() - this.createdAt > this.lifetime; }
        }

        class Target {
            constructor(x, y, type) {
                this.type = type; this.size = Math.random() * (TARGET_SIZE_MAX - TARGET_SIZE_MIN) + TARGET_SIZE_MIN;
                this.x = x; this.y = y; this.width = this.size; this.height = this.size;
                let speedMultiplier = 1.0 + (Math.random() - 0.5) * 0.3;
                let healthMultiplier = 1.0;
                let projectileSpeedMultiplier = 1.0;
                let shootCooldownFactor = 1.0;

                if (gameMode === 'hell') {
                    speedMultiplier *= 3.4; healthMultiplier = 2.2; projectileSpeedMultiplier = 1.15; shootCooldownFactor = 0.65;
                } else if (gameMode === 'endless') {
                    speedMultiplier *= 1.25; healthMultiplier = 1.2;
                } else {
                    speedMultiplier *= 0.8; healthMultiplier = 0.7;
                }

                this.speed = (TARGET_BASE_SPEED + (currentWave-1) * TARGET_SPEED_INCREMENT + (currentStage-1) * TARGET_SPEED_INCREMENT * 2) * speedMultiplier;
                this.projectileColor = "rgb(220, 100, 100)";
                this.projectileDamage = (gameMode === 'hell') ? 15 : 10;
                this.repulsionForce = 0.65; this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;

                switch(type) {
                    case 'purple':
                        this.color = "hsl(280, 70%, 60%)"; this.faceColor = "hsl(280, 70%, 40%)";
                        this.health = (40 + currentWave * 5 + currentStage * 10) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 450 : (gameMode === 'endless' ? 1500 : 1800)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 2.8 * projectileSpeedMultiplier;
                        break;
                    case 'orange':
                        this.color = "hsl(30, 80%, 60%)"; this.faceColor = "hsl(30, 80%, 40%)";
                        this.health = (30 + currentWave * 4 + currentStage * 8) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 300 : (gameMode === 'endless' ? 750 : 900)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 3.2 * projectileSpeedMultiplier;
                        break;
                    case 'green':
                        this.color = "hsl(140, 70%, 50%)"; this.faceColor = "hsl(140, 70%, 30%)";
                        this.health = (50 + currentWave * 7 + currentStage * 12) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 1.7 : 1.5);
                        this.canShoot = false;
                        break;
                    case 'blue':
                        this.color = "hsl(210, 70%, 60%)"; this.faceColor = "hsl(210, 70%, 40%)";
                        this.health = (20 + currentWave * 3 + currentStage * 5) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 0.6 : 0.55);
                        this.canShoot = false;
                        break;
                    default:
                        this.color = "hsl(0, 0%, 50%)"; this.faceColor = "hsl(0, 0%, 30%)";
                        this.health = (25 + currentWave * 4 + currentStage * 4) * healthMultiplier;
                        this.canShoot = false;
                }
                this.initialHealth = this.health; this.lastShotTime = 0;
                this.hitFlashDuration = 100; this.lastHitTime = 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                let drawColor = this.color; if (Date.now() - this.lastHitTime < this.hitFlashDuration) { drawColor = "white"; }
                ctx.fillStyle = drawColor; ctx.beginPath();
                if (this.type === 'purple') { const s = this.width / 2; ctx.moveTo(-s, -s); ctx.lineTo(s, -s); ctx.lineTo(s*0.8, -s*0.2); ctx.lineTo(s, s); ctx.lineTo(-s, s); ctx.lineTo(-s*0.8, s*0.2); ctx.closePath();
                } else if (this.type === 'orange') { for (let i = 0; i < 5; i++) { ctx.lineTo( (this.width / 2) * Math.cos( (Math.PI*2/5) * i - Math.PI/2 ), (this.height / 2) * Math.sin( (Math.PI*2/5) * i - Math.PI/2 )); } ctx.closePath();
                } else if (this.type === 'green') { ctx.moveTo(0, -this.height / 2); ctx.lineTo(this.width / 2, this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.closePath();
                } else { const r = this.width / 5; ctx.moveTo(-this.width/2 + r, -this.height/2); ctx.arcTo(this.width/2, -this.height/2, this.width/2, this.height/2, r); ctx.arcTo(this.width/2, this.height/2, -this.width/2, this.height/2, r); ctx.arcTo(-this.width/2, this.height/2, -this.width/2, -this.height/2, r); ctx.arcTo(-this.width/2, -this.height/2, this.width/2, -this.height/2, r); ctx.closePath(); }
                ctx.fill();
                ctx.fillStyle = this.faceColor; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)"; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 12, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                if (this.health > 0) {
                    const hBW = this.width * 0.8;
                    const hBH = 4;
                    const healthPercentage = (this.health / this.initialHealth) * 100;
                    const hP = Math.max(0, Math.min(1, this.health / this.initialHealth));

                    const barX = this.x + this.width * 0.1;
                    const barY = this.y - hBH - 3;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, hBW, hBH);

                    let healthBarColor = 'hsl(0, 70%, 50%)';
                    if (healthPercentage > 60) {
                        healthBarColor = 'hsl(120, 70%, 50%)';
                    } else if (healthPercentage > 25) {
                        healthBarColor = 'hsl(60, 70%, 50%)';
                    }
                    ctx.fillStyle = healthBarColor;
                    ctx.fillRect(barX, barY, hBW * hP, hBH);

                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(barX, barY, hBW, hBH);
                }
            }
            update(playerX, playerY, deltaTime, otherTargets) {
                const dtFactor = deltaTime / (1000/60); this.rotation += this.rotationSpeed * dtFactor;
                const dxToPlayer = playerX + PLAYER_WIDTH/2-(this.x+this.width/2); const dyToPlayer = playerY + PLAYER_HEIGHT/2-(this.y+this.height/2);
                const distToPlayer = Math.sqrt(dxToPlayer*dxToPlayer + dyToPlayer*dyToPlayer);
                let moveX = 0; let moveY = 0; if (distToPlayer > 0) { moveX += (dxToPlayer/distToPlayer)*this.speed; moveY += (dyToPlayer/distToPlayer)*this.speed; }
                let repelX = 0; let repelY = 0;
                otherTargets.forEach(other => {
                    if (other === this) return; const dx = this.x - other.x; const dy = this.y - other.y;
                    const distSq = dx*dx + dy*dy; const minDist = (this.size + other.size) * 0.6;
                    if (distSq < minDist*minDist && distSq > 0) { const dist = Math.sqrt(distSq); const force = this.repulsionForce * (1 - dist/minDist); repelX += (dx/dist)*force; repelY += (dy/dist)*force; }
                });
                this.x += (moveX + repelX) * dtFactor; this.y += (moveY + repelY) * dtFactor;
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width)); this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                if (this.canShoot && Date.now() - this.lastShotTime > this.shootCooldown) {
                    this.lastShotTime = Date.now(); const aimDx = playerX+PLAYER_WIDTH/2-(this.x+this.width/2); const aimDy = playerY+PLAYER_HEIGHT/2-(this.y+this.height/2);
                    const aimDist = Math.sqrt(aimDx*aimDx + aimDy*aimDy); let sX=0,sY=0;
                    if(aimDist>0){sX=(aimDx/aimDist)*this.enemyProjectileSpeed;sY=(aimDy/aimDist)*this.enemyProjectileSpeed;}
                    enemyProjectiles.push(new EnemyProjectile(this.x+this.width/2, this.y+this.height/2, sX, sY, this.projectileColor, this.projectileDamage));
                }
            }
            takeDamage(amount) { this.health -= amount; this.lastHitTime = Date.now(); createParticle(this.x+this.width/2, this.y+this.height/2, 3, 'rgba(255,255,255,0.8)', [2,5], [1,3], [100,300]); if (this.health < 0) {this.health = 0;} }
        }

        class EnemyProjectile {
            constructor(x,y,sX,sY,c, damage = 10){
                this.x=x-ENEMY_PROJECTILE_WIDTH/2;this.y=y-ENEMY_PROJECTILE_HEIGHT/2; this.width=ENEMY_PROJECTILE_WIDTH;this.height=ENEMY_PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c; this.damage = damage;
                this.trail = []; this.maxTrailLength = (gameMode === 'hell') ? 8 : 5; this.rotation = Math.random() * Math.PI * 2;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.3 * (i / this.trail.length); ctx.fillStyle = `hsla(0, 100%, 70%, ${alpha})`; ctx.beginPath(); ctx.arc(point.x + this.width / 2, point.y + this.height / 2, this.width / 2.5 * (i / this.trail.length), 0, Math.PI * 2); ctx.fill(); }
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                ctx.fillStyle = "rgba(255, 50, 50, 0.5)"; ctx.beginPath(); ctx.arc(0, 0, this.width / 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,this.width/2.2,0,Math.PI*2); ctx.fill();
                ctx.restore();
            }
            update(deltaTime){
                const dtFactor=deltaTime/(1000/60);
                this.x+=this.speedX*dtFactor; this.y+=this.speedY*dtFactor;
                this.rotation += 0.1 * dtFactor;

                if (this.x > CANVAS_WIDTH + this.width * 2 || this.x < -this.width * 2 || this.y > CANVAS_HEIGHT + this.height * 2 || this.y < -this.height * 2) {
                    const index = enemyProjectiles.indexOf(this);
                    if (index > -1) {
                        enemyProjectiles.splice(index, 1);
                    }
                }

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }
            }
        }

        class FoxPlayer {
            constructor(x, y, foxTypeName, controls) {
                this.type = FOX_TYPES[foxTypeName]; this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT;
                this.color = this.type.color;
                this.speed = this.type.baseSpeed;
                this.shootDelayBase = this.type.baseShootDelay;
                this.health = (gameMode === 'hell') ? 200 : this.type.health; this.initialHealth = this.health;
                this.controls = controls; this.projectiles = []; this.lastShotTime = 0;
                this.beamCharge = 0; this.beamChargeMax = BEAM_CHARGE_MAX; this.beamReady = false;
                this.isFiringBeam = false; this.beamActiveDuration = BEAM_ACTIVE_DURATION; this.beamActiveStartTime = 0;
                this.beamDamagePerFrame = 2.5; this.smashCharge = 0; this.smashChargeMax = SMASH_CHARGE_MAX; this.smashReady = false;
                this.isSmashing = false; this.smashRadius = 0; this.smashMaxRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
                this.smashExpansionSpeed = this.smashMaxRadius / 50; this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0;
                this.beamTargetAngle = 0;
                this.aimbotTarget = null; this.bulletCount = 1; this.engineParticles = [];
                this.engineParticleTimer = 0; this.engineParticleInterval = 50; this.currentSpeed = 0;
                this.shieldOpacity = 0; this.lastDamageTime = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.isDivineProtectionActive = false;
                this.rapidFireActiveUntil = 0;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.aimAngle);

                this.engineParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.beginPath();
                    const localX = p.x - (this.x + this.width / 2);
                    const localY = p.y - (this.y + this.height / 2);
                    ctx.arc(localX, localY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                ctx.font = `${this.height * 0.95}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('🦊', 0, 0);


                const shieldPath = () => {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.7, 0, Math.PI * 2);
                    ctx.closePath();
                };

                let currentShieldColor = this.type.shieldColor;
                let shieldActive = false;

                if (this.isInvulnerable) {
                    currentShieldColor = this.type.invulnerableShieldColor;
                    shieldActive = true;
                } else if (Date.now() < this.shieldActiveUntil) {
                    currentShieldColor = "hsla(180, 100%, 70%, 0.7)";
                    shieldActive = true;
                } else if (this.isDivineProtectionActive) {
                     currentShieldColor = "hsla(270, 100%, 70%, 0.7)";
                     shieldActive = true;
                } else if (this.shieldOpacity > 0) {
                    shieldActive = true;
                }

                if (shieldActive) {
                    ctx.strokeStyle = currentShieldColor;
                    ctx.lineWidth = (this.isInvulnerable || Date.now() < this.shieldActiveUntil || this.isDivineProtectionActive) ? 4 : 3;
                    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 80) * 0.4;
                    shieldPath();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();

                if (aimbotActive && this.aimbotTarget) { ctx.strokeStyle = "rgba(255,0,0,0.6)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x+this.width/2,this.y+this.height/2); ctx.lineTo(this.aimbotTarget.x+this.aimbotTarget.width/2,this.aimbotTarget.y+this.aimbotTarget.height/2); ctx.stroke(); }
                if (this.isFiringBeam) {
                    ctx.save(); ctx.translate(this.x+this.width/2,this.y+this.height/2);
                    ctx.rotate(this.beamTargetAngle);
                    const beamLength = CANVAS_WIDTH*1.5;
                    let gradBeam = ctx.createLinearGradient(0,0,beamLength,0); gradBeam.addColorStop(0,"rgba(255,255,220,1)"); gradBeam.addColorStop(0.1,"rgba(255,255,180,0.9)"); gradBeam.addColorStop(1,"rgba(255,200,100,0)");
                    ctx.fillStyle = gradBeam; ctx.fillRect(this.width/2, -BEAM_THICKNESS/4, beamLength, BEAM_THICKNESS/2);
                    let gradGlow = ctx.createLinearGradient(0,0,beamLength,0); gradGlow.addColorStop(0,"rgba(255,220,150,0.6)"); gradGlow.addColorStop(0.2,"rgba(255,200,100,0.4)"); gradGlow.addColorStop(1,"rgba(255,180,50,0)");
                    ctx.fillStyle = gradGlow; ctx.fillRect(this.width/2, -BEAM_THICKNESS/2, beamLength, BEAM_THICKNESS);
                    ctx.restore();
                }
                if (this.isSmashing) {
                    ctx.beginPath(); const smashProgress = this.smashRadius/this.smashMaxRadius;
                    ctx.strokeStyle = `rgba(255,100,50,${0.8-smashProgress*0.7})`; ctx.lineWidth = 10+15*(1-smashProgress); ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius,0,Math.PI*2); ctx.stroke();
                    ctx.fillStyle = `rgba(255,150,80,${0.5-smashProgress*0.4})`; ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius*0.8,0,Math.PI*2); ctx.fill();
                }
            }

            updateChargeIndicators() {
                const beamBar = document.getElementById('beamChargeBar'); if (beamBar) { const bCP = this.beamCharge/this.beamChargeMax; beamBar.style.width = `${Math.min(100,bCP*100)}%`; beamBar.classList.toggle('ready',this.beamReady); }
                const smashBar = document.getElementById('smashChargeBar'); if (smashBar) { const sCP = this.smashCharge/this.smashChargeMax; smashBar.style.width = `${Math.min(100,sCP*100)}%`; smashBar.classList.toggle('ready',this.smashReady); }
            }

            updateAimDirection() {
                this.aimbotTarget = null;
                if (aimbotActive) {
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => { const dx = target.x+target.width/2-(this.x+this.width/2); const dy = target.y+target.height/2-(this.y+this.height/2); const distSq = dx*dx+dy*dy; if (distSq < minDistanceSq) { minDistanceSq = distSq; closestTarget = target; }});
                    if (closestTarget) { const dx = closestTarget.x+closestTarget.width/2-(this.x+this.width/2); const dy = closestTarget.y+closestTarget.height/2-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx); this.aimbotTarget = closestTarget; }
                } else if (mouseAimActive) {
                    const dx = mouseX-(this.x+this.width/2); const dy = mouseY-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx);
                } else {
                    let keyAimDx = 0; let keyAimDy = 0;
                    if (keysPressed['ArrowLeft']) { keyAimDx = -1; } else if (keysPressed['ArrowRight']) { keyAimDx = 1;}
                    if (keysPressed['ArrowUp']) { keyAimDy = -1; } else if (keysPressed['ArrowDown']) { keyAimDy = 1;}
                    if (keyAimDx !== 0 || keyAimDy !== 0) { this.aimAngle = Math.atan2(keyAimDy, keyAimDx); }
                    else { if (this.lastMoveDx !== 0 || this.lastMoveDy !== 0) { this.aimAngle = Math.atan2(this.lastMoveDy, this.lastMoveDx); } }
                }
            }

            move(deltaTime) {
                let moveDx=0; let moveDy=0;
                if(keysPressed[this.controls.left]){moveDx-=1;} if(keysPressed[this.controls.right]){moveDx+=1;}
                if(keysPressed[this.controls.up]){moveDy-=1;} if(keysPressed[this.controls.down]){moveDy+=1;}
                const targetSpeed = (moveDx!==0||moveDy!==0)?this.speed:0; const acceleration=0.15; this.currentSpeed+=(targetSpeed-this.currentSpeed)*acceleration;
                const effectiveSpeed = this.currentSpeed*(deltaTime/(1000/60));
                if(moveDx!==0||moveDy!==0){ const dist=Math.sqrt(moveDx*moveDx+moveDy*moveDy); const nDx=moveDx/dist; const nDy=moveDy/dist; this.x+=nDx*effectiveSpeed; this.y+=nDy*effectiveSpeed; this.lastMoveDx=nDx; this.lastMoveDy=nDy; }
                this.x=Math.max(0,Math.min(this.x,CANVAS_WIDTH-this.width)); this.y=Math.max(0,Math.min(this.y,CANVAS_HEIGHT-this.height));
                this.engineParticleTimer+=deltaTime;
                if(this.engineParticleTimer>this.engineParticleInterval && this.currentSpeed > this.speed*0.2){
                    this.engineParticleTimer=0; const particleCount=Math.floor(this.currentSpeed/this.speed*2)+1;
                    for(let i=0;i<particleCount;i++){
                        const angleOffset=(Math.random()-0.5)*0.5;
                        const particleStartX = (this.x + this.width/2) - Math.cos(this.aimAngle) * (this.width * 0.4);
                        const particleStartY = (this.y + this.height/2) - Math.sin(this.aimAngle) * (this.height * 0.4);
                        const particleAngle=this.aimAngle+Math.PI+angleOffset;
                        const speed=(Math.random()*1+1)*(this.currentSpeed/this.speed);
                        this.engineParticles.push({ x:particleStartX, y:particleStartY, vx:Math.cos(particleAngle)*speed, vy:Math.sin(particleAngle)*speed, size:Math.random()*2+1, life:Math.random()*200+100, maxLife:300, color:`hsla(${20+Math.random()*30},100%,${60+Math.random()*20}%,${0.5+Math.random()*0.5})`, opacity:1 });
                    }
                }
                for(let i=this.engineParticles.length-1;i>=0;i--){ const p=this.engineParticles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=deltaTime; p.opacity=p.life/p.maxLife; if(p.life<=0)this.engineParticles.splice(i,1); }
            }

            shoot(triggeredByClick = false) {
                const currentTime = Date.now();
                const currentShootDelay = (Date.now() < this.rapidFireActiveUntil) ? this.shootDelayBase / 2 : this.shootDelayBase;
                const actualShootDelay = aimbotActive ? AIMBOT_SHOOT_DELAY : currentShootDelay;

                let attemptShot = false;
                if (aimbotActive) { attemptShot = true; }
                else if (mouseAimActive && triggeredByClick) { attemptShot = true; }
                else if (!mouseAimActive && keysPressed[this.controls.shoot]) { attemptShot = true; }

                if (attemptShot && (currentTime - this.lastShotTime > actualShootDelay)) {
                    this.lastShotTime = currentTime;
                    const numBullets = this.bulletCount;
                    const spreadAngle = numBullets > 1 ? Math.PI / 24 : 0;

                    const muzzleOffsetX = Math.cos(this.aimAngle) * (this.width * 0.5);
                    const muzzleOffsetY = Math.sin(this.aimAngle) * (this.height * 0.5);
                    createParticle( this.x+this.width/2 + muzzleOffsetX, this.y+this.height/2 + muzzleOffsetY, 5, `rgba(255,223,186,${0.5+Math.random()*0.5})`,[3,7],[2,4],[50,150],Math.PI/4 );

                    let nearestEnemyForHoming = null;
                    if (!mouseAimActive && !aimbotActive && gameTargets.length > 0) {
                        let minDistanceSq = Infinity;
                        const playerCenterX = this.x + this.width / 2;
                        const playerCenterY = this.y + this.height / 2;
                        gameTargets.forEach(target => {
                            const dx = (target.x + target.width / 2) - playerCenterX;
                            const dy = (target.y + target.height / 2) - playerCenterY;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < minDistanceSq) { minDistanceSq = distSq; nearestEnemyForHoming = target; }
                        });
                    }

                    for (let i = 0; i < numBullets; i++) {
                        const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle;
                        const currentAngle = this.aimAngle + angleOffset;
                        const cosA = Math.cos(currentAngle); const sinA = Math.sin(currentAngle);
                        const startX = this.x + this.width/2 + cosA * (this.width * 0.5);
                        const startY = this.y + this.height/2 + sinA * (this.height * 0.5);
                        this.projectiles.push(new Projectile( startX, startY, cosA*this.type.projectileSpeed, sinA*this.type.projectileSpeed, this.type.projectileColor, nearestEnemyForHoming ));
                    }
                }
            }
            fireBeam() {
                if (this.beamReady && !this.isFiringBeam) {
                    this.isFiringBeam = true; this.beamActiveStartTime = Date.now(); this.beamReady = false; this.beamCharge = 0;
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => {
                        const dx = target.x + target.width/2 - (this.x + this.width/2);
                        const dy = target.y + target.height/2 - (this.y + this.height/2);
                        const distSq = dx*dx + dy*dy;
                        if (distSq < minDistanceSq) {
                            minDistanceSq = distSq;
                            closestTarget = target;
                        }
                    });
                    if (closestTarget) {
                        const dx = closestTarget.x + closestTarget.width/2 - (this.x + this.width/2);
                        const dy = closestTarget.y + closestTarget.height/2 - (this.y + this.height/2);
                        this.beamTargetAngle = Math.atan2(dy, dx);
                    } else {
                        this.beamTargetAngle = this.aimAngle;
                    }
                    createParticle(this.x+this.width/2,this.y+this.height/2,20,'rgba(255,255,100,0.7)',[4,10],[3,6],[300,600],Math.PI*2);
                }
            }
            fireSmash() {
                if (this.smashReady && !this.isSmashing) {
                    this.smashReady = false; this.smashCharge = 0; this.isSmashing = true; this.smashRadius = 0;
                    createParticle(this.x+this.width/2,this.y+this.height/2,30,'rgba(255,100,50,0.7)',[5,15],[4,8],[400,800],Math.PI*2);
                }
            }

            update(deltaTime) {
                if (this.health <= 0) { return; }

                if (this.isInvulnerable && Date.now() >= this.invulnerableUntil) { this.isInvulnerable = false; }
                if (Date.now() >= this.rapidFireActiveUntil && this.shootDelayBase !== this.type.baseShootDelay) {
                    this.shootDelayBase = this.type.baseShootDelay;
                    showTemporaryPopup("Rapid Fire Worn Off!");
                }
                if (Date.now() >= this.shieldActiveUntil && this.shieldOpacity > 0 && !this.isInvulnerable) {
                }
                if (Date.now() >= this.speedBoostActiveUntil && this.speed !== this.type.baseSpeed) {
                    this.speed = this.type.baseSpeed;
                    showTemporaryPopup("Speed Boost Worn Off!");
                }


                if (this.isDivineProtectionActive && this.health < 20 && this.health > 0) {
                    this.health = 1000;
                    updateUI();
                }

                this.updateAimDirection(); this.move(deltaTime); this.shoot();
                if (!this.beamReady && !this.isFiringBeam) { this.beamCharge += deltaTime; if (this.beamCharge >= this.beamChargeMax) { this.beamCharge = this.beamChargeMax; this.beamReady = true;} }
                if (!this.smashReady && !this.isSmashing) { this.smashCharge += deltaTime; if (this.smashCharge >= this.smashChargeMax) { this.smashCharge = this.smashChargeMax; this.smashReady = true;}}
                if (keysPressed[this.controls.beam]) { this.fireBeam(); }
                if (this.isFiringBeam && (Date.now() - this.beamActiveStartTime >= this.beamActiveDuration)) { this.isFiringBeam = false; }
                if (this.isSmashing) {
                    this.smashRadius += this.smashExpansionSpeed * (deltaTime/(1000/60));
                    for (let i = gameTargets.length-1; i >= 0; i--) { const target = gameTargets[i]; const distSq = Math.pow(target.x+target.width/2-(this.x+this.width/2),2)+Math.pow(target.y+target.height/2-(this.y+this.height/2),2); if (distSq <= Math.pow(this.smashRadius,2)) { target.takeDamage(1000); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(i,1); playerScore += SCORE_PER_SMASH_HIT; }}}
                    if (this.smashRadius >= this.smashMaxRadius) { this.isSmashing = false; this.smashRadius = 0; showTemporaryPopup("SMASHED!"); }
                }
                this.projectiles.forEach((p, index) => { p.update(deltaTime); });

                if (!this.isInvulnerable && !(Date.now() < this.shieldActiveUntil) && !this.isDivineProtectionActive && this.shieldOpacity > 0) {
                    this.shieldOpacity -= 0.02 * (deltaTime / 16.67); if (this.shieldOpacity < 0) this.shieldOpacity = 0;
                }
            }
            reset(fullReset = true) {
                this.health = (this.isDivineProtectionActive && !fullReset) ? 1000 : (gameMode === 'hell' ? 200 : FOX_TYPES["Ranger"].health);
                this.initialHealth = this.health;
                this.projectiles = []; this.x = 50; this.y = CANVAS_HEIGHT/2 - this.height/2;
                this.beamCharge = 0; this.beamReady = false; this.isFiringBeam = false; this.smashCharge = 0; this.smashReady = false; this.isSmashing = false; this.smashRadius = 0;
                this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0; this.beamTargetAngle = 0; this.aimbotTarget = null;
                this.bulletCount = 1; this.engineParticles = []; this.currentSpeed = 0; this.shieldOpacity = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.rapidFireActiveUntil = 0; this.shootDelayBase = this.type.baseShootDelay;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0; this.speed = this.type.baseSpeed;
                if (fullReset) {
                    this.isDivineProtectionActive = false;
                    playerScore = 0;
                }
            }
            takeDamage(amount) {
                if (this.isInvulnerable || Date.now() < this.shieldActiveUntil) return;

                if (this.isDivineProtectionActive) {
                    if (this.health > 20) {
                        this.health -= amount;
                        if (this.health < 20) this.health = 20;
                    }
                    this.lastDamageTime = Date.now();
                    this.shieldOpacity = 1;
                    createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                    if (this.health < 0) this.health = 0;
                    return;
                }

                if (Date.now() - this.lastDamageTime < 200) return;
                this.health -= amount; this.lastDamageTime = Date.now(); this.shieldOpacity = 1;
                createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                if (this.health < 0) {this.health = 0;}
            }
            collectPowerUp(powerUpType) {
                createParticle(this.x + this.width/2, this.y + this.height/2, 15, 'rgba(200,200,255,0.7)', [4,9], [2,5], [200,500]);
                switch (powerUpType) {
                    case POWERUP_TYPES.MULTI_SHOT:
                        if (this.bulletCount < MAX_BULLET_COUNT) {
                            this.bulletCount++;
                            showTemporaryPopup(`Multi-Shot Level ${this.bulletCount}!`);
                        } else {
                            showTemporaryPopup(`Multi-Shot Maxed!`);
                        }
                        break;
                    case POWERUP_TYPES.RAPID_FIRE:
                        this.shootDelayBase = this.type.baseShootDelay / 2;
                        this.rapidFireActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Laser Fingers Activated!");
                        break;
                    case POWERUP_TYPES.SHIELD:
                        this.shieldActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Force Field Activated!");
                        break;
                    case POWERUP_TYPES.SPEED_BOOST:
                        this.speed = this.type.baseSpeed * 1.5;
                        this.speedBoostActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Zoomies Activated!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN:
                        this.health += 50;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("+50 Health!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN:
                        this.health += 150;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("Golden Health +150!");
                        break;
                }
                updateUI();
            }
        }

        class Projectile{
            constructor(x,y,sX,sY,c, homingTarget = null){
                this.x=x-PROJECTILE_WIDTH/2;this.y=y-PROJECTILE_HEIGHT/2; this.width=PROJECTILE_WIDTH;this.height=PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c;
                this.trail = []; this.maxTrailLength = 5;
                this.homingTarget = homingTarget;
                this.initialSpeedMagnitude = Math.sqrt(sX*sX + sY*sY);
                this.homingStrengthFactor = 0.035;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.5 * (i / this.trail.length); ctx.fillStyle = `hsla(50, 100%, 70%, ${alpha})`; ctx.beginPath(); const trailWidth = this.width*0.6*((this.trail.length-i)/this.trail.length); const trailHeight = this.height*0.6*((this.trail.length-i)/this.trail.length); ctx.ellipse(point.x+this.width/2,point.y+this.height/2,trailWidth/2,trailHeight/2,0,0,Math.PI*2); ctx.fill(); }
                ctx.fillStyle=this.color; ctx.beginPath(); const r = Math.min(this.width,this.height)/3; ctx.moveTo(this.x+r,this.y); ctx.arcTo(this.x+this.width,this.y,this.x+this.width,this.y+this.height,r); ctx.arcTo(this.x+this.width,this.y+this.height,this.x,this.y+this.height,r); ctx.arcTo(this.x,this.y+this.height,this.x,this.y,r); ctx.arcTo(this.x,this.y,this.x+this.width,this.y,r); ctx.closePath(); ctx.fill();
                ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.ellipse(this.x+this.width/2,this.y+this.height/2,this.width/3,this.height/3,0,0,Math.PI*2); ctx.fill();
            }
            update(dT){
                const dF=dT/(1000/60);
                if (this.homingTarget && gameTargets.includes(this.homingTarget) && this.homingTarget.health > 0) {
                    const targetCenterX = this.homingTarget.x + this.homingTarget.width / 2;
                    const targetCenterY = this.homingTarget.y + this.homingTarget.height / 2;
                    const projectileCenterX = this.x + this.width / 2;
                    const projectileCenterY = this.y + this.height / 2;
                    const distToTarget = Math.sqrt(Math.pow(targetCenterX - projectileCenterX, 2) + Math.pow(targetCenterY - projectileCenterY, 2));

                    if (distToTarget > this.homingTarget.size * 0.5) {
                        const angleToTarget = Math.atan2(targetCenterY - projectileCenterY, targetCenterX - projectileCenterX);
                        let currentAngle = Math.atan2(this.speedY, this.speedX);
                        let angleDifference = normalizeAngle(angleToTarget - currentAngle);
                        const turnAmount = Math.max(-this.homingStrengthFactor, Math.min(this.homingStrengthFactor, angleDifference)) * dF;
                        const newAngle = currentAngle + turnAmount;
                        this.speedX = Math.cos(newAngle) * this.initialSpeedMagnitude;
                        this.speedY = Math.sin(newAngle) * this.initialSpeedMagnitude;
                    }
                } else { this.homingTarget = null; }

                this.x+=this.speedX*dF; this.y+=this.speedY*dF;

                if (this.x > CANVAS_WIDTH + this.width) this.x = -this.width;
                else if (this.x < -this.width) this.x = CANVAS_WIDTH + this.width;
                if (this.y > CANVAS_HEIGHT + this.height) this.y = -this.height;
                else if (this.y < -this.height) this.y = CANVAS_HEIGHT + this.height;

                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }
            }
        }

        let player1;
        let lastFrameTime = 0;

        function spawnTargets(count, isInitialSpawn = true) {
            const enemyTypes = ['purple','orange','green','blue']; let availableTypes = [...enemyTypes];
            if (gameMode === 'normal') {
                if(currentStage===1&&currentWave===1){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['blue','green'];}
                else if(currentStage===2&&currentWave===1){availableTypes=['green'];}
                else if(currentStage===2&&currentWave===2){availableTypes=['green','purple'];}
                else if(currentStage >= 3) {availableTypes = ['green','purple','orange'];}
            } else {
                if(currentStage===1&&currentWave===1){availableTypes=['blue','green'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue','green','purple'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['green','purple','orange'];}
                else {availableTypes = ['purple','orange','green'];}
            }

            let spawnMultiplier=1.0;
            if(gameMode==='hell')spawnMultiplier=isInitialSpawn? (targetsPerWaveBase * 1.1) :HELL_MODE_EXTRA_SPAWN_COUNT;
            else if(gameMode==='endless')spawnMultiplier=1.3;

            let numToSpawn=isInitialSpawn?count:spawnMultiplier;
            for(let i=0;i<numToSpawn;i++){ const side=Math.floor(Math.random()*4); let x,y; const margin=50; if(side===0){x=Math.random()*CANVAS_WIDTH;y=-margin-Math.random()*50;}else if(side===1){x=CANVAS_WIDTH+margin+Math.random()*50;y=Math.random()*CANVAS_HEIGHT;}else if(side===2){x=Math.random()*CANVAS_WIDTH;y=CANVAS_HEIGHT+margin+Math.random()*50;}else{x=-margin-Math.random()*50;y=Math.random()*CANVAS_HEIGHT;} const type=availableTypes[Math.floor(Math.random()*availableTypes.length)]; gameTargets.push(new Target(x,y,type)); }
        };
        function initializeStage(stage, wave) {
            currentStage = stage; currentWave = wave; gameTargets = []; enemyProjectiles = []; powerUps = [];
            if (gameMode === 'endless' || gameMode === 'hell') { stageDisplay.textContent = `${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)} Mode: Wave ${wave}`; }
            else { stageDisplay.textContent = `Stage ${stage}: Wave ${wave}`; }

            let baseTargetsForMode = (gameMode === 'hell') ? 3 : (gameMode === 'normal' ? 2 : 3);
            let stageIncrementFactor = (gameMode === 'hell') ? 2.2 : (gameMode === 'normal' ? 1.2 : 2);
            let waveIncrementFactor = (gameMode === 'hell') ? 1.2 : (gameMode === 'normal' ? 0.7 : 1);

            targetsPerWaveBase = baseTargetsForMode;

            let numToSpawn = targetsPerWaveBase + (wave - 1) * waveIncrementFactor + (stage - 1) * stageIncrementFactor;
            spawnTargets(Math.max(1, Math.floor(numToSpawn)), true);
            if (gameMode === 'hell') { setNextHellSpawnTime(); } updateUI();
        };

        function setNextPowerupSpawnTime() {
            nextPowerUpSpawnTime = Date.now() + Math.random() * (POWERUP_SPAWN_INTERVAL_MAX - POWERUP_SPAWN_INTERVAL_MIN) + POWERUP_SPAWN_INTERVAL_MIN;
        }
        function setNextGreenHealthPackSpawnTime() {
            nextGreenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GREEN_SPAWN_MAX - HEALTH_PACK_GREEN_SPAWN_MIN) + HEALTH_PACK_GREEN_SPAWN_MIN;
        }
        function setNextGoldenHealthPackSpawnTime() {
            nextGoldenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GOLDEN_SPAWN_MAX - HEALTH_PACK_GOLDEN_SPAWN_MIN) + HEALTH_PACK_GOLDEN_SPAWN_MIN;
        }

        function trySpawnPowerUp() {
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextPowerUpSpawnTime && powerUps.filter(p => p.type !== POWERUP_TYPES.HEALTH_PACK_GREEN && p.type !== POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                const availablePowerUps = [POWERUP_TYPES.MULTI_SHOT, POWERUP_TYPES.RAPID_FIRE, POWERUP_TYPES.SHIELD, POWERUP_TYPES.SPEED_BOOST];
                const randomType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                powerUps.push(new PowerUp(x,y,randomType));
                setNextPowerupSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGreenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GREEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GREEN));
                setNextGreenHealthPackSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGoldenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GOLDEN));
                setNextGoldenHealthPackSpawnTime();
            }
        }
        function setNextHellSpawnTime() { nextHellSpawnTime = Date.now() + HELL_MODE_SPAWN_INTERVAL * (0.7 + Math.random() * 0.2); }
        function trySpawnHellEnemies() {
            if (gameMode === 'hell' && gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextHellSpawnTime) {
                spawnTargets(0, false); setNextHellSpawnTime();
            }
        }

        function checkCollisions() {
            if (!player1 || player1.isSmashing) { return; }
            player1.projectiles.forEach((p, pIndex) => { for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; if (p.x < target.x+target.width && p.x+p.width > target.x && p.y < target.y+target.height && p.y+p.height > target.y) { target.takeDamage(10); player1.projectiles.splice(pIndex,1); playerScore+=SCORE_PER_HIT; if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]); gameTargets.splice(tIndex,1); if(player1.isSmashing) { /* No screen shake if smash killed it */ } else { screenShake(10, 200); } } break; }}});
            if (player1.isFiringBeam) { const beamAngle = player1.beamTargetAngle; const beamLength = CANVAS_WIDTH*1.5; for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; const tCX = target.x+target.width/2; const tCY = target.y+target.height/2; const pCX = player1.x+player1.width/2; const pCY = player1.y+player1.height/2; const dx = tCX-pCX; const dy = tCY-pCY; const distToP = Math.sqrt(dx*dx+dy*dy); if (distToP < beamLength) { const angleToT = Math.atan2(dy,dx); const angleDiff = Math.abs(normalizeAngle(beamAngle-angleToT)); if (angleDiff < Math.atan2(BEAM_THICKNESS/2,distToP) || distToP < target.size*0.8 ) { target.takeDamage(player1.beamDamagePerFrame*(lastFrameTime-(player1.beamFrameTime||lastFrameTime))/(1000/60)); playerScore+=SCORE_PER_BEAM_FRAME; if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]); gameTargets.splice(tIndex,1); screenShake(3,100); }}}} player1.beamFrameTime = lastFrameTime; } else { player1.beamFrameTime = null; }
            for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; if (player1.x < target.x+target.width && player1.x+player1.width > target.x && player1.y < target.y+target.height && player1.y+player1.height > target.y) { player1.takeDamage(TARGET_CONTACT_DAMAGE); target.takeDamage(50); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(tIndex,1); screenShake(5,150); } else { const dx = target.x-player1.x; const dy = target.y-player1.y; const dist = Math.sqrt(dx*dx+dy*dy)||1; target.x+=(dx/dist)*10; target.y+=(dy/dist)*10; }}}
            for (let epIndex = enemyProjectiles.length-1; epIndex >= 0; epIndex--) { const ep = enemyProjectiles[epIndex]; if (player1.health > 0 && ep.x < player1.x+player1.width && ep.x+ep.width > player1.x && ep.y < player1.y+player1.height && ep.y+ep.height > player1.y) { player1.takeDamage(ep.damage); enemyProjectiles.splice(epIndex,1); }}
            for (let puIndex = powerUps.length-1; puIndex >= 0; puIndex--) { const powerUp = powerUps[puIndex]; if (player1.x < powerUp.x+powerUp.size && player1.x+player1.width > powerUp.x && player1.y < powerUp.y+powerUp.size && player1.y+player1.height > powerUp.y) { player1.collectPowerUp(powerUp.type); powerUps.splice(puIndex,1); createParticle(powerUp.x + powerUp.size/2, powerUp.y + powerUp.size/2, 20, powerUp.pulseColor, [3,8], [2,5], [200,500]);}}
            if (!player1.isSmashing && gameTargets.length === 0 && gameRunning && player1.health > 0) { if (gameMode==='normal' && currentStage===COMPLETION_STAGE && currentWave===MAX_WAVES_PER_LEVEL) { showGameCompletionPopup(); } else { currentWave++; if (gameMode==='normal' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(10,targetsPerWaveBase+ (gameMode === 'hell' ? 2.2 : 1.2)); showTemporaryPopup(`Stage ${currentStage-1} Cleared! Onto Stage ${currentStage}!`); } else if (gameMode==='hell' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(20,targetsPerWaveBase+2.5); showTemporaryPopup(`Hell Stage ${currentStage-1} Cleared! Prepare for more!`); } else { showTemporaryPopup(`Wave ${currentWave-1} Cleared!`); } initializeStage(currentStage,currentWave); }}
            if (player1.health <= 0 && gameRunning) { announceOutcome("Game Over!", false); } updateUI();
        };

        function screenShake(intensity, duration) {
            document.body.style.transition = 'transform 0.05s';
            let startTime = Date.now();
            function shake() {
                let elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const x = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    const y = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    canvas.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(shake);
                } else {
                    canvas.style.transform = 'translate(0,0)';
                    document.body.style.transition = '';
                }
            }
            shake();
        }


        function showGameCompletionPopup() {
            gameRunning = false; messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            codeInputSection.classList.add('hidden'); deathOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            setMessageBadge('Mission Complete');
            showPopup(messageBox); currentPopupAction = 'game_complete';
        }

        function updateUI() {
            if (!player1) return;
            healthText.textContent = `${player1.health}`;
            const healthPercentage = (player1.health / player1.initialHealth) * 100;
            healthBarInner.style.width = `${Math.max(0, Math.min(100, healthPercentage))}%`;
            if (healthPercentage <= 25) {
                healthBarInner.style.backgroundColor = '#f56565';
            } else if (healthPercentage <= 60) {
                healthBarInner.style.backgroundColor = '#ecc94b';
            } else {
                healthBarInner.style.backgroundColor = '#48bb78';
            }

            scoreDisplay.textContent = `${playerScore}`;
            bulletCountDisplay.textContent = `${player1.bulletCount}`;
            player1.updateChargeIndicators();
        };
        function announceOutcome(message, isVictory) {
            gameRunning = false; messageText.textContent = message;
            codeInputSection.classList.add('hidden'); completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); deathOptions.classList.remove('hidden');
            actionButton1.textContent = "Respawn"; actionButton2.classList.remove('hidden'); actionButton2.textContent = "Revive";
            setMessageBadge(isVictory ? 'Mission Complete' : 'Critical Status');
            showPopup(messageBox); currentPopupAction = 'game_over_options';

            // MODIFIED: Changed prompt to use the globalPlayerName
            const playerNameForLeaderboard = globalPlayerName || `Fox${Math.floor(Math.random()*1000)}`;

            if (!isVictory) {
                // We'll just auto-save with the name they entered at the start.
                // const playerName = prompt("Game Over! Enter name for leaderboard:", `Fox${Math.floor(Math.random()*1000)}`);
                saveScoreToLeaderboard(playerNameForLeaderboard, playerScore);
                displayLeaderboard();
                leaderboardContainer.classList.remove('hidden');
            } else {
                leaderboardContainer.classList.add('hidden');
            }
        };
        actionButton1.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; leaderboardContainer.classList.add('hidden'); gameMode = 'normal'; document.body.className = 'select-none';
            player1.reset(true); currentStage = 1; currentWave = 1; targetsPerWaveBase = 2;
            initializeStage(1,1);
            gameRunning = true; lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        function saveScoreToLeaderboard(name, score) {
            let l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.4')) || [];
            l.push({ name, score, date: new Date().toLocaleDateString(), stage: `${gameMode.substring(0,1).toUpperCase()}-S${currentStage}W${currentWave}` });
            l.sort((a,b) => b.score - a.score); l = l.slice(0,10); localStorage.setItem('ssbbLeaderboard_v6.4', JSON.stringify(l));
        };
        function displayLeaderboard() {
            leaderboardList.innerHTML = ""; const l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.4')) || [];
            if (l.length === 0) { leaderboardList.innerHTML = "<li>No scores yet! Be the first!</li>"; return; }
            l.forEach(e => { const li = document.createElement('li'); li.textContent = `${e.name}: ${e.score} (${e.stage} - ${e.date})`; leaderboardList.appendChild(li); });
        };

        function gameLoop(currentTime) {
            if (!gameRunning && !isGameEffectivelyPaused()) {
            } else if (!gameRunning && isGameEffectivelyPaused()) {
                return;
            }

            const dT = Math.min(50, (currentTime - lastFrameTime) || (1000/60)); lastFrameTime = currentTime;

            if (!isGameEffectivelyPaused()) {
                trySpawnPowerUp(); trySpawnHellEnemies();
                if (player1) { player1.update(dT); }
                gameTargets.forEach(t => { if (player1) { t.update(player1.x,player1.y,dT,gameTargets); }});
                enemyProjectiles.forEach((ep,i) => { ep.update(dT); });
                powerUps.forEach((pu,i) => { if (pu.update(dT)) { powerUps.splice(i,1); } });
                if (player1) { player1.projectiles.forEach(p => p.update(dT)); }
                checkCollisions();
            }

            ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT); updateAndDrawParticles(dT);
            if (player1) { player1.draw(); }
            gameTargets.forEach(t => { t.draw(); });
            enemyProjectiles.forEach((ep) => { ep.draw(); });
            powerUps.forEach((pu) => { pu.draw(); });
            if (player1) { player1.projectiles.forEach(p => p.draw()); }

            requestAnimationFrame(gameLoop);
        };

        function resizeCanvas() {
            const gameArea = document.querySelector('.game-container');
            const topUIHeight = document.querySelector('h1').offsetHeight + document.querySelector('.ui-top-bar').offsetHeight + document.querySelector('#stageDisplay').offsetHeight + 5;
            const bottomUIHeight = document.querySelector('.controls-info').offsetHeight + document.querySelector('.extra-buttons-container').offsetHeight + (leaderboardContainer.classList.contains('hidden')?0:leaderboardContainer.offsetHeight) + 5;

            const availableWidth = window.innerWidth - 4;
            const availableHeight = window.innerHeight - topUIHeight - bottomUIHeight - 4;

            const aspectRatio = 16/9;
            let newWidth = availableWidth;
            let newHeight = newWidth / aspectRatio;

            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * aspectRatio;
            }
            newWidth = Math.min(newWidth, gameArea.clientWidth - 2);
            newHeight = newWidth / aspectRatio;


            newWidth = Math.max(320, Math.min(newWidth, 2560));
            newHeight = Math.max(180, Math.min(newHeight, 1440));

            canvas.width = newWidth;
            canvas.height = newHeight;
            CANVAS_WIDTH = newWidth;
            CANVAS_HEIGHT = newHeight;

            if(player1){
                player1.x=Math.max(0,Math.min(player1.x,CANVAS_WIDTH-player1.width));
                player1.y=Math.max(0,Math.min(player1.y,CANVAS_HEIGHT-player1.height));
                player1.smashMaxRadius = Math.max(CANVAS_WIDTH,CANVAS_HEIGHT)*0.8;
                player1.smashExpansionSpeed = player1.smashMaxRadius/50;
            }
            updateUI();
        };

        function startGame() {
            mainGameContent.classList.remove('hidden');
            player1 = new FoxPlayer(50, CANVAS_HEIGHT/2 - PLAYER_HEIGHT/2, "Ranger", { up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',shoot:'Space',beam:'KeyB',smash:'KeyX' });
            setNextPowerupSpawnTime();
            setNextGreenHealthPackSpawnTime();
            setNextGoldenHealthPackSpawnTime();
            resizeCanvas(); window.addEventListener('resize', resizeCanvas);
            initializeStage(1,1);
            displayLeaderboard();
            if (JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.4'))?.length > 0) { leaderboardContainer.classList.remove('hidden'); }
            gameRunning = true;
            lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        showPopup(licensePopup);
        licenseKeyInput.focus();

    });
    </script>
</body>
</html>

