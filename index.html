<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShootyShooty BangBang Plus - v6.5</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
:root {
    --bg-gradient: radial-gradient(120% 120% at 50% 0%, rgba(96, 77, 214, 0.55), rgba(7, 10, 28, 0.95));
    --bg-overlay: linear-gradient(180deg, rgba(8, 14, 40, 0.8) 0%, rgba(2, 6, 18, 0.95) 60%, rgba(0, 3, 8, 0.98) 100%);
    --panel-bg: rgba(12, 18, 44, 0.7);
    --panel-border: rgba(148, 163, 255, 0.22);
    --panel-highlight: rgba(255, 255, 255, 0.1);
    --text-primary: #e9edff;
    --text-muted: #9aa6d9;
    --accent: #8b5cf6;
    --accent-strong: #a855f7;
    --accent-soft: rgba(139, 92, 246, 0.18);
    --success: #4ade80;
    --warning: #facc15;
    --danger: #fb7185;
    --glow: rgba(139, 92, 246, 0.35);
    --star-primary: rgba(255, 255, 255, 0.95);
    --star-secondary: rgba(125, 211, 252, 0.85);
    --star-tertiary: rgba(244, 114, 182, 0.75);
}
body {
    font-family: 'Outfit', 'Space Grotesk', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    margin: 0;
    padding: 1.75rem 1rem 3rem;
    background: var(--bg-gradient);
    color: var(--text-primary);
    overflow-x: hidden;
    position: relative;
    transition: background 0.6s ease, color 0.6s ease;
}
body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -2;
    background-image:
        radial-gradient(var(--star-primary) 1px, transparent 45px),
        radial-gradient(var(--star-secondary) 1.2px, transparent 60px),
        radial-gradient(var(--star-tertiary) 1.5px, transparent 80px),
        radial-gradient(rgba(255, 255, 255, 0.25) 0.5px, transparent 35px),
        radial-gradient(rgba(148, 163, 255, 0.2) 1px, transparent 70px);
    background-size: 160px 160px, 220px 220px, 340px 340px, 120px 120px, 420px 420px;
    background-position: 0 0, 40px 60px, 120px -40px, -30px 90px, 80px 210px;
    animation: starDrift 65s linear infinite;
    opacity: 0.85;
}
body::after {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;
    background: var(--bg-overlay);
    pointer-events: none;
}
@keyframes starDrift {
    from { background-position: 0 0, 40px 60px, 120px -40px, -30px 90px, 80px 210px; }
    to { background-position: -360px -360px, -220px -180px, 240px -260px, 160px -140px, -120px -240px; }
}
body.hell-mode::before {
    animation-duration: 35s;
    opacity: 0.95;
}
body.endless-mode::before {
    animation-duration: 85s;
    opacity: 0.7;
}
body[data-theme="aurora"] {
    --bg-gradient: radial-gradient(120% 120% at 50% 5%, rgba(112, 75, 217, 0.6), rgba(7, 12, 36, 0.96));
    --bg-overlay: linear-gradient(200deg, rgba(16, 22, 60, 0.85) 0%, rgba(4, 7, 24, 0.95) 55%, rgba(2, 4, 16, 0.98) 100%);
    --panel-bg: rgba(18, 26, 60, 0.72);
    --panel-border: rgba(147, 197, 253, 0.25);
    --accent: #a78bfa;
    --accent-strong: #7c5cfc;
    --accent-soft: rgba(167, 139, 250, 0.2);
    --glow: rgba(130, 102, 255, 0.45);
    --star-primary: rgba(255, 255, 255, 0.9);
    --star-secondary: rgba(165, 243, 252, 0.85);
    --star-tertiary: rgba(196, 181, 253, 0.8);
}
body[data-theme="supernova"] {
    --bg-gradient: radial-gradient(130% 140% at 60% -10%, rgba(255, 138, 76, 0.6), rgba(26, 8, 48, 0.96));
    --bg-overlay: linear-gradient(200deg, rgba(36, 12, 36, 0.85) 0%, rgba(19, 6, 32, 0.95) 50%, rgba(8, 2, 18, 0.98) 100%);
    --panel-bg: rgba(35, 14, 42, 0.72);
    --panel-border: rgba(248, 113, 113, 0.28);
    --accent: #fb7185;
    --accent-strong: #f97316;
    --accent-soft: rgba(251, 113, 133, 0.2);
    --glow: rgba(251, 113, 133, 0.42);
    --star-primary: rgba(255, 241, 176, 0.95);
    --star-secondary: rgba(255, 169, 129, 0.85);
    --star-tertiary: rgba(255, 99, 146, 0.8);
}
body[data-theme="nebula"] {
    --bg-gradient: radial-gradient(120% 160% at 30% -20%, rgba(45, 212, 191, 0.5), rgba(12, 10, 52, 0.97));
    --bg-overlay: linear-gradient(210deg, rgba(10, 28, 48, 0.82) 0%, rgba(6, 17, 38, 0.95) 60%, rgba(2, 8, 20, 0.98) 100%);
    --panel-bg: rgba(16, 32, 56, 0.72);
    --panel-border: rgba(45, 212, 191, 0.28);
    --accent: #22d3ee;
    --accent-strong: #38bdf8;
    --accent-soft: rgba(34, 211, 238, 0.2);
    --glow: rgba(34, 211, 238, 0.4);
    --star-primary: rgba(224, 255, 255, 0.95);
    --star-secondary: rgba(125, 211, 252, 0.85);
    --star-tertiary: rgba(165, 243, 252, 0.8);
}
body[data-theme="oasis"] {
    --bg-gradient: radial-gradient(130% 140% at 70% 0%, rgba(45, 197, 253, 0.55), rgba(5, 22, 35, 0.96));
    --bg-overlay: linear-gradient(200deg, rgba(10, 32, 48, 0.85) 0%, rgba(4, 14, 24, 0.95) 60%, rgba(1, 6, 12, 0.98) 100%);
    --panel-bg: rgba(10, 30, 44, 0.72);
    --panel-border: rgba(59, 130, 246, 0.26);
    --accent: #38bdf8;
    --accent-strong: #34d399;
    --accent-soft: rgba(56, 189, 248, 0.22);
    --glow: rgba(56, 189, 248, 0.4);
    --star-primary: rgba(240, 253, 250, 0.95);
    --star-secondary: rgba(165, 243, 252, 0.85);
    --star-tertiary: rgba(134, 239, 172, 0.8);
}
body[data-theme="endless"] {
    --bg-gradient: radial-gradient(130% 180% at 50% 0%, rgba(59, 130, 246, 0.4), rgba(13, 16, 48, 0.96));
    --bg-overlay: linear-gradient(200deg, rgba(9, 23, 64, 0.85) 0%, rgba(7, 11, 34, 0.96) 55%, rgba(2, 6, 20, 0.98) 100%);
    --panel-bg: rgba(12, 26, 58, 0.72);
    --panel-border: rgba(147, 197, 253, 0.28);
    --accent: #60a5fa;
    --accent-strong: #38bdf8;
    --accent-soft: rgba(59, 130, 246, 0.2);
    --glow: rgba(59, 130, 246, 0.42);
    --star-primary: rgba(233, 248, 255, 0.95);
    --star-secondary: rgba(137, 180, 255, 0.85);
    --star-tertiary: rgba(96, 165, 250, 0.8);
}
body[data-theme="inferno"] {
    --bg-gradient: radial-gradient(140% 200% at 50% -10%, rgba(255, 94, 0, 0.55), rgba(32, 7, 20, 0.97));
    --bg-overlay: linear-gradient(210deg, rgba(45, 6, 24, 0.85) 0%, rgba(28, 6, 20, 0.95) 60%, rgba(12, 3, 14, 0.98) 100%);
    --panel-bg: rgba(38, 8, 22, 0.75);
    --panel-border: rgba(248, 113, 113, 0.32);
    --accent: #fb7185;
    --accent-strong: #f97316;
    --accent-soft: rgba(251, 113, 133, 0.24);
    --glow: rgba(249, 115, 22, 0.45);
    --star-primary: rgba(255, 244, 214, 0.95);
    --star-secondary: rgba(255, 149, 128, 0.85);
    --star-tertiary: rgba(255, 94, 94, 0.8);
}
#versionDisplay {
    position: fixed;
    top: 1.25rem;
    right: 1.25rem;
    font-size: 0.75rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    background: rgba(15, 23, 42, 0.6);
    padding: 0.35rem 0.85rem;
    border-radius: 999px;
    border: 1px solid var(--panel-border);
    color: var(--text-muted);
    backdrop-filter: blur(10px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35), 0 0 20px var(--glow);
    z-index: 10;
}
.game-container {
    width: min(1200px, calc(100vw - 2rem));
    background: linear-gradient(160deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0.02) 50%, rgba(255, 255, 255, 0.03) 100%), var(--panel-bg);
    border-radius: 28px;
    border: 1px solid var(--panel-border);
    padding: 2.25rem clamp(1.25rem, 2vw, 2.5rem);
    box-shadow: 0 35px 90px rgba(6, 8, 24, 0.55), 0 0 80px var(--glow);
    backdrop-filter: blur(20px);
    display: flex;
    flex-direction: column;
    gap: 1.4rem;
}
.game-title {
    font-size: clamp(2.25rem, 4vw, 3.2rem);
    font-weight: 700;
    margin: 0;
    text-align: left;
    color: var(--text-primary);
    text-shadow: 0 14px 30px rgba(0, 0, 0, 0.5);
}
.game-tagline {
    margin: -0.5rem 0 0.5rem;
    color: var(--text-muted);
    font-size: clamp(1rem, 1.6vw, 1.2rem);
    letter-spacing: 0.02em;
}
.cosmic-subheader {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 1.5rem;
}
.theme-panel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}
.theme-panel__label {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: var(--text-muted);
}
.theme-panel__label .label-title {
    font-size: 0.75rem;
    letter-spacing: 0.22em;
}
.theme-panel__label .label-value {
    font-size: 0.9rem;
    letter-spacing: 0.08em;
    color: var(--text-primary);
}
.theme-card-grid {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
}
.theme-card {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 0.55rem;
    padding: 0.65rem 1rem;
    border-radius: 18px;
    border: 1px solid transparent;
    background: rgba(10, 12, 28, 0.45);
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 12px 30px rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(8px);
}
.theme-card::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 18px;
    opacity: 0.75;
    z-index: -1;
    transition: opacity 0.3s ease;
}
.theme-card .theme-card__swatch {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
}
.theme-card span:last-child {
    pointer-events: none;
}
.theme-card.active, .theme-card:hover {
    transform: translateY(-4px);
    border-color: var(--accent-strong);
    box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35), 0 0 24px var(--glow);
}
.theme-card.active::before {
    opacity: 1;
}
.theme-aurora::before {
    background: linear-gradient(120deg, rgba(124, 92, 255, 0.5), rgba(34, 211, 238, 0.4));
}
.theme-supernova::before {
    background: linear-gradient(120deg, rgba(249, 115, 22, 0.55), rgba(244, 114, 182, 0.5));
}
.theme-nebula::before {
    background: linear-gradient(120deg, rgba(16, 185, 129, 0.55), rgba(59, 130, 246, 0.5));
}
.theme-oasis::before {
    background: linear-gradient(120deg, rgba(37, 99, 235, 0.55), rgba(56, 189, 248, 0.5));
}
.theme-aurora .theme-card__swatch {
    background: radial-gradient(circle at 30% 30%, #f0abfc, #6366f1);
}
.theme-supernova .theme-card__swatch {
    background: radial-gradient(circle at 20% 20%, #fed7aa, #f97316);
}
.theme-nebula .theme-card__swatch {
    background: radial-gradient(circle at 20% 20%, #5eead4, #38bdf8);
}
.theme-oasis .theme-card__swatch {
    background: radial-gradient(circle at 20% 20%, #bbf7d0, #22d3ee);
}
.session-badges {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
}
.session-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.45rem 0.9rem;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid var(--panel-border);
    color: var(--text-muted);
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
}
.ui-top-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
}
.ui-chip {
    background: rgba(0, 8, 24, 0.4);
    border: 1px solid var(--panel-border);
    border-radius: 18px;
    padding: 0.85rem 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
}
.ui-chip--score {
    font-weight: 600;
    font-size: 1rem;
    color: var(--accent);
}
.ui-chip--health {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.6rem;
}
.ui-chip--shots {
    justify-content: center;
    font-weight: 600;
}
.chip-title {
    font-weight: 600;
    font-size: 0.95rem;
}
.chip-label {
    font-size: 0.75rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--text-muted);
}
.health-bar-container {
    width: 100%;
    height: 12px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.05);
}
.health-bar-inner {
    height: 100%;
    background: linear-gradient(90deg, #34d399, #22d3ee);
    transition: width 0.25s ease;
    border-radius: inherit;
}
.charge-container {
    flex: 1;
    height: 14px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.35);
}
.charge-bar {
    height: 100%;
    width: 0%;
    border-radius: inherit;
    transition: width 0.2s ease, background 0.3s ease;
}
.beam-charge-bar {
    background: linear-gradient(90deg, #fbbf24, #f59e0b);
}
.beam-charge-bar.ready {
    background: linear-gradient(90deg, #34d399, #4ade80);
    box-shadow: 0 0 12px rgba(74, 222, 128, 0.6);
}
.smash-charge-bar {
    background: linear-gradient(90deg, #fb7185, #f472b6);
}
.smash-charge-bar.ready {
    background: linear-gradient(90deg, #a855f7, #6366f1);
    box-shadow: 0 0 12px rgba(99, 102, 241, 0.6);
}
#stageDisplay {
    font-size: 1.15rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.25em;
    text-align: center;
    padding: 0.75rem 1rem;
    border-radius: 18px;
    border: 1px solid var(--panel-border);
    background: rgba(0, 8, 24, 0.45);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
}
#gameCanvas {
    width: 100%;
    max-width: 100%;
    border-radius: 24px;
    border: 2px solid rgba(255, 255, 255, 0.08);
    background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.06), rgba(4, 10, 30, 0.95));
    box-shadow: 0 30px 80px rgba(8, 12, 40, 0.65), 0 0 50px var(--glow);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}
body.hell-mode #gameCanvas {
    border-color: rgba(248, 113, 113, 0.65);
    box-shadow: 0 30px 80px rgba(45, 6, 24, 0.75), 0 0 70px rgba(249, 115, 22, 0.55);
}
body.endless-mode #gameCanvas {
    border-color: rgba(96, 165, 250, 0.65);
    box-shadow: 0 30px 80px rgba(8, 26, 64, 0.7), 0 0 70px rgba(96, 165, 250, 0.5);
}
.extra-buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.9rem;
    justify-content: center;
}
.mode-selection-buttons,
.button-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.8rem;
    margin-top: 1rem;
}
.button-row {
    margin-top: 0.75rem;
}
.button {
    padding: 0.75rem 1.35rem;
    border-radius: 999px;
    border: 1px solid transparent;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    color: var(--text-primary);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease, background 0.3s ease;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
    backdrop-filter: blur(6px);
}
.button:hover {
    transform: translateY(-3px);
    box-shadow: 0 16px 40px rgba(0, 0, 0, 0.4), 0 0 24px var(--glow);
}
.button:active {
    transform: translateY(0);
}
.button:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 3px;
}
.button-primary {
    border-color: var(--accent-strong);
    color: var(--accent-strong);
}
.button-secondary {
    border-color: rgba(255, 255, 255, 0.22);
    color: var(--text-primary);
}
.button-danger {
    border-color: rgba(251, 113, 133, 0.8);
    color: #fb7185;
}
.button-special {
    border-color: rgba(45, 212, 191, 0.85);
    color: #22d3ee;
}
.button-godmode {
    border-color: rgba(250, 204, 21, 0.85);
    color: #fde68a;
}
.button-healthboost {
    border-color: rgba(74, 222, 128, 0.8);
    color: #4ade80;
}
.button-finish {
    border-color: rgba(96, 165, 250, 0.8);
    color: #60a5fa;
}
.button-danger:hover {
    background: linear-gradient(135deg, rgba(251, 113, 133, 0.18), rgba(251, 113, 133, 0.04));
}
.button-special:hover {
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.18), rgba(45, 212, 191, 0.04));
}
.button-godmode:hover {
    background: linear-gradient(135deg, rgba(250, 204, 21, 0.18), rgba(250, 204, 21, 0.04));
}
.button-healthboost:hover {
    background: linear-gradient(135deg, rgba(74, 222, 128, 0.18), rgba(74, 222, 128, 0.04));
}
.button-finish:hover {
    background: linear-gradient(135deg, rgba(96, 165, 250, 0.18), rgba(96, 165, 250, 0.04));
}
.button-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    font-size: 1.75rem;
    color: var(--text-muted);
    cursor: pointer;
    transition: transform 0.3s ease, color 0.3s ease;
}
.button-close:hover {
    transform: rotate(90deg);
    color: var(--text-primary);
}
.controls-info {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
    border-radius: 22px;
    border: 1px solid var(--panel-border);
    padding: 1.2rem;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.9rem;
    line-height: 1.6;
}
.controls-heading {
    margin: 0 0 0.75rem;
    color: var(--accent);
    font-size: 1.05rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
}
.controls-accent {
    color: var(--accent-strong);
    font-weight: 600;
}
.controls-detail {
    font-size: 0.8rem;
    color: var(--text-muted);
}
#leaderboardContainer {
    margin-top: 0.5rem;
    padding: 1.2rem;
    border-radius: 22px;
    border: 1px solid var(--panel-border);
    background: linear-gradient(160deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.01));
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
    color: var(--text-primary);
}
#leaderboardContainer h2 {
    color: var(--accent);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 0.75rem;
}
#leaderboardList {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 180px;
    overflow-y: auto;
}
#leaderboardList li {
    padding: 0.55rem 0.25rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    font-size: 0.85rem;
    color: var(--text-muted);
}
.leaderboard-hint {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.75rem;
}
#leaderboardList li:last-child {
    border-bottom: none;
}
.input-group {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.75rem;
}
.input-group input {
    flex: 1;
    background: rgba(8, 12, 32, 0.8);
    color: var(--text-primary);
    border: 1px solid var(--panel-border);
    padding: 0.75rem 1rem;
    border-radius: 14px;
    font-size: 1rem;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    min-width: 220px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}
.input-group input:focus {
    border-color: var(--accent-strong);
    box-shadow: 0 0 0 3px rgba(124, 92, 255, 0.25);
    outline: none;
}
.input-error {
    border-color: #f87171 !important;
    box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.25) !important;
}
.error-text {
    color: #fca5a5;
    font-size: 0.85rem;
    margin-top: 0.5rem;
}
#messageBox, #changelogPopup, #licensePopup, #namePopup, #loadingScreen, #adminPasswordPopup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.92);
    background: linear-gradient(160deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02)), var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 26px;
    padding: 2.2rem 2.6rem;
    width: min(92vw, 620px);
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55), 0 0 60px var(--glow);
    text-align: center;
    opacity: 0;
    pointer-events: none;
    color: var(--text-primary);
    backdrop-filter: blur(24px);
    z-index: 100;
    transition: transform 0.35s cubic-bezier(0.23, 1, 0.32, 1), opacity 0.3s ease;
}
.popup-title {
    margin: 0 0 1.25rem;
    font-size: clamp(1.5rem, 2.4vw, 2rem);
    font-weight: 700;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--accent-strong);
}
.changelog-title {
    text-align: center;
}
.message-box-text {
    font-size: 1.05rem;
    margin-bottom: 1.25rem;
    color: var(--text-primary);
    line-height: 1.6;
}
#changelogPopup {
    text-align: left;
    max-height: 80vh;
    overflow-y: auto;
}
#changelogContent p {
    margin-bottom: 0.6rem;
    line-height: 1.5;
    color: var(--text-muted);
}
#changelogContent p:first-child {
    color: var(--accent-strong);
    font-weight: 600;
}
#tempPopup {
    position: fixed;
    top: 9%;
    left: 50%;
    transform: translate(-50%, -10px);
    padding: 0.85rem 1.6rem;
    border-radius: 999px;
    background: rgba(8, 12, 32, 0.85);
    border: 1px solid var(--panel-border);
    color: var(--text-primary);
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0;
    pointer-events: none;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45), 0 0 30px var(--glow);
    transition: transform 0.35s ease, opacity 0.3s ease;
    z-index: 140;
}
#tempPopup.visible {
    opacity: 1;
    transform: translate(-50%, 0);
}
#messageBox.visible, #changelogPopup.visible, #licensePopup.visible, #namePopup.visible, #loadingScreen.visible, #adminPasswordPopup.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
    pointer-events: auto;
}
#loadingScreen {
    z-index: 120;
}
#loadingProgressBarContainer {
    width: 100%;
    height: 16px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    overflow: hidden;
    margin-top: 1.5rem;
}
#loadingProgressBar {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent-strong));
    transition: width 0.25s ease;
    box-shadow: 0 0 20px var(--glow);
}
.hidden {
    display: none !important;
}
@media (max-width: 1024px) {
    .game-container {
        padding: 2rem 1.5rem;
    }
}
@media (max-width: 768px) {
    body {
        padding: 1.5rem 0.75rem 2.5rem;
    }
    .cosmic-subheader {
        flex-direction: column;
        align-items: flex-start;
    }
    .theme-card-grid {
        width: 100%;
    }
    .ui-top-bar {
        grid-template-columns: repeat(2, minmax(0, 1fr));
    }
}
@media (max-width: 540px) {
    .ui-top-bar {
        grid-template-columns: repeat(1, minmax(0, 1fr));
    }
    .session-badges {
        width: 100%;
        justify-content: center;
    }
    .theme-card-grid {
        justify-content: center;
    }
    #versionDisplay {
        position: static;
        margin-bottom: 1rem;
    }
}
</style>
</head>
<body class="select-none" data-theme="aurora">
    <div id="versionDisplay" class="version-box">V6.5</div>
    <div id="tempPopup" class="hidden"></div>
 
    <div id="licensePopup" class="hidden">
        <h2 class="popup-title">Game Integrity Protection GIP</h2>
        <p class="mb-4">Please enter your license key to play this game.</p>
        <div class="input-group">
            <input type="text" id="licenseKeyInput" placeholder="Enter License Key">
            <button id="submitLicenseKeyButton" class="button button-primary" type="button">Verify Key</button>
        </div>
        <p id="licenseErrorText" class="error-text hidden">Invalid License Key!</p>
    </div>

    <div id="namePopup" class="hidden">
        <h2 class="popup-title">Integrity Verified.</h2>
        <p class="mb-4">Please enter your name.</p>
        <div class="input-group">
            <input type="text" id="playerNameInput" placeholder="Enter Your Name">
            <button id="submitPlayerNameButton" class="button button-primary" type="button">Start Game</button>
        </div>
    </div>

    <div id="loadingScreen" class="hidden">
        <h2 id="loadingWelcomeText" class="popup-title">Welcome!</h2>
        <p class="mb-4">We're loading your game environment, please wait.</p>
        <div id="loadingProgressBarContainer">
            <div id="loadingProgressBar"></div>
        </div>
    </div>

    <!-- NEW ADMIN PASSWORD POPUP -->
    <div id="adminPasswordPopup" class="hidden">
        <h2 class="popup-title">Admin Access</h2>
        <p class="mb-4">Enter the password to access admin features.</p>
        <div class="input-group">
            <input type="password" id="adminPasswordInput" placeholder="Enter Password">
            <button id="submitAdminPasswordButton" class="button button-godmode" type="button">Submit</button>
        </div>
        <p id="adminPasswordError" class="error-text hidden">Invalid Password!</p>
        <button id="closeAdminPasswordPopup" class="button-close" type="button">&times;</button>
    </div>
    <!-- END NEW POPUP -->


    <div id="mainGameContent" class="hidden">
        <div class="game-container">
            <h1 class="game-title">ShootyShooty BangBang Plus</h1>
            <p class="game-tagline">Carve constellations of victory in a sky that matches your mood.</p>
            <div class="cosmic-subheader">
                <div class="theme-panel">
                    <div class="theme-panel__label">
                        <span class="label-title">Theme</span>
                        <span class="label-value" id="activeThemeName">Aurora</span>
                    </div>
                    <div class="theme-card-grid">
                        <button class="theme-card theme-aurora active" type="button" data-theme-option="aurora">
                            <span class="theme-card__swatch"></span>
                            <span>Aurora</span>
                        </button>
                        <button class="theme-card theme-supernova" type="button" data-theme-option="supernova">
                            <span class="theme-card__swatch"></span>
                            <span>Supernova</span>
                        </button>
                        <button class="theme-card theme-nebula" type="button" data-theme-option="nebula">
                            <span class="theme-card__swatch"></span>
                            <span>Nebula Drift</span>
                        </button>
                        <button class="theme-card theme-oasis" type="button" data-theme-option="oasis">
                            <span class="theme-card__swatch"></span>
                            <span>Solar Oasis</span>
                        </button>
                    </div>
                </div>
                <div class="session-badges">
                    <span class="session-badge">Brighter starfields</span>
                    <span class="session-badge">Glass panels</span>
                    <span class="session-badge">Dynamic glow</span>
                </div>
            </div>

            <div class="ui-top-bar">
                <div id="healthDisplayContainer" class="ui-chip ui-chip--health">
                    <span id="healthText" class="chip-title">Health: 100</span>
                    <div class="health-bar-container">
                        <div id="healthBarInner" class="health-bar-inner"></div>
                    </div>
                </div>
                <div id="scoreDisplay" class="ui-chip ui-chip--score">Score: 0</div>
                <div class="ui-chip">
                    <span class="chip-label">Beam</span>
                    <div class="charge-container">
                        <div id="beamChargeBar" class="charge-bar beam-charge-bar"></div>
                    </div>
                </div>
                <div class="ui-chip">
                    <span class="chip-label">Smash</span>
                    <div class="charge-container">
                        <div id="smashChargeBar" class="charge-bar smash-charge-bar"></div>
                    </div>
                </div>
                <div id="bulletCountDisplay" class="ui-chip ui-chip--shots">Shots: 1</div>
            </div>

            <div id="stageDisplay" class="stage-info">Stage 1: Wave 1</div>
            <canvas id="gameCanvas"></canvas>

            <div class="extra-buttons-container">
                <button id="aimbotButton" class="button button-secondary" type="button">Aimbot</button>
                <button id="changelogButton" class="button button-secondary" type="button">Changelog</button>
                <button id="invincibilityButton" class="button button-godmode" type="button">Invincibility</button>
                <button id="plusHealthButton" class="button button-healthboost" type="button">+100 Health</button>
                <button id="finishGameButton" class="button button-finish" type="button">Finish Game</button>
            </div>

            <div id="messageBox" class="hidden">
                <p id="messageText" class="message-box-text"></p>
                <div id="codeInputSection" class="hidden input-group">
                    <input type="text" id="codeInput" placeholder="Enter Code">
                    <button id="submitCodeButton" class="button button-primary" type="button">Submit</button>
                    <button id="cancelCodeButton" class="button button-secondary" type="button">Cancel</button>
                </div>
                <div id="deathOptions" class="hidden button-row">
                    <button id="actionButton1" class="button button-primary" type="button">Play Again</button>
                    <button id="actionButton2" class="button button-secondary" type="button">Revive</button>
                </div>
                <div id="completionOptions" class="hidden mode-selection-buttons">
                    <button id="hellModeButton" class="button button-danger" type="button">Hell Mode</button>
                    <button id="endlessModeButton" class="button button-special" type="button">Endless Mode</button>
                </div>
                <div id="hellConfirmOptions" class="hidden mode-selection-buttons">
                    <button id="confirmHellButton" class="button button-danger" type="button">Yes, Unleash Hell!</button>
                    <button id="cancelHellButton" class="button button-secondary" type="button">Maybe Later</button>
                </div>
                <button id="closeMessageBoxButton" class="button-close" type="button">&times;</button>
            </div>

            <div id="changelogPopup" class="hidden">
                <h2 class="popup-title changelog-title">Changelog</h2>
                <div id="changelogContent">
                    <p>6.5: Revive password changed to 'ultrasecretpasscode'.</p>
                    <p>6.4: Added password protection to admin controls ('Invincibility', '+100 Health', 'Finish Game'). Admin access is now granted for the entire session after one successful login. Game version updated and title renamed to 'ShootyShooty BangBang Plus'.</p>
                    <p>6.2: fixed enemy health bar display. Added Green (+50HP) and Golden (+150HP) health power-ups cause duh. Enhanced particle effects for explosions and power-up collection. Screen shake on Smash & enemy death >:) </p>
                    <p>6.1: fixed GIP input issue with game control keys. beam attack now correctly uses sigma aimbot at the nearest enemy. refined bullet homing to prevent circling at close distance or whatever</p>
                    <p>6.0: fixed beam auto-aim. improved bullet homing to prevent circling at close range. enemy bullets no longer wrap.</p>
                    <p>5.9: fixed page scrolling. beam attack now auto-aims at nearest enemy. Added more background stars. Buttons now have an outline style. Fixed bullet homing issue circle. bullets now rebound instead of despawn for amore CHAOOSOSOSOSOSOSOSO</p>
                    <p>5.8: game title updated to "Shooty Shooty Bang Bang PLUS".resizing logic adjusted to make the game area larger because it kept.</p>
                    <p>5.7: changed 8-bit fonts to a smoother sans-serif font for a calmer feel and not like arcade pew pew pew pew</p>
                    <p>5.6: aimbot password changed.</p>
                    <p>5.5: player icon changed to a fox emoji cause old one looked like a fuckin box. particle logic adjusted for new shape.</p>
                    <p>5.4: added new power-ups: Rapid Fire, Shield, Speed Boost. power-up spawn timer no longer resets on wave/stage change. power-ups spawn every 10-20s.</p>
                    <p>5.3: ssssslightly increased bullet homing strength. Added more stars to the background for a cooler background hehe</p>
                    <p>5.2: added health bar. Added 'Finish Game' button. Adjusted Hell mode (slightly easier) & Normal mode (easier) difficulty. Changed main font to serif.</p>
                    <p>5.1: nerfed bullet homing strength. made Normal mode easier (enemy health/speed, wave length???)</p>
                    <p>5.0: created shooty shooty bang bang plus. more features, so beautiful and supports creator :D<p>
                    <p>4.9: moved Aimbot & Changelog buttons for better visibility below playing area field thingy Buttons are now larger.</p>
                    <p>4.8: fixed revive because it would freeze the game.</p>
                    <p>4.7: major major major major visual overhaul! dded animated backgrounds, particle effects, smoother animations, improved UI styling, and enhanced entity designs. player has a directional pointer. projectiles have cool trails</p>
                    <p>4.6: revamped enemy tracking and speed, upgraded AI and smarter enemies.</p>
                    <p>4.5: added endless and hell mode. polished everything and added to github</p>
                    <p>4.4: added changelog</p>
                    <p>4.3: fixed aimbot because it kept crashing the testing environment</p>
                    <p>4.2: added aimbot with secret code</p>
                    <p>4.1: rewrote the entire code cause it literally just wouldn't run</p>
                    <p>4.0: added revive feature with secret code</p>
                    <p>3.4: changed overall look to entities with more shapes and colors</p>
                    <p>3.3: bugfixes</p>
                    <p>3.2: added more friendly arrow movement</p>
                    <p>3.1: fixed mouse control mode</p>
                    <p>3.0: added mouse control mode</p>
                    <p>2.2: attempted background music, failed miserably</p>
                    <p>2.0: brand new UI with new colors and faces to enemies (AHH ITS SO GOOD)</p>
                    <p>1.4: bugfixing cause it broken</p>
                    <p>1.3: updated beam attack UI cause it looks like Microsoft paint</p>
                    <p>1.2: new attack mode: beam</p>
                    <p>1.1: new UI cause old one was hella ugly</p>
                    <p>1.0: initial release, what did you expect</p>
                </div>
                <button id="closeChangelogButton" class="button-close" type="button">&times;</button>
            </div>

            <div class="controls-info">
                <p class="controls-heading">Controls</p>
                <p><span class="controls-accent">Player:</span> WASD to Move, Space/Click to Shoot, B for Beam, X for Smash, M for Mouse Aim</p>
                <p class="controls-detail">Beam: 21s, Smash: 37.5s. Targets hurt on touch!</p>
            </div>

            <div id="leaderboardContainer" class="hidden">
                <h2 class="leaderboard-title">Local Leaderboard</h2>
                <ul id="leaderboardList"></ul>
                <p class="leaderboard-hint">(Scores are saved in this browser only)</p>
            </div>
        </div>
    </div>


    <script>
    function normalizeAngle(angle) {
        while (angle > Math.PI) { angle -= 2 * Math.PI; }
        while (angle < -Math.PI) { angle += 2 * Math.PI; }
        return angle;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stageDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const healthText = document.getElementById('healthText');
        const healthBarInner = document.getElementById('healthBarInner');
        const tempPopup = document.getElementById('tempPopup');
        const aimbotButton = document.getElementById('aimbotButton');
        const changelogButton = document.getElementById('changelogButton');
        const invincibilityButton = document.getElementById('invincibilityButton');
        const plusHealthButton = document.getElementById('plusHealthButton');
        const finishGameButton = document.getElementById('finishGameButton');
        const changelogPopup = document.getElementById('changelogPopup');
        const closeChangelogButton = document.getElementById('closeChangelogButton');
        const closeMessageBoxButton = document.getElementById('closeMessageBoxButton');
        const bulletCountDisplay = document.getElementById('bulletCountDisplay');
        const versionDisplay = document.getElementById('versionDisplay');

        const licensePopup = document.getElementById('licensePopup');
        const licenseKeyInput = document.getElementById('licenseKeyInput');
        const submitLicenseKeyButton = document.getElementById('submitLicenseKeyButton');
        const licenseErrorText = document.getElementById('licenseErrorText');
        const namePopup = document.getElementById('namePopup');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitPlayerNameButton = document.getElementById('submitPlayerNameButton');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingWelcomeText = document.getElementById('loadingWelcomeText');
        const loadingProgressBar = document.getElementById('loadingProgressBar');
        const mainGameContent = document.getElementById('mainGameContent');

        // NEW: Admin Popup Elements
        const adminPasswordPopup = document.getElementById('adminPasswordPopup');
        const adminPasswordInput = document.getElementById('adminPasswordInput');
        const submitAdminPasswordButton = document.getElementById('submitAdminPasswordButton');
        const closeAdminPasswordPopup = document.getElementById('closeAdminPasswordPopup');
        const adminPasswordError = document.getElementById('adminPasswordError');

        const themeCards = document.querySelectorAll('[data-theme-option]');
        const activeThemeName = document.getElementById('activeThemeName');
        const themeNames = {
            aurora: 'Aurora',
            supernova: 'Supernova',
            nebula: 'Nebula Drift',
            oasis: 'Solar Oasis',
            endless: 'Endless Drift',
            inferno: 'Inferno'
        };
        let storedTheme = localStorage.getItem('ssbb_theme') || 'aurora';
        let activeTheme = storedTheme;

        function applyTheme(theme, { persist = true, fromMode = false } = {}) {
            if (!themeNames[theme]) {
                theme = 'aurora';
            }
            document.body.dataset.theme = theme;
            activeTheme = theme;
            themeCards.forEach(card => {
                card.classList.toggle('active', card.dataset.themeOption === theme);
            });
            if (activeThemeName && themeNames[theme]) {
                activeThemeName.textContent = themeNames[theme];
            }
            if (persist) {
                storedTheme = theme;
                localStorage.setItem('ssbb_theme', theme);
            }
            if (!fromMode) {
                document.body.classList.remove('hell-mode', 'endless-mode');
            }
        }

        applyTheme(storedTheme, { persist: false });

        themeCards.forEach(card => {
            card.addEventListener('click', () => {
                const themeOption = card.dataset.themeOption;
                if (!themeOption || themeOption === activeTheme) {
                    return;
                }
                applyTheme(themeOption);
                showTemporaryPopup(`${themeNames[themeOption] || 'Custom'} theme engaged!`);
            });
        });

        const GAME_VERSION = "v6.5";
        let CANVAS_WIDTH = 800;
        let CANVAS_HEIGHT = 600;
        const PLAYER_WIDTH = 30;
        const PLAYER_HEIGHT = 30;
        const PROJECTILE_WIDTH = 10;
        const PROJECTILE_HEIGHT = 5;
        const ENEMY_PROJECTILE_WIDTH = 8;
        const ENEMY_PROJECTILE_HEIGHT = 8;
        const POWERUP_SIZE = 25;
        const BEAM_THICKNESS = 25;
        const TARGET_SIZE_MIN = 20;
        const TARGET_SIZE_MAX = 35;
        const TARGET_BASE_SPEED = 0.25;
        const TARGET_SPEED_INCREMENT = 0.03;
        const TARGET_CONTACT_DAMAGE = 8;
        const SCORE_PER_HIT = 55;
        const SCORE_PER_BEAM_FRAME = 4;
        const SCORE_PER_SMASH_HIT = 30;
        const MAX_WAVES_PER_LEVEL = 3;
        const COMPLETION_STAGE = 10;
        const BEAM_CHARGE_MAX = 21000;
        const SMASH_CHARGE_MAX = 37500;
        const BEAM_ACTIVE_DURATION = 1800;
        const POWERUP_SPAWN_INTERVAL_MIN = 10000;
        const POWERUP_SPAWN_INTERVAL_MAX = 20000;
        const HEALTH_PACK_GREEN_SPAWN_MIN = 10000;
        const HEALTH_PACK_GREEN_SPAWN_MAX = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MIN = 15000;
        const HEALTH_PACK_GOLDEN_SPAWN_MAX = 20000;
        const POWERUP_LIFETIME = 8000;
        const POWERUP_DURATION = 7000;
        const MAX_BULLET_COUNT = 5;
        const HELL_MODE_SPAWN_INTERVAL = 1200;
        const HELL_MODE_EXTRA_SPAWN_COUNT = 2;
        const REVIVE_INVULNERABILITY_DURATION = 3000;

        let gameRunning = false;
        let currentStage = 1;
        let currentWave = 1;
        let targetsPerWaveBase = 2;
        let gameTargets = [];
        let enemyProjectiles = [];
        let powerUps = [];
        let playerScore = 0;
        let mouseAimActive = false;
        let mouseX = 0;
        let mouseY = 0;
        let aimbotActive = false;
        const AIMBOT_SHOOT_DELAY = 35;
        let currentPopupAction = null;
        let gameMode = 'normal';
        let nextPowerUpSpawnTime = 0;
        let nextGreenHealthPackSpawnTime = 0;
        let nextGoldenHealthPackSpawnTime = 0;
        let nextHellSpawnTime = 0;
        let globalPlayerName = "Player";

        // NEW: Admin Password State
        let pendingAdminAction = null;
        const ADMIN_PASSWORD = "admin123"; // <-- YOU CAN CHANGE THE PASSWORD HERE
        let isAdminAccessGranted = false; // <-- NEW: Tracks if admin is unlocked

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const codeInputSection = document.getElementById('codeInputSection');
        const codeInput = document.getElementById('codeInput');
        const submitCodeButton = document.getElementById('submitCodeButton');
        const cancelCodeButton = document.getElementById('cancelCodeButton');
        const deathOptions = document.getElementById('deathOptions');
        const completionOptions = document.getElementById('completionOptions');
        const hellModeButton = document.getElementById('hellModeButton');
        const endlessModeButton = document.getElementById('endlessModeButton');
        const hellConfirmOptions = document.getElementById('hellConfirmOptions');
        const confirmHellButton = document.getElementById('confirmHellButton');
        const cancelHellButton = document.getElementById('cancelHellButton');
        const actionButton1 = document.getElementById('actionButton1');
        const actionButton2 = document.getElementById('actionButton2');
        const leaderboardContainer = document.getElementById('leaderboardContainer');
        const leaderboardList = document.getElementById('leaderboardList');

        const FOX_TYPES = {
            "Ranger": {
                color: "hsl(25, 85%, 55%)",
                accentColor: "hsl(0, 0%, 95%)",
                eyeColor: "hsl(190, 100%, 30%)",
                shieldColor: "hsla(200, 100%, 80%, 0.3)",
                invulnerableShieldColor: "hsla(50, 100%, 70%, 0.7)",
                engineColor: "hsl(30, 100%, 50%)",
                baseSpeed: 3.8,
                health: 100,
                baseShootDelay: 220,
                projectileSpeed: 6.0,
                projectileColor: "hsl(50, 100%, 60%)"
            }
        };

        const keysPressed = {};
        versionDisplay.textContent = GAME_VERSION;

        function isGameEffectivelyPaused() {
            if (!mainGameContent.classList.contains('hidden')) {
                 // UPDATED: Added adminPasswordPopup
                 return messageBox.classList.contains('visible') ||
                        changelogPopup.classList.contains('visible') ||
                        adminPasswordPopup.classList.contains('visible');
            }
            return true;
        }

        let particles = [];
        function createParticle(x, y, count, color, sizeRange, speedRange, lifeRange, angleSpread = Math.PI * 2) {
            for (let i = 0; i < count; i++) {
                const targetY = typeof mouseY === 'number' ? mouseY : y;
                const targetX = typeof mouseX === 'number' ? mouseX : x + 1;
                const angle = (Math.random() - 0.5) * angleSpread + Math.atan2(targetY - y, targetX - x);
                const speed = Math.random() * (speedRange[1] - speedRange[0]) + speedRange[0];
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    size: Math.random() * (sizeRange[1] - sizeRange[0]) + sizeRange[0],
                    life: Math.random() * (lifeRange[1] - lifeRange[0]) + lifeRange[0], maxLife: lifeRange[1],
                    color: color, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function updateAndDrawParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * (deltaTime / 16.67); p.y += p.vy * (deltaTime / 16.67);
                p.vx *= 0.98; p.vy *= 0.98; p.life -= deltaTime; p.rotation += p.rotationSpeed * (deltaTime / 16.67);
                if (p.life <= 0) { particles.splice(i, 1); } else {
                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color; const opacity = Math.max(0, p.life / p.maxLife);
                    ctx.globalAlpha = opacity * 0.8; ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();
                }
            }
            ctx.globalAlpha = 1;
        }

        window.addEventListener('keydown', (e) => {
            // UPDATED: Added adminPasswordInput
            const activePopupInput = document.activeElement === licenseKeyInput ||
                                     document.activeElement === playerNameInput ||
                                     (document.activeElement === codeInput && !codeInputSection.classList.contains('hidden')) ||
                                     document.activeElement === adminPasswordInput;

            if (activePopupInput) {
                if (e.code === 'Enter') {
                    e.preventDefault();
                    if (document.activeElement === licenseKeyInput) submitLicenseKeyButton.click();
                    else if (document.activeElement === playerNameInput) submitPlayerNameButton.click();
                    else if (document.activeElement === codeInput) submitCodeButton.click();
                    else if (document.activeElement === adminPasswordInput) submitAdminPasswordButton.click(); // NEW
                }
                return;
            }


            if (e.code === 'Escape') {
                if (changelogPopup.classList.contains('visible')) {
                    hidePopup(changelogPopup); currentPopupAction = null; return;
                }
                // NEW: Handle admin popup escape
                if (adminPasswordPopup.classList.contains('visible')) {
                    hidePopup(adminPasswordPopup);
                    currentPopupAction = null;
                    pendingAdminAction = null;
                    return;
                }
                if (messageBox.classList.contains('visible')) {
                    if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                        messageText.textContent = "Game Over!";
                        codeInputSection.classList.add('hidden');
                        deathOptions.classList.remove('hidden');
                        currentPopupAction = 'game_over_options';
                        return;
                    } else if (['aimbot', 'hell_confirm', 'game_complete'].includes(currentPopupAction)) {
                         hidePopup(messageBox); currentPopupAction = null; return;
                    }
                }
            }

            if (isGameEffectivelyPaused() && !mainGameContent.classList.contains('hidden')) {
                 if (e.code === 'Space' || e.code.startsWith('Arrow') || ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyB', 'KeyX', 'KeyM'].includes(e.code)) {
                     e.preventDefault();
                 }
                 return;
            } else if (licensePopup.classList.contains('visible') || namePopup.classList.contains('visible') || loadingScreen.classList.contains('visible')) {
                if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyX', 'KeyM'].includes(e.code)) {
                    e.preventDefault();
                }
                return;
            }


            keysPressed[e.code] = true;
            if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) { e.preventDefault(); }
            if (e.code === 'KeyM') { toggleMouseAim(); }
            if (e.code === 'KeyX' && player1 && player1.smashReady && !player1.isSmashing) { player1.fireSmash(); }
        });
        window.addEventListener('keyup', (e) => { keysPressed[e.code] = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (isGameEffectivelyPaused()) return;
            const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('click', () => {
            if (isGameEffectivelyPaused()) return;
            if (mouseAimActive && !aimbotActive && player1 && player1.health > 0) { player1.shoot(true); }
        });

        function showPopup(element) {
            element.classList.remove('hidden');
            setTimeout(() => element.classList.add('visible'), 10);
        }
        function hidePopup(element) {
            element.classList.remove('visible');
            setTimeout(() => element.classList.add('hidden'), 600);
        }

        submitLicenseKeyButton.addEventListener('click', () => {
            if (licenseKeyInput.value.trim() === "64446644") {
                licenseErrorText.classList.add('hidden');
                licenseKeyInput.classList.remove('input-error');
                hidePopup(licensePopup);
                setTimeout(() => {
                    showPopup(namePopup);
                    playerNameInput.focus();
                }, 300);
            } else {
                licenseErrorText.classList.remove('hidden');
                licenseKeyInput.classList.add('input-error');
                setTimeout(() => licenseKeyInput.classList.remove('input-error'), 300);
                licenseKeyInput.value = "";
                licenseKeyInput.focus();
            }
        });

        submitPlayerNameButton.addEventListener('click', () => {
            globalPlayerName = playerNameInput.value.trim() || "Player";
            hidePopup(namePopup);
            setTimeout(() => {
                loadingWelcomeText.textContent = `Welcome to ShootyShooty BangBang Plus, ${globalPlayerName}! We're loading your game environment, please wait.`;
                showPopup(loadingScreen);
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 1;
                    loadingProgressBar.style.width = `${progress}%`;
                    if (progress >= 100) {
                        clearInterval(interval);
                        hidePopup(loadingScreen);
                        setTimeout(startGame, 300);
                    }
                }, 100); // Increased loading time slightly
            }, 300);
        });


        aimbotButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && currentPopupAction !== 'aimbot') return;
            if (aimbotActive) { aimbotActive = false; showTemporaryPopup("Aimbot Deactivated!"); return; }
            messageText.textContent = "Enter Admin Code:";
            codeInputSection.classList.remove('hidden'); deathOptions.classList.add('hidden');
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden');
            showPopup(messageBox); codeInput.value = ""; codeInput.focus(); currentPopupAction = 'aimbot';
        });

        actionButton2.addEventListener('click', () => {
            if (currentPopupAction === 'game_over_options') {
                messageText.textContent = "Enter Revive Code:";
                codeInputSection.classList.remove('hidden');
                deathOptions.classList.add('hidden');
                codeInput.value = "";
                codeInput.focus();
                currentPopupAction = 'revive_code_input';
            }
        });

        changelogButton.addEventListener('click', () => {
            if (isGameEffectivelyPaused() && !changelogPopup.classList.contains('visible')) return;
            showPopup(changelogPopup); currentPopupAction = 'changelog';
        });

        // --- NEW ADMIN ACCESS LOGIC ---

        function requestAdminAccess(action) {
            // Don't show if another popup is already active
            if (isGameEffectivelyPaused() && !adminPasswordPopup.classList.contains('visible')) return;

            pendingAdminAction = action;
            adminPasswordInput.value = "";
            adminPasswordError.classList.add('hidden');
            adminPasswordInput.classList.remove('input-error');
            showPopup(adminPasswordPopup);
            adminPasswordInput.focus();
            currentPopupAction = 'admin_password'; // To help with pause logic
        }

        function executeAdminAction(action) {
            if (!player1 && (action === 'invincibility' || action === 'health')) return;

            switch (action) {
                case 'invincibility':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.isDivineProtectionActive = !player1.isDivineProtectionActive;
                        if (player1.isDivineProtectionActive) {
                            player1.health = 1000;
                            player1.initialHealth = 1000;
                            showTemporaryPopup("Divine Protection Activated!");
                        } else {
                            player1.health = Math.min(player1.health, player1.type.health);
                            player1.initialHealth = player1.type.health;
                            showTemporaryPopup("Divine Protection Deactivated!");
                        }
                        updateUI();
                    }
                    break;
                case 'health':
                    if (player1 && !isGameEffectivelyPaused()) {
                        player1.health += 100;
                        if (player1.isDivineProtectionActive) {
                            player1.health = Math.min(player1.health, 1000);
                        } else {
                            player1.initialHealth = Math.max(player1.initialHealth, player1.health, player1.type.health);
                        }
                        updateUI();
                        showTemporaryPopup("+100 Health!");
                    }
                    break;
                case 'finish':
                     if (!isGameEffectivelyPaused()) {
                        showGameCompletionPopup();
                     }
                    break;
            }
        }

        // UPDATED: Re-wired admin buttons to new password prompt
        invincibilityButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('invincibility');
            } else {
                requestAdminAccess('invincibility');
            }
        });

        plusHealthButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('health');
            } else {
                requestAdminAccess('health');
            }
        });

        finishGameButton.addEventListener('click', () => {
            if (isAdminAccessGranted) {
                executeAdminAction('finish');
            } else {
                requestAdminAccess('finish');
            }
        });

        // NEW: Event listeners for admin password popup
        closeAdminPasswordPopup.addEventListener('click', () => {
            hidePopup(adminPasswordPopup);
            pendingAdminAction = null;
            currentPopupAction = null;
        });

        submitAdminPasswordButton.addEventListener('click', () => {
            if (adminPasswordInput.value === ADMIN_PASSWORD) {
                isAdminAccessGranted = true; // <-- Grant access
                hidePopup(adminPasswordPopup);
                executeAdminAction(pendingAdminAction);
                pendingAdminAction = null;
                currentPopupAction = null;
                adminPasswordInput.value = "";
                adminPasswordError.classList.add('hidden');
                adminPasswordInput.classList.remove('input-error');
                showTemporaryPopup("Admin Access Granted!"); // Notify user
            } else {
                adminPasswordError.classList.remove('hidden');
                adminPasswordInput.classList.add('input-error');
                setTimeout(() => adminPasswordInput.classList.remove('input-error'), 300);
                adminPasswordInput.value = "";
                adminPasswordInput.focus();
            }
        });

        // --- END NEW ADMIN LOGIC ---


        hellModeButton.addEventListener('click', () => {
            messageText.textContent = "Warning: Hell Mode is for HIGHLY ADVANCED PLAYERS ONLY. Proceed?";
            completionOptions.classList.add('hidden'); hellConfirmOptions.classList.remove('hidden');
            showPopup(messageBox); currentPopupAction = 'hell_confirm';
        });

        endlessModeButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'endless';
            document.body.classList.remove('hell-mode'); document.body.classList.add('endless-mode');
            applyTheme('endless', { persist: false, fromMode: true });
            showTemporaryPopup("Thanks for playing! Enjoy Endless Mode!");
            player1.reset(true); initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        confirmHellButton.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; gameMode = 'hell';
            document.body.classList.remove('endless-mode'); document.body.classList.add('hell-mode');
            applyTheme('inferno', { persist: false, fromMode: true });
            stageDisplay.textContent = "HELL MODE ENABLED";
            player1.reset(true); player1.health = 200; player1.initialHealth = 200;
            targetsPerWaveBase = 3;
            initializeStage(1, 1); gameRunning = true;
            lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        cancelHellButton.addEventListener('click', () => {
            messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            currentPopupAction = 'game_complete';
        });

        closeChangelogButton.addEventListener('click', () => { hidePopup(changelogPopup); currentPopupAction = null; });
        closeMessageBoxButton.addEventListener('click', () => {
            hidePopup(messageBox);
            if (currentPopupAction === 'game_over_options' || currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                 leaderboardContainer.classList.add('hidden');
            }
            currentPopupAction = null;
        });

        submitCodeButton.addEventListener('click', () => {
            const code = codeInput.value.trim().toLowerCase();
            if (currentPopupAction === 'aimbot') {
                if (code === "ultrasecretpassword") {
                    aimbotActive = true;
                    showTemporaryPopup("Aimbot Enabled!");
                } else {
                    showTemporaryPopup("Incorrect Code.");
                }
                hidePopup(messageBox); currentPopupAction = null;
            } else if (currentPopupAction === 'revive_code_input') {
                if (code === "ultrasecretpasscode") {
                    player1.reset(false);
                    player1.health = player1.isDivineProtectionActive ? 1000 : player1.initialHealth;
                    player1.isInvulnerable = true; player1.invulnerableUntil = Date.now() + REVIVE_INVULNERABILITY_DURATION;
                    gameRunning = true; lastFrameTime = performance.now();
                    hidePopup(messageBox); leaderboardContainer.classList.add('hidden');
                    requestAnimationFrame(gameLoop); currentPopupAction = null;
                } else {
                    messageText.textContent = "Incorrect Code. Try Respawn?";
                    codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                    currentPopupAction = 'revive_failed';
                }
            }
            codeInput.value = "";
        });

        cancelCodeButton.addEventListener('click', () => {
            if (currentPopupAction === 'revive_code_input' || currentPopupAction === 'revive_failed') {
                messageText.textContent = "Game Over!";
                codeInputSection.classList.add('hidden'); deathOptions.classList.remove('hidden');
                currentPopupAction = 'game_over_options';
            } else {
                hidePopup(messageBox); currentPopupAction = null;
            }
        });

        function showTemporaryPopup(message) {
            tempPopup.textContent = message;
            showPopup(tempPopup);
            setTimeout(() => {
                hidePopup(tempPopup);
            }, 2500);
        };
        function toggleMouseAim() {
            if (isGameEffectivelyPaused()) return;
            mouseAimActive = !mouseAimActive; showTemporaryPopup(mouseAimActive ? "Mouse Aim Activated!" : "Mouse Aim Deactivated!");
            canvas.style.cursor = mouseAimActive ? 'crosshair' : 'default';
            if (mouseAimActive && aimbotActive) { showTemporaryPopup("Aimbot is active, mouse aim will be overridden by Aimbot targeting."); }
        };

        const POWERUP_TYPES = {
            MULTI_SHOT: 'multiShot',
            RAPID_FIRE: 'rapidFire',
            SHIELD: 'shield',
            SPEED_BOOST: 'speedBoost',
            HEALTH_PACK_GREEN: 'healthPackGreen',
            HEALTH_PACK_GOLDEN: 'healthPackGolden'
        };

        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.size = POWERUP_SIZE;
                this.createdAt = Date.now(); this.lifetime = POWERUP_LIFETIME;
                this.pulseSpeed = 0.05; this.currentPulse = 0;

                switch (this.type) {
                    case POWERUP_TYPES.MULTI_SHOT: this.baseColor = 'rgb(34, 197, 94)'; this.pulseColor = 'rgb(134, 239, 172)'; this.symbol = ''; break;
                    case POWERUP_TYPES.RAPID_FIRE: this.baseColor = 'rgb(251, 146, 60)'; this.pulseColor = 'rgb(253, 186, 116)'; this.symbol = ''; break;
                    case POWERUP_TYPES.SHIELD: this.baseColor = 'rgb(59, 130, 246)'; this.pulseColor = 'rgb(147, 197, 253)'; this.symbol = ''; break;
                    case POWERUP_TYPES.SPEED_BOOST: this.baseColor = 'rgb(168, 85, 247)'; this.pulseColor = 'rgb(216, 180, 254)'; this.symbol = ''; break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN: this.baseColor = 'hsl(120, 60%, 50%)'; this.pulseColor = 'hsl(120, 60%, 70%)'; this.symbol = ''; break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN: this.baseColor = 'hsl(50, 100%, 50%)'; this.pulseColor = 'hsl(50, 100%, 70%)'; this.symbol = ''; break;
                    default: this.baseColor = 'grey'; this.pulseColor = 'lightgrey'; this.symbol = '?';
                }
            }
            draw() {
                this.currentPulse = (this.currentPulse + this.pulseSpeed) % (Math.PI * 2);
                const scaleFactor = 1 + Math.sin(this.currentPulse) * 0.1;
                const currentSize = this.size * scaleFactor;
                ctx.fillStyle = this.pulseColor;
                ctx.globalAlpha = 0.5 * (1 + Math.sin(this.currentPulse) * 0.5);
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 1.8, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = this.baseColor;
                ctx.beginPath(); ctx.arc(this.x + this.size / 2, this.y + this.size / 2, currentSize / 2.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${currentSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x + this.size / 2, this.y + this.size / 2);
            }
            update(deltaTime) { return Date.now() - this.createdAt > this.lifetime; }
        }

        class Target {
            constructor(x, y, type) {
                this.type = type; this.size = Math.random() * (TARGET_SIZE_MAX - TARGET_SIZE_MIN) + TARGET_SIZE_MIN;
                this.x = x; this.y = y; this.width = this.size; this.height = this.size;
                let speedMultiplier = 1.0 + (Math.random() - 0.5) * 0.3;
                let healthMultiplier = 1.0;
                let projectileSpeedMultiplier = 1.0;
                let shootCooldownFactor = 1.0;

                if (gameMode === 'hell') {
                    speedMultiplier *= 3.4; healthMultiplier = 2.2; projectileSpeedMultiplier = 1.15; shootCooldownFactor = 0.65;
                } else if (gameMode === 'endless') {
                    speedMultiplier *= 1.25; healthMultiplier = 1.2;
                } else {
                    speedMultiplier *= 0.8; healthMultiplier = 0.7;
                }

                this.speed = (TARGET_BASE_SPEED + (currentWave-1) * TARGET_SPEED_INCREMENT + (currentStage-1) * TARGET_SPEED_INCREMENT * 2) * speedMultiplier;
                this.projectileColor = "rgb(220, 100, 100)";
                this.projectileDamage = (gameMode === 'hell') ? 15 : 10;
                this.repulsionForce = 0.65; this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;

                switch(type) {
                    case 'purple':
                        this.color = "hsl(280, 70%, 60%)"; this.faceColor = "hsl(280, 70%, 40%)";
                        this.health = (40 + currentWave * 5 + currentStage * 10) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 450 : (gameMode === 'endless' ? 1500 : 1800)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 2.8 * projectileSpeedMultiplier;
                        break;
                    case 'orange':
                        this.color = "hsl(30, 80%, 60%)"; this.faceColor = "hsl(30, 80%, 40%)";
                        this.health = (30 + currentWave * 4 + currentStage * 8) * healthMultiplier;
                        this.shootCooldown = (gameMode === 'hell' ? 300 : (gameMode === 'endless' ? 750 : 900)) * shootCooldownFactor;
                        this.canShoot = true; this.enemyProjectileSpeed = 3.2 * projectileSpeedMultiplier;
                        break;
                    case 'green':
                        this.color = "hsl(140, 70%, 50%)"; this.faceColor = "hsl(140, 70%, 30%)";
                        this.health = (50 + currentWave * 7 + currentStage * 12) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 1.7 : 1.5);
                        this.canShoot = false;
                        break;
                    case 'blue':
                        this.color = "hsl(210, 70%, 60%)"; this.faceColor = "hsl(210, 70%, 40%)";
                        this.health = (20 + currentWave * 3 + currentStage * 5) * healthMultiplier;
                        this.speed *= (gameMode === 'hell' ? 0.6 : 0.55);
                        this.canShoot = false;
                        break;
                    default:
                        this.color = "hsl(0, 0%, 50%)"; this.faceColor = "hsl(0, 0%, 30%)";
                        this.health = (25 + currentWave * 4 + currentStage * 4) * healthMultiplier;
                        this.canShoot = false;
                }
                this.initialHealth = this.health; this.lastShotTime = 0;
                this.hitFlashDuration = 100; this.lastHitTime = 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                let drawColor = this.color; if (Date.now() - this.lastHitTime < this.hitFlashDuration) { drawColor = "white"; }
                ctx.fillStyle = drawColor; ctx.beginPath();
                if (this.type === 'purple') { const s = this.width / 2; ctx.moveTo(-s, -s); ctx.lineTo(s, -s); ctx.lineTo(s*0.8, -s*0.2); ctx.lineTo(s, s); ctx.lineTo(-s, s); ctx.lineTo(-s*0.8, s*0.2); ctx.closePath();
                } else if (this.type === 'orange') { for (let i = 0; i < 5; i++) { ctx.lineTo( (this.width / 2) * Math.cos( (Math.PI*2/5) * i - Math.PI/2 ), (this.height / 2) * Math.sin( (Math.PI*2/5) * i - Math.PI/2 )); } ctx.closePath();
                } else if (this.type === 'green') { ctx.moveTo(0, -this.height / 2); ctx.lineTo(this.width / 2, this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.closePath();
                } else { const r = this.width / 5; ctx.moveTo(-this.width/2 + r, -this.height/2); ctx.arcTo(this.width/2, -this.height/2, this.width/2, this.height/2, r); ctx.arcTo(this.width/2, this.height/2, -this.width/2, this.height/2, r); ctx.arcTo(-this.width/2, this.height/2, -this.width/2, -this.height/2, r); ctx.arcTo(-this.width/2, -this.height/2, this.width/2, -this.height/2, r); ctx.closePath(); }
                ctx.fill();
                ctx.fillStyle = this.faceColor; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)"; ctx.beginPath(); ctx.arc(0, -this.height * 0.15, this.width / 12, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                if (this.health > 0) {
                    const hBW = this.width * 0.8;
                    const hBH = 4;
                    const healthPercentage = (this.health / this.initialHealth) * 100;
                    const hP = Math.max(0, Math.min(1, this.health / this.initialHealth));

                    const barX = this.x + this.width * 0.1;
                    const barY = this.y - hBH - 3;

                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, hBW, hBH);

                    let healthBarColor = 'hsl(0, 70%, 50%)';
                    if (healthPercentage > 60) {
                        healthBarColor = 'hsl(120, 70%, 50%)';
                    } else if (healthPercentage > 25) {
                        healthBarColor = 'hsl(60, 70%, 50%)';
                    }
                    ctx.fillStyle = healthBarColor;
                    ctx.fillRect(barX, barY, hBW * hP, hBH);

                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(barX, barY, hBW, hBH);
                }
            }
            update(playerX, playerY, deltaTime, otherTargets) {
                const dtFactor = deltaTime / (1000/60); this.rotation += this.rotationSpeed * dtFactor;
                const dxToPlayer = playerX + PLAYER_WIDTH/2-(this.x+this.width/2); const dyToPlayer = playerY + PLAYER_HEIGHT/2-(this.y+this.height/2);
                const distToPlayer = Math.sqrt(dxToPlayer*dxToPlayer + dyToPlayer*dyToPlayer);
                let moveX = 0; let moveY = 0; if (distToPlayer > 0) { moveX += (dxToPlayer/distToPlayer)*this.speed; moveY += (dyToPlayer/distToPlayer)*this.speed; }
                let repelX = 0; let repelY = 0;
                otherTargets.forEach(other => {
                    if (other === this) return; const dx = this.x - other.x; const dy = this.y - other.y;
                    const distSq = dx*dx + dy*dy; const minDist = (this.size + other.size) * 0.6;
                    if (distSq < minDist*minDist && distSq > 0) { const dist = Math.sqrt(distSq); const force = this.repulsionForce * (1 - dist/minDist); repelX += (dx/dist)*force; repelY += (dy/dist)*force; }
                });
                this.x += (moveX + repelX) * dtFactor; this.y += (moveY + repelY) * dtFactor;
                this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH - this.width)); this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT - this.height));
                if (this.canShoot && Date.now() - this.lastShotTime > this.shootCooldown) {
                    this.lastShotTime = Date.now(); const aimDx = playerX+PLAYER_WIDTH/2-(this.x+this.width/2); const aimDy = playerY+PLAYER_HEIGHT/2-(this.y+this.height/2);
                    const aimDist = Math.sqrt(aimDx*aimDx + aimDy*aimDy); let sX=0,sY=0;
                    if(aimDist>0){sX=(aimDx/aimDist)*this.enemyProjectileSpeed;sY=(aimDy/aimDist)*this.enemyProjectileSpeed;}
                    enemyProjectiles.push(new EnemyProjectile(this.x+this.width/2, this.y+this.height/2, sX, sY, this.projectileColor, this.projectileDamage));
                }
            }
            takeDamage(amount) { this.health -= amount; this.lastHitTime = Date.now(); createParticle(this.x+this.width/2, this.y+this.height/2, 3, 'rgba(255,255,255,0.8)', [2,5], [1,3], [100,300]); if (this.health < 0) {this.health = 0;} }
        }

        class EnemyProjectile {
            constructor(x,y,sX,sY,c, damage = 10){
                this.x=x-ENEMY_PROJECTILE_WIDTH/2;this.y=y-ENEMY_PROJECTILE_HEIGHT/2; this.width=ENEMY_PROJECTILE_WIDTH;this.height=ENEMY_PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c; this.damage = damage;
                this.trail = []; this.maxTrailLength = (gameMode === 'hell') ? 8 : 5; this.rotation = Math.random() * Math.PI * 2;
                this.baseSpeed = Math.sqrt(sX*sX + sY*sY) || 0;
                this.curveStrength = 0.035;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.3 * (i / this.trail.length); ctx.fillStyle = `hsla(0, 100%, 70%, ${alpha})`; ctx.beginPath(); ctx.arc(point.x + this.width / 2, point.y + this.height / 2, this.width / 2.5 * (i / this.trail.length), 0, Math.PI * 2); ctx.fill(); }
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                ctx.fillStyle = "rgba(255, 50, 50, 0.5)"; ctx.beginPath(); ctx.arc(0, 0, this.width / 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(0,0,this.width/2.2,0,Math.PI*2); ctx.fill();
                ctx.restore();
            }
            update(deltaTime){
                const dtFactor=deltaTime/(1000/60);
                if (player1 && player1.health > 0 && this.baseSpeed > 0) {
                    const projectileCenterX = this.x + this.width / 2;
                    const projectileCenterY = this.y + this.height / 2;
                    const playerCenterX = player1.x + player1.width / 2;
                    const playerCenterY = player1.y + player1.height / 2;
                    const dx = playerCenterX - projectileCenterX;
                    const dy = playerCenterY - projectileCenterY;
                    const distance = Math.sqrt(dx*dx + dy*dy) || 1;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(this.speedY, this.speedX);
                    let angleDiff = normalizeAngle(targetAngle - currentAngle);
                    const maxTurn = (this.curveStrength / (1 + distance / 400)) * dtFactor;
                    angleDiff = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
                    const newAngle = currentAngle + angleDiff;
                    this.speedX = Math.cos(newAngle) * this.baseSpeed;
                    this.speedY = Math.sin(newAngle) * this.baseSpeed;
                }
                this.x+=this.speedX*dtFactor; this.y+=this.speedY*dtFactor;
                this.rotation += 0.1 * dtFactor;

                if (this.x > CANVAS_WIDTH + this.width * 2 || this.x < -this.width * 2 || this.y > CANVAS_HEIGHT + this.height * 2 || this.y < -this.height * 2) {
                    const index = enemyProjectiles.indexOf(this);
                    if (index > -1) {
                        enemyProjectiles.splice(index, 1);
                    }
                }

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }
            }
        }

        class FoxPlayer {
            constructor(x, y, foxTypeName, controls) {
                this.type = FOX_TYPES[foxTypeName]; this.x = x; this.y = y; this.width = PLAYER_WIDTH; this.height = PLAYER_HEIGHT;
                this.color = this.type.color;
                this.speed = this.type.baseSpeed;
                this.shootDelayBase = this.type.baseShootDelay;
                this.health = (gameMode === 'hell') ? 200 : this.type.health; this.initialHealth = this.health;
                this.controls = controls; this.projectiles = []; this.lastShotTime = 0;
                this.beamCharge = 0; this.beamChargeMax = BEAM_CHARGE_MAX; this.beamReady = false;
                this.isFiringBeam = false; this.beamActiveDuration = BEAM_ACTIVE_DURATION; this.beamActiveStartTime = 0;
                this.beamDamagePerFrame = 2.5; this.smashCharge = 0; this.smashChargeMax = SMASH_CHARGE_MAX; this.smashReady = false;
                this.isSmashing = false; this.smashRadius = 0; this.smashMaxRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
                this.smashExpansionSpeed = this.smashMaxRadius / 50; this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0;
                this.beamTargetAngle = 0;
                this.aimbotTarget = null; this.bulletCount = 1; this.engineParticles = [];
                this.engineParticleTimer = 0; this.engineParticleInterval = 50; this.currentSpeed = 0;
                this.shieldOpacity = 0; this.lastDamageTime = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.isDivineProtectionActive = false;
                this.rapidFireActiveUntil = 0;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.aimAngle);

                this.engineParticles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.opacity;
                    ctx.beginPath();
                    const localX = p.x - (this.x + this.width / 2);
                    const localY = p.y - (this.y + this.height / 2);
                    ctx.arc(localX, localY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                ctx.font = `${this.height * 0.95}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText('', 0, 0);


                const shieldPath = () => {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.7, 0, Math.PI * 2);
                    ctx.closePath();
                };

                let currentShieldColor = this.type.shieldColor;
                let shieldActive = false;

                if (this.isInvulnerable) {
                    currentShieldColor = this.type.invulnerableShieldColor;
                    shieldActive = true;
                } else if (Date.now() < this.shieldActiveUntil) {
                    currentShieldColor = "hsla(180, 100%, 70%, 0.7)";
                    shieldActive = true;
                } else if (this.isDivineProtectionActive) {
                     currentShieldColor = "hsla(270, 100%, 70%, 0.7)";
                     shieldActive = true;
                } else if (this.shieldOpacity > 0) {
                    shieldActive = true;
                }

                if (shieldActive) {
                    ctx.strokeStyle = currentShieldColor;
                    ctx.lineWidth = (this.isInvulnerable || Date.now() < this.shieldActiveUntil || this.isDivineProtectionActive) ? 4 : 3;
                    ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 80) * 0.4;
                    shieldPath();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();

                if (aimbotActive && this.aimbotTarget) { ctx.strokeStyle = "rgba(255,0,0,0.6)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x+this.width/2,this.y+this.height/2); ctx.lineTo(this.aimbotTarget.x+this.aimbotTarget.width/2,this.aimbotTarget.y+this.aimbotTarget.height/2); ctx.stroke(); }
                if (this.isFiringBeam) {
                    ctx.save(); ctx.translate(this.x+this.width/2,this.y+this.height/2);
                    ctx.rotate(this.beamTargetAngle);
                    const beamLength = CANVAS_WIDTH*1.5;
                    let gradBeam = ctx.createLinearGradient(0,0,beamLength,0); gradBeam.addColorStop(0,"rgba(255,255,220,1)"); gradBeam.addColorStop(0.1,"rgba(255,255,180,0.9)"); gradBeam.addColorStop(1,"rgba(255,200,100,0)");
                    ctx.fillStyle = gradBeam; ctx.fillRect(this.width/2, -BEAM_THICKNESS/4, beamLength, BEAM_THICKNESS/2);
                    let gradGlow = ctx.createLinearGradient(0,0,beamLength,0); gradGlow.addColorStop(0,"rgba(255,220,150,0.6)"); gradGlow.addColorStop(0.2,"rgba(255,200,100,0.4)"); gradGlow.addColorStop(1,"rgba(255,180,50,0)");
                    ctx.fillStyle = gradGlow; ctx.fillRect(this.width/2, -BEAM_THICKNESS/2, beamLength, BEAM_THICKNESS);
                    ctx.restore();
                }
                if (this.isSmashing) {
                    ctx.beginPath(); const smashProgress = this.smashRadius/this.smashMaxRadius;
                    ctx.strokeStyle = `rgba(255,100,50,${0.8-smashProgress*0.7})`; ctx.lineWidth = 10+15*(1-smashProgress); ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius,0,Math.PI*2); ctx.stroke();
                    ctx.fillStyle = `rgba(255,150,80,${0.5-smashProgress*0.4})`; ctx.arc(this.x+this.width/2,this.y+this.height/2,this.smashRadius*0.8,0,Math.PI*2); ctx.fill();
                }
            }

            updateChargeIndicators() {
                const beamBar = document.getElementById('beamChargeBar'); if (beamBar) { const bCP = this.beamCharge/this.beamChargeMax; beamBar.style.width = `${Math.min(100,bCP*100)}%`; beamBar.classList.toggle('ready',this.beamReady); }
                const smashBar = document.getElementById('smashChargeBar'); if (smashBar) { const sCP = this.smashCharge/this.smashChargeMax; smashBar.style.width = `${Math.min(100,sCP*100)}%`; smashBar.classList.toggle('ready',this.smashReady); }
            }

            updateAimDirection() {
                this.aimbotTarget = null;
                if (aimbotActive) {
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => { const dx = target.x+target.width/2-(this.x+this.width/2); const dy = target.y+target.height/2-(this.y+this.height/2); const distSq = dx*dx+dy*dy; if (distSq < minDistanceSq) { minDistanceSq = distSq; closestTarget = target; }});
                    if (closestTarget) { const dx = closestTarget.x+closestTarget.width/2-(this.x+this.width/2); const dy = closestTarget.y+closestTarget.height/2-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx); this.aimbotTarget = closestTarget; }
                } else if (mouseAimActive) {
                    const dx = mouseX-(this.x+this.width/2); const dy = mouseY-(this.y+this.height/2); this.aimAngle = Math.atan2(dy, dx);
                } else {
                    let keyAimDx = 0; let keyAimDy = 0;
                    if (keysPressed['ArrowLeft']) { keyAimDx = -1; } else if (keysPressed['ArrowRight']) { keyAimDx = 1;}
                    if (keysPressed['ArrowUp']) { keyAimDy = -1; } else if (keysPressed['ArrowDown']) { keyAimDy = 1;}
                    if (keyAimDx !== 0 || keyAimDy !== 0) { this.aimAngle = Math.atan2(keyAimDy, keyAimDx); }
                    else { if (this.lastMoveDx !== 0 || this.lastMoveDy !== 0) { this.aimAngle = Math.atan2(this.lastMoveDy, this.lastMoveDx); } }
                }
            }

            move(deltaTime) {
                let moveDx=0; let moveDy=0;
                if(keysPressed[this.controls.left]){moveDx-=1;} if(keysPressed[this.controls.right]){moveDx+=1;}
                if(keysPressed[this.controls.up]){moveDy-=1;} if(keysPressed[this.controls.down]){moveDy+=1;}
                const targetSpeed = (moveDx!==0||moveDy!==0)?this.speed:0; const acceleration=0.15; this.currentSpeed+=(targetSpeed-this.currentSpeed)*acceleration;
                const effectiveSpeed = this.currentSpeed*(deltaTime/(1000/60));
                if(moveDx!==0||moveDy!==0){ const dist=Math.sqrt(moveDx*moveDx+moveDy*moveDy); const nDx=moveDx/dist; const nDy=moveDy/dist; this.x+=nDx*effectiveSpeed; this.y+=nDy*effectiveSpeed; this.lastMoveDx=nDx; this.lastMoveDy=nDy; }
                this.x=Math.max(0,Math.min(this.x,CANVAS_WIDTH-this.width)); this.y=Math.max(0,Math.min(this.y,CANVAS_HEIGHT-this.height));
                this.engineParticleTimer+=deltaTime;
                if(this.engineParticleTimer>this.engineParticleInterval && this.currentSpeed > this.speed*0.2){
                    this.engineParticleTimer=0; const particleCount=Math.floor(this.currentSpeed/this.speed*2)+1;
                    for(let i=0;i<particleCount;i++){
                        const angleOffset=(Math.random()-0.5)*0.5;
                        const particleStartX = (this.x + this.width/2) - Math.cos(this.aimAngle) * (this.width * 0.4);
                        const particleStartY = (this.y + this.height/2) - Math.sin(this.aimAngle) * (this.height * 0.4);
                        const particleAngle=this.aimAngle+Math.PI+angleOffset;
                        const speed=(Math.random()*1+1)*(this.currentSpeed/this.speed);
                        this.engineParticles.push({ x:particleStartX, y:particleStartY, vx:Math.cos(particleAngle)*speed, vy:Math.sin(particleAngle)*speed, size:Math.random()*2+1, life:Math.random()*200+100, maxLife:300, color:`hsla(${20+Math.random()*30},100%,${60+Math.random()*20}%,${0.5+Math.random()*0.5})`, opacity:1 });
                    }
                }
                for(let i=this.engineParticles.length-1;i>=0;i--){ const p=this.engineParticles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=deltaTime; p.opacity=p.life/p.maxLife; if(p.life<=0)this.engineParticles.splice(i,1); }
            }

            shoot(triggeredByClick = false) {
                const currentTime = Date.now();
                const currentShootDelay = (Date.now() < this.rapidFireActiveUntil) ? this.shootDelayBase / 2 : this.shootDelayBase;
                const actualShootDelay = aimbotActive ? AIMBOT_SHOOT_DELAY : currentShootDelay;

                let attemptShot = false;
                if (aimbotActive) { attemptShot = true; }
                else if (mouseAimActive && triggeredByClick) { attemptShot = true; }
                else if (!mouseAimActive && keysPressed[this.controls.shoot]) { attemptShot = true; }

                if (attemptShot && (currentTime - this.lastShotTime > actualShootDelay)) {
                    this.lastShotTime = currentTime;
                    const numBullets = this.bulletCount;
                    const spreadAngle = numBullets > 1 ? Math.PI / 24 : 0;

                    const muzzleOffsetX = Math.cos(this.aimAngle) * (this.width * 0.5);
                    const muzzleOffsetY = Math.sin(this.aimAngle) * (this.height * 0.5);
                    createParticle( this.x+this.width/2 + muzzleOffsetX, this.y+this.height/2 + muzzleOffsetY, 5, `rgba(255,223,186,${0.5+Math.random()*0.5})`,[3,7],[2,4],[50,150],Math.PI/4 );
                    createParticle( this.x+this.width/2 + muzzleOffsetX, this.y+this.height/2 + muzzleOffsetY, 3, 'rgba(255,255,255,0.7)',[2,4],[1,2],[40,90],Math.PI/6 );

                    for (let i = 0; i < numBullets; i++) {
                        const angleOffset = (i - (numBullets - 1) / 2) * spreadAngle;
                        const currentAngle = this.aimAngle + angleOffset;
                        const cosA = Math.cos(currentAngle); const sinA = Math.sin(currentAngle);
                        const startX = this.x + this.width/2 + cosA * (this.width * 0.5);
                        const startY = this.y + this.height/2 + sinA * (this.height * 0.5);
                        this.projectiles.push(new Projectile( startX, startY, cosA*this.type.projectileSpeed, sinA*this.type.projectileSpeed, this.type.projectileColor ));
                    }
                }
            }
            fireBeam() {
                if (this.beamReady && !this.isFiringBeam) {
                    this.isFiringBeam = true; this.beamActiveStartTime = Date.now(); this.beamReady = false; this.beamCharge = 0;
                    let closestTarget = null; let minDistanceSq = Infinity;
                    gameTargets.forEach(target => {
                        const dx = target.x + target.width/2 - (this.x + this.width/2);
                        const dy = target.y + target.height/2 - (this.y + this.height/2);
                        const distSq = dx*dx + dy*dy;
                        if (distSq < minDistanceSq) {
                            minDistanceSq = distSq;
                            closestTarget = target;
                        }
                    });
                    if (closestTarget) {
                        const dx = closestTarget.x + closestTarget.width/2 - (this.x + this.width/2);
                        const dy = closestTarget.y + closestTarget.height/2 - (this.y + this.height/2);
                        this.beamTargetAngle = Math.atan2(dy, dx);
                    } else {
                        this.beamTargetAngle = this.aimAngle;
                    }
                    createParticle(this.x+this.width/2,this.y+this.height/2,20,'rgba(255,255,100,0.7)',[4,10],[3,6],[300,600],Math.PI*2);
                }
            }
            fireSmash() {
                if (this.smashReady && !this.isSmashing) {
                    this.smashReady = false; this.smashCharge = 0; this.isSmashing = true; this.smashRadius = 0;
                    createParticle(this.x+this.width/2,this.y+this.height/2,30,'rgba(255,100,50,0.7)',[5,15],[4,8],[400,800],Math.PI*2);
                }
            }

            update(deltaTime) {
                if (this.health <= 0) { return; }

                if (this.isInvulnerable && Date.now() >= this.invulnerableUntil) { this.isInvulnerable = false; }
                if (Date.now() >= this.rapidFireActiveUntil && this.shootDelayBase !== this.type.baseShootDelay) {
                    this.shootDelayBase = this.type.baseShootDelay;
                    showTemporaryPopup("Rapid Fire Worn Off!");
                }
                if (Date.now() >= this.shieldActiveUntil && this.shieldOpacity > 0 && !this.isInvulnerable) {
                }
                if (Date.now() >= this.speedBoostActiveUntil && this.speed !== this.type.baseSpeed) {
                    this.speed = this.type.baseSpeed;
                    showTemporaryPopup("Speed Boost Worn Off!");
                }


                if (this.isDivineProtectionActive && this.health < 20 && this.health > 0) {
                    this.health = 1000;
                    updateUI();
                }

                this.updateAimDirection(); this.move(deltaTime); this.shoot();
                if (!this.beamReady && !this.isFiringBeam) { this.beamCharge += deltaTime; if (this.beamCharge >= this.beamChargeMax) { this.beamCharge = this.beamChargeMax; this.beamReady = true;} }
                if (!this.smashReady && !this.isSmashing) { this.smashCharge += deltaTime; if (this.smashCharge >= this.smashChargeMax) { this.smashCharge = this.smashChargeMax; this.smashReady = true;}}
                if (keysPressed[this.controls.beam]) { this.fireBeam(); }
                if (this.isFiringBeam && (Date.now() - this.beamActiveStartTime >= this.beamActiveDuration)) { this.isFiringBeam = false; }
                if (this.isSmashing) {
                    this.smashRadius += this.smashExpansionSpeed * (deltaTime/(1000/60));
                    for (let i = gameTargets.length-1; i >= 0; i--) { const target = gameTargets[i]; const distSq = Math.pow(target.x+target.width/2-(this.x+this.width/2),2)+Math.pow(target.y+target.height/2-(this.y+this.height/2),2); if (distSq <= Math.pow(this.smashRadius,2)) { target.takeDamage(1000); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(i,1); playerScore += SCORE_PER_SMASH_HIT; }}}
                    if (this.smashRadius >= this.smashMaxRadius) { this.isSmashing = false; this.smashRadius = 0; showTemporaryPopup("SMASHED!"); }
                }
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    projectile.update(deltaTime);
                    if (projectile.shouldRemove) {
                        this.projectiles.splice(i, 1);
                    }
                }

                if (!this.isInvulnerable && !(Date.now() < this.shieldActiveUntil) && !this.isDivineProtectionActive && this.shieldOpacity > 0) {
                    this.shieldOpacity -= 0.02 * (deltaTime / 16.67); if (this.shieldOpacity < 0) this.shieldOpacity = 0;
                }
            }
            reset(fullReset = true) {
                this.health = (this.isDivineProtectionActive && !fullReset) ? 1000 : (gameMode === 'hell' ? 200 : FOX_TYPES["Ranger"].health);
                this.initialHealth = this.health;
                this.projectiles = []; this.x = 50; this.y = CANVAS_HEIGHT/2 - this.height/2;
                this.beamCharge = 0; this.beamReady = false; this.isFiringBeam = false; this.smashCharge = 0; this.smashReady = false; this.isSmashing = false; this.smashRadius = 0;
                this.lastMoveDx = 1; this.lastMoveDy = 0; this.aimAngle = 0; this.beamTargetAngle = 0; this.aimbotTarget = null;
                this.bulletCount = 1; this.engineParticles = []; this.currentSpeed = 0; this.shieldOpacity = 0;
                this.isInvulnerable = false; this.invulnerableUntil = 0;
                this.rapidFireActiveUntil = 0; this.shootDelayBase = this.type.baseShootDelay;
                this.shieldActiveUntil = 0;
                this.speedBoostActiveUntil = 0; this.speed = this.type.baseSpeed;
                if (fullReset) {
                    this.isDivineProtectionActive = false;
                    playerScore = 0;
                }
            }
            takeDamage(amount) {
                if (this.isInvulnerable || Date.now() < this.shieldActiveUntil) return;

                if (this.isDivineProtectionActive) {
                    if (this.health > 20) {
                        this.health -= amount;
                        if (this.health < 20) this.health = 20;
                    }
                    this.lastDamageTime = Date.now();
                    this.shieldOpacity = 1;
                    createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                    if (this.health < 0) this.health = 0;
                    return;
                }

                if (Date.now() - this.lastDamageTime < 200) return;
                this.health -= amount; this.lastDamageTime = Date.now(); this.shieldOpacity = 1;
                createParticle(this.x+this.width/2,this.y+this.height/2,10,'rgba(255,100,100,0.8)',[3,7],[1,4],[150,400]);
                if (this.health < 0) {this.health = 0;}
            }
            collectPowerUp(powerUpType) {
                createParticle(this.x + this.width/2, this.y + this.height/2, 15, 'rgba(200,200,255,0.7)', [4,9], [2,5], [200,500]);
                switch (powerUpType) {
                    case POWERUP_TYPES.MULTI_SHOT:
                        if (this.bulletCount < MAX_BULLET_COUNT) {
                            this.bulletCount++;
                            showTemporaryPopup(`Multi-Shot Level ${this.bulletCount}!`);
                        } else {
                            showTemporaryPopup(`Multi-Shot Maxed!`);
                        }
                        break;
                    case POWERUP_TYPES.RAPID_FIRE:
                        this.shootDelayBase = this.type.baseShootDelay / 2;
                        this.rapidFireActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Laser Fingers Activated!");
                        break;
                    case POWERUP_TYPES.SHIELD:
                        this.shieldActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Force Field Activated!");
                        break;
                    case POWERUP_TYPES.SPEED_BOOST:
                        this.speed = this.type.baseSpeed * 1.5;
                        this.speedBoostActiveUntil = Date.now() + POWERUP_DURATION;
                        showTemporaryPopup("Zoomies Activated!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GREEN:
                        this.health += 50;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("+50 Health!");
                        break;
                    case POWERUP_TYPES.HEALTH_PACK_GOLDEN:
                        this.health += 150;
                        if (this.isDivineProtectionActive) this.health = Math.min(this.health, 1000);
                        else this.initialHealth = Math.max(this.initialHealth, this.health);
                        showTemporaryPopup("Golden Health +150!");
                        break;
                }
                updateUI();
            }
        }

        class Projectile{
            constructor(x,y,sX,sY,c){
                this.x=x-PROJECTILE_WIDTH/2;this.y=y-PROJECTILE_HEIGHT/2; this.width=PROJECTILE_WIDTH;this.height=PROJECTILE_HEIGHT;
                this.speedX=sX;this.speedY=sY;this.color=c;
                this.trail = []; this.maxTrailLength = 5;
                this.createdAt = Date.now();
                this.maxLifetime = 5000;
                this.shouldRemove = false;
            }
            draw(){
                for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = 0.5 * (i / this.trail.length); ctx.fillStyle = `hsla(50, 100%, 70%, ${alpha})`; ctx.beginPath(); const trailWidth = this.width*0.6*((this.trail.length-i)/this.trail.length); const trailHeight = this.height*0.6*((this.trail.length-i)/this.trail.length); ctx.ellipse(point.x+this.width/2,point.y+this.height/2,trailWidth/2,trailHeight/2,0,0,Math.PI*2); ctx.fill(); }
                ctx.fillStyle=this.color; ctx.beginPath(); const r = Math.min(this.width,this.height)/3; ctx.moveTo(this.x+r,this.y); ctx.arcTo(this.x+this.width,this.y,this.x+this.width,this.y+this.height,r); ctx.arcTo(this.x+this.width,this.y+this.height,this.x,this.y+this.height,r); ctx.arcTo(this.x,this.y+this.height,this.x,this.y,r); ctx.arcTo(this.x,this.y,this.x+this.width,this.y,r); ctx.closePath(); ctx.fill();
                ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.ellipse(this.x+this.width/2,this.y+this.height/2,this.width/3,this.height/3,0,0,Math.PI*2); ctx.fill();
            }
            update(dT){
                const dF=dT/(1000/60);
                this.x+=this.speedX*dF; this.y+=this.speedY*dF;

                if (this.x <= 0) { this.x = 0; this.speedX = Math.abs(this.speedX); }
                else if (this.x + this.width >= CANVAS_WIDTH) { this.x = CANVAS_WIDTH - this.width; this.speedX = -Math.abs(this.speedX); }
                if (this.y <= 0) { this.y = 0; this.speedY = Math.abs(this.speedY); }
                else if (this.y + this.height >= CANVAS_HEIGHT) { this.y = CANVAS_HEIGHT - this.height; this.speedY = -Math.abs(this.speedY); }

                this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > this.maxTrailLength) { this.trail.shift(); }

                if (Date.now() - this.createdAt > this.maxLifetime) { this.shouldRemove = true; }
            }
        }

        let player1;
        let lastFrameTime = 0;

        function spawnTargets(count, isInitialSpawn = true) {
            const enemyTypes = ['purple','orange','green','blue']; let availableTypes = [...enemyTypes];
            if (gameMode === 'normal') {
                if(currentStage===1&&currentWave===1){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['blue','green'];}
                else if(currentStage===2&&currentWave===1){availableTypes=['green'];}
                else if(currentStage===2&&currentWave===2){availableTypes=['green','purple'];}
                else if(currentStage >= 3) {availableTypes = ['green','purple','orange'];}
            } else {
                if(currentStage===1&&currentWave===1){availableTypes=['blue','green'];}
                else if(currentStage===1&&currentWave===2){availableTypes=['blue','green','purple'];}
                else if(currentStage===1&&currentWave===3){availableTypes=['green','purple','orange'];}
                else {availableTypes = ['purple','orange','green'];}
            }

            let spawnMultiplier=1.0;
            if(gameMode==='hell')spawnMultiplier=isInitialSpawn? (targetsPerWaveBase * 1.1) :HELL_MODE_EXTRA_SPAWN_COUNT;
            else if(gameMode==='endless')spawnMultiplier=1.3;

            let numToSpawn=isInitialSpawn?count:spawnMultiplier;
            for(let i=0;i<numToSpawn;i++){ const side=Math.floor(Math.random()*4); let x,y; const margin=50; if(side===0){x=Math.random()*CANVAS_WIDTH;y=-margin-Math.random()*50;}else if(side===1){x=CANVAS_WIDTH+margin+Math.random()*50;y=Math.random()*CANVAS_HEIGHT;}else if(side===2){x=Math.random()*CANVAS_WIDTH;y=CANVAS_HEIGHT+margin+Math.random()*50;}else{x=-margin-Math.random()*50;y=Math.random()*CANVAS_HEIGHT;} const type=availableTypes[Math.floor(Math.random()*availableTypes.length)]; gameTargets.push(new Target(x,y,type)); }
        };
        function initializeStage(stage, wave) {
            currentStage = stage; currentWave = wave; gameTargets = []; enemyProjectiles = []; powerUps = [];
            if (gameMode === 'endless' || gameMode === 'hell') { stageDisplay.textContent = `${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)} Mode: Wave ${wave}`; }
            else { stageDisplay.textContent = `Stage ${stage}: Wave ${wave}`; }

            let baseTargetsForMode = (gameMode === 'hell') ? 3 : (gameMode === 'normal' ? 2 : 3);
            let stageIncrementFactor = (gameMode === 'hell') ? 2.2 : (gameMode === 'normal' ? 1.2 : 2);
            let waveIncrementFactor = (gameMode === 'hell') ? 1.2 : (gameMode === 'normal' ? 0.7 : 1);

            targetsPerWaveBase = baseTargetsForMode;

            let numToSpawn = targetsPerWaveBase + (wave - 1) * waveIncrementFactor + (stage - 1) * stageIncrementFactor;
            spawnTargets(Math.max(1, Math.floor(numToSpawn)), true);
            if (gameMode === 'hell') { setNextHellSpawnTime(); } updateUI();
        };

        function setNextPowerupSpawnTime() {
            nextPowerUpSpawnTime = Date.now() + Math.random() * (POWERUP_SPAWN_INTERVAL_MAX - POWERUP_SPAWN_INTERVAL_MIN) + POWERUP_SPAWN_INTERVAL_MIN;
        }
        function setNextGreenHealthPackSpawnTime() {
            nextGreenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GREEN_SPAWN_MAX - HEALTH_PACK_GREEN_SPAWN_MIN) + HEALTH_PACK_GREEN_SPAWN_MIN;
        }
        function setNextGoldenHealthPackSpawnTime() {
            nextGoldenHealthPackSpawnTime = Date.now() + Math.random() * (HEALTH_PACK_GOLDEN_SPAWN_MAX - HEALTH_PACK_GOLDEN_SPAWN_MIN) + HEALTH_PACK_GOLDEN_SPAWN_MIN;
        }

        function trySpawnPowerUp() {
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextPowerUpSpawnTime && powerUps.filter(p => p.type !== POWERUP_TYPES.HEALTH_PACK_GREEN && p.type !== POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                const availablePowerUps = [POWERUP_TYPES.MULTI_SHOT, POWERUP_TYPES.RAPID_FIRE, POWERUP_TYPES.SHIELD, POWERUP_TYPES.SPEED_BOOST];
                const randomType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                powerUps.push(new PowerUp(x,y,randomType));
                setNextPowerupSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGreenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GREEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GREEN));
                setNextGreenHealthPackSpawnTime();
            }
            if (gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextGoldenHealthPackSpawnTime && powerUps.filter(p => p.type === POWERUP_TYPES.HEALTH_PACK_GOLDEN).length < 1) {
                const x = Math.random()*(CANVAS_WIDTH-POWERUP_SIZE*2)+POWERUP_SIZE;
                const y = Math.random()*(CANVAS_HEIGHT-POWERUP_SIZE*2)+POWERUP_SIZE;
                powerUps.push(new PowerUp(x,y,POWERUP_TYPES.HEALTH_PACK_GOLDEN));
                setNextGoldenHealthPackSpawnTime();
            }
        }
        function setNextHellSpawnTime() { nextHellSpawnTime = Date.now() + HELL_MODE_SPAWN_INTERVAL * (0.7 + Math.random() * 0.2); }
        function trySpawnHellEnemies() {
            if (gameMode === 'hell' && gameRunning && !isGameEffectivelyPaused() && Date.now() >= nextHellSpawnTime) {
                spawnTargets(0, false); setNextHellSpawnTime();
            }
        }

        function checkCollisions() {
            if (!player1 || player1.isSmashing) { return; }
            player1.projectiles.forEach((p, pIndex) => { for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; if (p.x < target.x+target.width && p.x+p.width > target.x && p.y < target.y+target.height && p.y+p.height > target.y) { target.takeDamage(10); player1.projectiles.splice(pIndex,1); playerScore+=SCORE_PER_HIT; if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]); gameTargets.splice(tIndex,1); if(player1.isSmashing) { /* No screen shake if smash killed it */ } else { screenShake(5, 150); } } break; }}});
            if (player1.isFiringBeam) { const beamAngle = player1.beamTargetAngle; const beamLength = CANVAS_WIDTH*1.5; for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; const tCX = target.x+target.width/2; const tCY = target.y+target.height/2; const pCX = player1.x+player1.width/2; const pCY = player1.y+player1.height/2; const dx = tCX-pCX; const dy = tCY-pCY; const distToP = Math.sqrt(dx*dx+dy*dy); if (distToP < beamLength) { const angleToT = Math.atan2(dy,dx); const angleDiff = Math.abs(normalizeAngle(beamAngle-angleToT)); if (angleDiff < Math.atan2(BEAM_THICKNESS/2,distToP) || distToP < target.size*0.8 ) { target.takeDamage(player1.beamDamagePerFrame*(lastFrameTime-(player1.beamFrameTime||lastFrameTime))/(1000/60)); playerScore+=SCORE_PER_BEAM_FRAME; if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,15 + Math.floor(target.size/2),target.color,[3,target.size/2.5],[1.5,5],[350,800]); gameTargets.splice(tIndex,1); screenShake(3,100); }}}} player1.beamFrameTime = lastFrameTime; } else { player1.beamFrameTime = null; }
            for (let tIndex = gameTargets.length-1; tIndex >= 0; tIndex--) { const target = gameTargets[tIndex]; if (player1.x < target.x+target.width && player1.x+player1.width > target.x && player1.y < target.y+target.height && player1.y+player1.height > target.y) { player1.takeDamage(TARGET_CONTACT_DAMAGE); target.takeDamage(50); if (target.health <= 0) { createParticle(target.x+target.width/2,target.y+target.height/2,10,target.color,[3,8],[2,5],[200,500]); gameTargets.splice(tIndex,1); screenShake(5,150); } else { const dx = target.x-player1.x; const dy = target.y-player1.y; const dist = Math.sqrt(dx*dx+dy*dy)||1; target.x+=(dx/dist)*10; target.y+=(dy/dist)*10; }}}
            for (let epIndex = enemyProjectiles.length-1; epIndex >= 0; epIndex--) { const ep = enemyProjectiles[epIndex]; if (player1.health > 0 && ep.x < player1.x+player1.width && ep.x+ep.width > player1.x && ep.y < player1.y+player1.height && ep.y+ep.height > player1.y) { player1.takeDamage(ep.damage); enemyProjectiles.splice(epIndex,1); }}
            for (let puIndex = powerUps.length-1; puIndex >= 0; puIndex--) { const powerUp = powerUps[puIndex]; if (player1.x < powerUp.x+powerUp.size && player1.x+player1.width > powerUp.x && player1.y < powerUp.y+powerUp.size && player1.y+player1.height > powerUp.y) { player1.collectPowerUp(powerUp.type); powerUps.splice(puIndex,1); createParticle(powerUp.x + powerUp.size/2, powerUp.y + powerUp.size/2, 20, powerUp.pulseColor, [3,8], [2,5], [200,500]);}}
            if (!player1.isSmashing && gameTargets.length === 0 && gameRunning && player1.health > 0) { if (gameMode==='normal' && currentStage===COMPLETION_STAGE && currentWave===MAX_WAVES_PER_LEVEL) { showGameCompletionPopup(); } else { currentWave++; if (gameMode==='normal' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(10,targetsPerWaveBase+ (gameMode === 'hell' ? 2.2 : 1.2)); showTemporaryPopup(`Stage ${currentStage-1} Cleared! Onto Stage ${currentStage}!`); } else if (gameMode==='hell' && currentWave > MAX_WAVES_PER_LEVEL) { currentWave=1; currentStage++; targetsPerWaveBase=Math.min(20,targetsPerWaveBase+2.5); showTemporaryPopup(`Hell Stage ${currentStage-1} Cleared! Prepare for more!`); } else { showTemporaryPopup(`Wave ${currentWave-1} Cleared!`); } initializeStage(currentStage,currentWave); }}
            if (player1.health <= 0 && gameRunning) { announceOutcome("Game Over!", false); } updateUI();
        };

        function screenShake(intensity, duration) {
            document.body.style.transition = 'transform 0.05s';
            let startTime = Date.now();
            function shake() {
                let elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const x = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    const y = (Math.random() - 0.5) * intensity * (1 - elapsed / duration);
                    canvas.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(shake);
                } else {
                    canvas.style.transform = 'translate(0,0)';
                    document.body.style.transition = '';
                }
            }
            shake();
        }


        function showGameCompletionPopup() {
            gameRunning = false; messageText.textContent = "You have successfully beat all the stages! Now you can choose to go into Hell Mode, or Endless Mode.";
            codeInputSection.classList.add('hidden'); deathOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); completionOptions.classList.remove('hidden');
            showPopup(messageBox); currentPopupAction = 'game_complete';
        }

        function updateUI() {
            if (!player1) return;
            healthText.textContent = `Health: ${player1.health}`;
            const healthPercentage = (player1.health / player1.initialHealth) * 100;
            healthBarInner.style.width = `${Math.max(0, Math.min(100, healthPercentage))}%`;
            if (healthPercentage <= 25) {
                healthBarInner.style.backgroundColor = '#f56565';
            } else if (healthPercentage <= 60) {
                healthBarInner.style.backgroundColor = '#ecc94b';
            } else {
                healthBarInner.style.backgroundColor = '#48bb78';
            }

            scoreDisplay.textContent = `Score: ${playerScore}`;
            bulletCountDisplay.textContent = `Shots: ${player1.bulletCount}`;
            player1.updateChargeIndicators();
        };
        function announceOutcome(message, isVictory) {
            gameRunning = false; messageText.textContent = message;
            codeInputSection.classList.add('hidden'); completionOptions.classList.add('hidden'); hellConfirmOptions.classList.add('hidden'); deathOptions.classList.remove('hidden');
            actionButton1.textContent = "Respawn"; actionButton2.classList.remove('hidden'); actionButton2.textContent = "Revive";
            showPopup(messageBox); currentPopupAction = 'game_over_options';

            // MODIFIED: Changed prompt to use the globalPlayerName
            const playerNameForLeaderboard = globalPlayerName || `Fox${Math.floor(Math.random()*1000)}`;

            if (!isVictory) {
                // We'll just auto-save with the name they entered at the start.
                // const playerName = prompt("Game Over! Enter name for leaderboard:", `Fox${Math.floor(Math.random()*1000)}`);
                saveScoreToLeaderboard(playerNameForLeaderboard, playerScore);
                displayLeaderboard();
                leaderboardContainer.classList.remove('hidden');
            } else {
                leaderboardContainer.classList.add('hidden');
            }
        };
        actionButton1.addEventListener('click', () => {
            hidePopup(messageBox); currentPopupAction = null; leaderboardContainer.classList.add('hidden'); gameMode = 'normal'; document.body.className = 'select-none';
            applyTheme(storedTheme, { persist: false });
            player1.reset(true); currentStage = 1; currentWave = 1; targetsPerWaveBase = 2;
            initializeStage(1,1);
            gameRunning = true; lastFrameTime = performance.now(); requestAnimationFrame(gameLoop);
        });

        function saveScoreToLeaderboard(name, score) {
            let l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5')) || [];
            l.push({ name, score, date: new Date().toLocaleDateString(), stage: `${gameMode.substring(0,1).toUpperCase()}-S${currentStage}W${currentWave}` });
            l.sort((a,b) => b.score - a.score); l = l.slice(0,10); localStorage.setItem('ssbbLeaderboard_v6.5', JSON.stringify(l));
        };
        function displayLeaderboard() {
            leaderboardList.innerHTML = ""; const l = JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5')) || [];
            if (l.length === 0) { leaderboardList.innerHTML = "<li>No scores yet! Be the first!</li>"; return; }
            l.forEach(e => { const li = document.createElement('li'); li.textContent = `${e.name}: ${e.score} (${e.stage} - ${e.date})`; leaderboardList.appendChild(li); });
        };

        function gameLoop(currentTime) {
            if (!gameRunning && !isGameEffectivelyPaused()) {
            } else if (!gameRunning && isGameEffectivelyPaused()) {
                return;
            }

            const dT = Math.min(50, (currentTime - lastFrameTime) || (1000/60)); lastFrameTime = currentTime;

            if (!isGameEffectivelyPaused()) {
                trySpawnPowerUp(); trySpawnHellEnemies();
                if (player1) { player1.update(dT); }
                gameTargets.forEach(t => { if (player1) { t.update(player1.x,player1.y,dT,gameTargets); }});
                enemyProjectiles.forEach((ep,i) => { ep.update(dT); });
                powerUps.forEach((pu,i) => { if (pu.update(dT)) { powerUps.splice(i,1); } });
                if (player1) { player1.projectiles.forEach(p => p.update(dT)); }
                checkCollisions();
            }

            ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT); updateAndDrawParticles(dT);
            if (player1) { player1.draw(); }
            gameTargets.forEach(t => { t.draw(); });
            enemyProjectiles.forEach((ep) => { ep.draw(); });
            powerUps.forEach((pu) => { pu.draw(); });
            if (player1) { player1.projectiles.forEach(p => p.draw()); }

            requestAnimationFrame(gameLoop);
        };

        function resizeCanvas() {
            const gameArea = document.querySelector('.game-container');
            const headerEl = document.querySelector('h1');
            const taglineEl = document.querySelector('.game-tagline');
            const subheaderEl = document.querySelector('.cosmic-subheader');
            const uiTopBar = document.querySelector('.ui-top-bar');
            const stageEl = document.querySelector('#stageDisplay');
            const controlsInfoEl = document.querySelector('.controls-info');
            const buttonsEl = document.querySelector('.extra-buttons-container');

            const topUIHeight = (headerEl ? headerEl.offsetHeight : 0)
                + (taglineEl ? taglineEl.offsetHeight : 0)
                + (subheaderEl ? subheaderEl.offsetHeight : 0)
                + (uiTopBar ? uiTopBar.offsetHeight : 0)
                + (stageEl ? stageEl.offsetHeight : 0)
                + 40;

            const leaderboardHeight = leaderboardContainer.classList.contains('hidden') ? 0 : leaderboardContainer.offsetHeight;
            const bottomUIHeight = (controlsInfoEl ? controlsInfoEl.offsetHeight : 0)
                + (buttonsEl ? buttonsEl.offsetHeight : 0)
                + leaderboardHeight
                + 30;

            const availableWidth = window.innerWidth - 32;
            const availableHeight = window.innerHeight - topUIHeight - bottomUIHeight - 32;

            const aspectRatio = 16/9;
            let newWidth = availableWidth;
            let newHeight = newWidth / aspectRatio;

            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * aspectRatio;
            }

            if (gameArea) {
                newWidth = Math.min(newWidth, gameArea.clientWidth - 2);
            }
            newHeight = newWidth / aspectRatio;

            newWidth = Math.max(320, Math.min(newWidth, 2560));
            newHeight = Math.max(180, Math.min(newHeight, 1440));

            canvas.width = newWidth;
            canvas.height = newHeight;
            CANVAS_WIDTH = newWidth;
            CANVAS_HEIGHT = newHeight;

            if (player1) {
                player1.x = Math.max(0, Math.min(player1.x, CANVAS_WIDTH - player1.width));
                player1.y = Math.max(0, Math.min(player1.y, CANVAS_HEIGHT - player1.height));
                player1.smashMaxRadius = Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.8;
                player1.smashExpansionSpeed = player1.smashMaxRadius / 50;
            }
            updateUI();
        };

        function startGame() {
            applyTheme(storedTheme, { persist: false });
            document.body.classList.add('select-none');
            mainGameContent.classList.remove('hidden');
            player1 = new FoxPlayer(50, CANVAS_HEIGHT/2 - PLAYER_HEIGHT/2, "Ranger", { up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',shoot:'Space',beam:'KeyB',smash:'KeyX' });
            setNextPowerupSpawnTime();
            setNextGreenHealthPackSpawnTime();
            setNextGoldenHealthPackSpawnTime();
            resizeCanvas(); window.addEventListener('resize', resizeCanvas);
            initializeStage(1,1);
            displayLeaderboard();
            if (JSON.parse(localStorage.getItem('ssbbLeaderboard_v6.5'))?.length > 0) { leaderboardContainer.classList.remove('hidden'); }
            gameRunning = true;
            lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        showPopup(licensePopup);
        licenseKeyInput.focus();

    });
    </script>
</body>
</html>


